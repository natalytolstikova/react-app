{"ast":null,"code":"'use strict';\n\nconst net = require('node:net');\nconst assert = require('node:assert');\nconst util = require('./util');\nconst {\n  InvalidArgumentError,\n  ConnectTimeoutError\n} = require('./errors');\nlet tls; // include tls conditionally since it is not always available\n\n// TODO: session re-use does not wait for the first\n// connection to resolve the session and might therefore\n// resolve the same servername multiple times even when\n// re-use is enabled.\n\nlet SessionCache;\n// FIXME: remove workaround when the Node bug is fixed\n// https://github.com/nodejs/node/issues/49344#issuecomment-1741776308\nif (global.FinalizationRegistry && !(process.env.NODE_V8_COVERAGE || process.env.UNDICI_NO_FG)) {\n  SessionCache = class WeakSessionCache {\n    constructor(maxCachedSessions) {\n      this._maxCachedSessions = maxCachedSessions;\n      this._sessionCache = new Map();\n      this._sessionRegistry = new global.FinalizationRegistry(key => {\n        if (this._sessionCache.size < this._maxCachedSessions) {\n          return;\n        }\n        const ref = this._sessionCache.get(key);\n        if (ref !== undefined && ref.deref() === undefined) {\n          this._sessionCache.delete(key);\n        }\n      });\n    }\n    get(sessionKey) {\n      const ref = this._sessionCache.get(sessionKey);\n      return ref ? ref.deref() : null;\n    }\n    set(sessionKey, session) {\n      if (this._maxCachedSessions === 0) {\n        return;\n      }\n      this._sessionCache.set(sessionKey, new WeakRef(session));\n      this._sessionRegistry.register(session, sessionKey);\n    }\n  };\n} else {\n  SessionCache = class SimpleSessionCache {\n    constructor(maxCachedSessions) {\n      this._maxCachedSessions = maxCachedSessions;\n      this._sessionCache = new Map();\n    }\n    get(sessionKey) {\n      return this._sessionCache.get(sessionKey);\n    }\n    set(sessionKey, session) {\n      if (this._maxCachedSessions === 0) {\n        return;\n      }\n      if (this._sessionCache.size >= this._maxCachedSessions) {\n        // remove the oldest session\n        const {\n          value: oldestKey\n        } = this._sessionCache.keys().next();\n        this._sessionCache.delete(oldestKey);\n      }\n      this._sessionCache.set(sessionKey, session);\n    }\n  };\n}\nfunction buildConnector({\n  allowH2,\n  maxCachedSessions,\n  socketPath,\n  timeout,\n  session: customSession,\n  ...opts\n}) {\n  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n    throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero');\n  }\n  const options = {\n    path: socketPath,\n    ...opts\n  };\n  const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);\n  timeout = timeout == null ? 10e3 : timeout;\n  allowH2 = allowH2 != null ? allowH2 : false;\n  return function connect({\n    hostname,\n    host,\n    protocol,\n    port,\n    servername,\n    localAddress,\n    httpSocket\n  }, callback) {\n    let socket;\n    if (protocol === 'https:') {\n      if (!tls) {\n        tls = require('node:tls');\n      }\n      servername = servername || options.servername || util.getServerName(host) || null;\n      const sessionKey = servername || hostname;\n      const session = customSession || sessionCache.get(sessionKey) || null;\n      assert(sessionKey);\n      socket = tls.connect({\n        highWaterMark: 16384,\n        // TLS in node can't have bigger HWM anyway...\n        ...options,\n        servername,\n        session,\n        localAddress,\n        // TODO(HTTP/2): Add support for h2c\n        ALPNProtocols: allowH2 ? ['http/1.1', 'h2'] : ['http/1.1'],\n        socket: httpSocket,\n        // upgrade socket connection\n        port: port || 443,\n        host: hostname\n      });\n      socket.on('session', function (session) {\n        // TODO (fix): Can a session become invalid once established? Don't think so?\n        sessionCache.set(sessionKey, session);\n      });\n    } else {\n      assert(!httpSocket, 'httpSocket can only be sent on TLS update');\n      socket = net.connect({\n        highWaterMark: 64 * 1024,\n        // Same as nodejs fs streams.\n        ...options,\n        localAddress,\n        port: port || 80,\n        host: hostname\n      });\n    }\n\n    // Set TCP keep alive options on the socket here instead of in connect() for the case of assigning the socket\n    if (options.keepAlive == null || options.keepAlive) {\n      const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 60e3 : options.keepAliveInitialDelay;\n      socket.setKeepAlive(true, keepAliveInitialDelay);\n    }\n    const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);\n    socket.setNoDelay(true).once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {\n      cancelTimeout();\n      if (callback) {\n        const cb = callback;\n        callback = null;\n        cb(null, this);\n      }\n    }).on('error', function (err) {\n      cancelTimeout();\n      if (callback) {\n        const cb = callback;\n        callback = null;\n        cb(err);\n      }\n    });\n    return socket;\n  };\n}\nfunction setupTimeout(onConnectTimeout, timeout) {\n  if (!timeout) {\n    return () => {};\n  }\n  let s1 = null;\n  let s2 = null;\n  const timeoutId = setTimeout(() => {\n    // setImmediate is added to make sure that we prioritize socket error events over timeouts\n    s1 = setImmediate(() => {\n      if (process.platform === 'win32') {\n        // Windows needs an extra setImmediate probably due to implementation differences in the socket logic\n        s2 = setImmediate(() => onConnectTimeout());\n      } else {\n        onConnectTimeout();\n      }\n    });\n  }, timeout);\n  return () => {\n    clearTimeout(timeoutId);\n    clearImmediate(s1);\n    clearImmediate(s2);\n  };\n}\nfunction onConnectTimeout(socket) {\n  let message = 'Connect Timeout Error';\n  if (Array.isArray(socket.autoSelectFamilyAttemptedAddresses)) {\n    message += ` (attempted addresses: ${socket.autoSelectFamilyAttemptedAddresses.join(', ')})`;\n  }\n  util.destroy(socket, new ConnectTimeoutError(message));\n}\nmodule.exports = buildConnector;","map":{"version":3,"names":["net","require","assert","util","InvalidArgumentError","ConnectTimeoutError","tls","SessionCache","global","FinalizationRegistry","process","env","NODE_V8_COVERAGE","UNDICI_NO_FG","WeakSessionCache","constructor","maxCachedSessions","_maxCachedSessions","_sessionCache","Map","_sessionRegistry","key","size","ref","get","undefined","deref","delete","sessionKey","set","session","WeakRef","register","SimpleSessionCache","value","oldestKey","keys","next","buildConnector","allowH2","socketPath","timeout","customSession","opts","Number","isInteger","options","path","sessionCache","connect","hostname","host","protocol","port","servername","localAddress","httpSocket","callback","socket","getServerName","highWaterMark","ALPNProtocols","on","keepAlive","keepAliveInitialDelay","setKeepAlive","cancelTimeout","setupTimeout","onConnectTimeout","setNoDelay","once","cb","err","s1","s2","timeoutId","setTimeout","setImmediate","platform","clearTimeout","clearImmediate","message","Array","isArray","autoSelectFamilyAttemptedAddresses","join","destroy","module","exports"],"sources":["/Users/nataliia/PussyProjects/react-app/node_modules/undici/lib/core/connect.js"],"sourcesContent":["'use strict'\n\nconst net = require('node:net')\nconst assert = require('node:assert')\nconst util = require('./util')\nconst { InvalidArgumentError, ConnectTimeoutError } = require('./errors')\n\nlet tls // include tls conditionally since it is not always available\n\n// TODO: session re-use does not wait for the first\n// connection to resolve the session and might therefore\n// resolve the same servername multiple times even when\n// re-use is enabled.\n\nlet SessionCache\n// FIXME: remove workaround when the Node bug is fixed\n// https://github.com/nodejs/node/issues/49344#issuecomment-1741776308\nif (global.FinalizationRegistry && !(process.env.NODE_V8_COVERAGE || process.env.UNDICI_NO_FG)) {\n  SessionCache = class WeakSessionCache {\n    constructor (maxCachedSessions) {\n      this._maxCachedSessions = maxCachedSessions\n      this._sessionCache = new Map()\n      this._sessionRegistry = new global.FinalizationRegistry((key) => {\n        if (this._sessionCache.size < this._maxCachedSessions) {\n          return\n        }\n\n        const ref = this._sessionCache.get(key)\n        if (ref !== undefined && ref.deref() === undefined) {\n          this._sessionCache.delete(key)\n        }\n      })\n    }\n\n    get (sessionKey) {\n      const ref = this._sessionCache.get(sessionKey)\n      return ref ? ref.deref() : null\n    }\n\n    set (sessionKey, session) {\n      if (this._maxCachedSessions === 0) {\n        return\n      }\n\n      this._sessionCache.set(sessionKey, new WeakRef(session))\n      this._sessionRegistry.register(session, sessionKey)\n    }\n  }\n} else {\n  SessionCache = class SimpleSessionCache {\n    constructor (maxCachedSessions) {\n      this._maxCachedSessions = maxCachedSessions\n      this._sessionCache = new Map()\n    }\n\n    get (sessionKey) {\n      return this._sessionCache.get(sessionKey)\n    }\n\n    set (sessionKey, session) {\n      if (this._maxCachedSessions === 0) {\n        return\n      }\n\n      if (this._sessionCache.size >= this._maxCachedSessions) {\n        // remove the oldest session\n        const { value: oldestKey } = this._sessionCache.keys().next()\n        this._sessionCache.delete(oldestKey)\n      }\n\n      this._sessionCache.set(sessionKey, session)\n    }\n  }\n}\n\nfunction buildConnector ({ allowH2, maxCachedSessions, socketPath, timeout, session: customSession, ...opts }) {\n  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n    throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero')\n  }\n\n  const options = { path: socketPath, ...opts }\n  const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions)\n  timeout = timeout == null ? 10e3 : timeout\n  allowH2 = allowH2 != null ? allowH2 : false\n  return function connect ({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {\n    let socket\n    if (protocol === 'https:') {\n      if (!tls) {\n        tls = require('node:tls')\n      }\n      servername = servername || options.servername || util.getServerName(host) || null\n\n      const sessionKey = servername || hostname\n      const session = customSession || sessionCache.get(sessionKey) || null\n\n      assert(sessionKey)\n\n      socket = tls.connect({\n        highWaterMark: 16384, // TLS in node can't have bigger HWM anyway...\n        ...options,\n        servername,\n        session,\n        localAddress,\n        // TODO(HTTP/2): Add support for h2c\n        ALPNProtocols: allowH2 ? ['http/1.1', 'h2'] : ['http/1.1'],\n        socket: httpSocket, // upgrade socket connection\n        port: port || 443,\n        host: hostname\n      })\n\n      socket\n        .on('session', function (session) {\n          // TODO (fix): Can a session become invalid once established? Don't think so?\n          sessionCache.set(sessionKey, session)\n        })\n    } else {\n      assert(!httpSocket, 'httpSocket can only be sent on TLS update')\n      socket = net.connect({\n        highWaterMark: 64 * 1024, // Same as nodejs fs streams.\n        ...options,\n        localAddress,\n        port: port || 80,\n        host: hostname\n      })\n    }\n\n    // Set TCP keep alive options on the socket here instead of in connect() for the case of assigning the socket\n    if (options.keepAlive == null || options.keepAlive) {\n      const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 60e3 : options.keepAliveInitialDelay\n      socket.setKeepAlive(true, keepAliveInitialDelay)\n    }\n\n    const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout)\n\n    socket\n      .setNoDelay(true)\n      .once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {\n        cancelTimeout()\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(null, this)\n        }\n      })\n      .on('error', function (err) {\n        cancelTimeout()\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(err)\n        }\n      })\n\n    return socket\n  }\n}\n\nfunction setupTimeout (onConnectTimeout, timeout) {\n  if (!timeout) {\n    return () => {}\n  }\n\n  let s1 = null\n  let s2 = null\n  const timeoutId = setTimeout(() => {\n    // setImmediate is added to make sure that we prioritize socket error events over timeouts\n    s1 = setImmediate(() => {\n      if (process.platform === 'win32') {\n        // Windows needs an extra setImmediate probably due to implementation differences in the socket logic\n        s2 = setImmediate(() => onConnectTimeout())\n      } else {\n        onConnectTimeout()\n      }\n    })\n  }, timeout)\n  return () => {\n    clearTimeout(timeoutId)\n    clearImmediate(s1)\n    clearImmediate(s2)\n  }\n}\n\nfunction onConnectTimeout (socket) {\n  let message = 'Connect Timeout Error'\n  if (Array.isArray(socket.autoSelectFamilyAttemptedAddresses)) {\n    message += ` (attempted addresses: ${socket.autoSelectFamilyAttemptedAddresses.join(', ')})`\n  }\n  util.destroy(socket, new ConnectTimeoutError(message))\n}\n\nmodule.exports = buildConnector\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
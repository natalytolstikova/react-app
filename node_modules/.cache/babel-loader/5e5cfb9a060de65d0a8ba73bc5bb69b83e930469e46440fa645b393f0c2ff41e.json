{"ast":null,"code":"'use strict';\n\nconst assert = require('node:assert');\nconst {\n  pipeline\n} = require('node:stream');\nconst util = require('../core/util.js');\nconst {\n  RequestContentLengthMismatchError,\n  RequestAbortedError,\n  SocketError,\n  InformationalError\n} = require('../core/errors.js');\nconst {\n  kUrl,\n  kReset,\n  kClient,\n  kRunning,\n  kPending,\n  kQueue,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kSocket,\n  kStrictContentLength,\n  kOnError,\n  kMaxConcurrentStreams,\n  kHTTP2Session,\n  kResume\n} = require('../core/symbols.js');\nconst kOpenStreams = Symbol('open streams');\n\n// Experimental\nlet h2ExperimentalWarned = false;\n\n/** @type {import('http2')} */\nlet http2;\ntry {\n  http2 = require('node:http2');\n} catch {\n  // @ts-ignore\n  http2 = {\n    constants: {}\n  };\n}\nconst {\n  constants: {\n    HTTP2_HEADER_AUTHORITY,\n    HTTP2_HEADER_METHOD,\n    HTTP2_HEADER_PATH,\n    HTTP2_HEADER_SCHEME,\n    HTTP2_HEADER_CONTENT_LENGTH,\n    HTTP2_HEADER_EXPECT,\n    HTTP2_HEADER_STATUS\n  }\n} = http2;\nfunction parseH2Headers(headers) {\n  const result = [];\n  for (const [name, value] of Object.entries(headers)) {\n    // h2 may concat the header value by array\n    // e.g. Set-Cookie\n    if (Array.isArray(value)) {\n      for (const subvalue of value) {\n        // we need to provide each header value of header name\n        // because the headers handler expect name-value pair\n        result.push(Buffer.from(name), Buffer.from(subvalue));\n      }\n    } else {\n      result.push(Buffer.from(name), Buffer.from(value));\n    }\n  }\n  return result;\n}\nasync function connectH2(client, socket) {\n  client[kSocket] = socket;\n  if (!h2ExperimentalWarned) {\n    h2ExperimentalWarned = true;\n    process.emitWarning('H2 support is experimental, expect them to change at any time.', {\n      code: 'UNDICI-H2'\n    });\n  }\n  const session = http2.connect(client[kUrl], {\n    createConnection: () => socket,\n    peerMaxConcurrentStreams: client[kMaxConcurrentStreams]\n  });\n  session[kOpenStreams] = 0;\n  session[kClient] = client;\n  session[kSocket] = socket;\n  util.addListener(session, 'error', onHttp2SessionError);\n  util.addListener(session, 'frameError', onHttp2FrameError);\n  util.addListener(session, 'end', onHttp2SessionEnd);\n  util.addListener(session, 'goaway', onHTTP2GoAway);\n  util.addListener(session, 'close', function () {\n    const {\n      [kClient]: client\n    } = this;\n    const {\n      [kSocket]: socket\n    } = client;\n    const err = this[kSocket][kError] || this[kError] || new SocketError('closed', util.getSocketInfo(socket));\n    client[kHTTP2Session] = null;\n    if (client.destroyed) {\n      assert(client[kPending] === 0);\n\n      // Fail entire queue.\n      const requests = client[kQueue].splice(client[kRunningIdx]);\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i];\n        util.errorRequest(client, request, err);\n      }\n    }\n  });\n  session.unref();\n  client[kHTTP2Session] = session;\n  socket[kHTTP2Session] = session;\n  util.addListener(socket, 'error', function (err) {\n    assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID');\n    this[kError] = err;\n    this[kClient][kOnError](err);\n  });\n  util.addListener(socket, 'end', function () {\n    util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)));\n  });\n  util.addListener(socket, 'close', function () {\n    const err = this[kError] || new SocketError('closed', util.getSocketInfo(this));\n    client[kSocket] = null;\n    if (this[kHTTP2Session] != null) {\n      this[kHTTP2Session].destroy(err);\n    }\n    client[kPendingIdx] = client[kRunningIdx];\n    assert(client[kRunning] === 0);\n    client.emit('disconnect', client[kUrl], [client], err);\n    client[kResume]();\n  });\n  let closed = false;\n  socket.on('close', () => {\n    closed = true;\n  });\n  return {\n    version: 'h2',\n    defaultPipelining: Infinity,\n    write(...args) {\n      // TODO (fix): return\n      writeH2(client, ...args);\n    },\n    resume() {},\n    destroy(err, callback) {\n      if (closed) {\n        queueMicrotask(callback);\n      } else {\n        // Destroying the socket will trigger the session close\n        socket.destroy(err).on('close', callback);\n      }\n    },\n    get destroyed() {\n      return socket.destroyed;\n    },\n    busy() {\n      return false;\n    }\n  };\n}\nfunction onHttp2SessionError(err) {\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID');\n  this[kSocket][kError] = err;\n  this[kClient][kOnError](err);\n}\nfunction onHttp2FrameError(type, code, id) {\n  if (id === 0) {\n    const err = new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`);\n    this[kSocket][kError] = err;\n    this[kClient][kOnError](err);\n  }\n}\nfunction onHttp2SessionEnd() {\n  const err = new SocketError('other side closed', util.getSocketInfo(this[kSocket]));\n  this.destroy(err);\n  util.destroy(this[kSocket], err);\n}\n\n/**\n * This is the root cause of #3011\n * We need to handle GOAWAY frames properly, and trigger the session close\n * along with the socket right away\n */\nfunction onHTTP2GoAway(code) {\n  const err = new RequestAbortedError(`HTTP/2: \"GOAWAY\" frame received with code ${code}`);\n\n  // We need to trigger the close cycle right away\n  // We need to destroy the session and the socket\n  // Requests should be failed with the error after the current one is handled\n  this[kSocket][kError] = err;\n  this[kClient][kOnError](err);\n  this.unref();\n  util.destroy(this[kSocket], err);\n}\n\n// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2\nfunction shouldSendContentLength(method) {\n  return method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS' && method !== 'TRACE' && method !== 'CONNECT';\n}\nfunction writeH2(client, request) {\n  const session = client[kHTTP2Session];\n  const {\n    body,\n    method,\n    path,\n    host,\n    upgrade,\n    expectContinue,\n    signal,\n    headers: reqHeaders\n  } = request;\n  if (upgrade) {\n    util.errorRequest(client, request, new Error('Upgrade not supported for H2'));\n    return false;\n  }\n  if (request.aborted) {\n    return false;\n  }\n  const headers = {};\n  for (let n = 0; n < reqHeaders.length; n += 2) {\n    const key = reqHeaders[n + 0];\n    const val = reqHeaders[n + 1];\n    if (Array.isArray(val)) {\n      for (let i = 0; i < val.length; i++) {\n        if (headers[key]) {\n          headers[key] += `,${val[i]}`;\n        } else {\n          headers[key] = val[i];\n        }\n      }\n    } else {\n      headers[key] = val;\n    }\n  }\n\n  /** @type {import('node:http2').ClientHttp2Stream} */\n  let stream;\n  const {\n    hostname,\n    port\n  } = client[kUrl];\n  headers[HTTP2_HEADER_AUTHORITY] = host || `${hostname}${port ? `:${port}` : ''}`;\n  headers[HTTP2_HEADER_METHOD] = method;\n  const abort = err => {\n    if (request.aborted || request.completed) {\n      return;\n    }\n    err = err || new RequestAbortedError();\n    util.errorRequest(client, request, err);\n    if (stream != null) {\n      util.destroy(stream, err);\n    }\n\n    // We do not destroy the socket as we can continue using the session\n    // the stream get's destroyed and the session remains to create new streams\n    util.destroy(body, err);\n  };\n  try {\n    // We are already connected, streams are pending.\n    // We can call on connect, and wait for abort\n    request.onConnect(abort);\n  } catch (err) {\n    util.errorRequest(client, request, err);\n  }\n  if (method === 'CONNECT') {\n    session.ref();\n    // We are already connected, streams are pending, first request\n    // will create a new stream. We trigger a request to create the stream and wait until\n    // `ready` event is triggered\n    // We disabled endStream to allow the user to write to the stream\n    stream = session.request(headers, {\n      endStream: false,\n      signal\n    });\n    if (stream.id && !stream.pending) {\n      request.onUpgrade(null, null, stream);\n      ++session[kOpenStreams];\n    } else {\n      stream.once('ready', () => {\n        request.onUpgrade(null, null, stream);\n        ++session[kOpenStreams];\n      });\n    }\n    stream.once('close', () => {\n      session[kOpenStreams] -= 1;\n      if (session[kOpenStreams] === 0) session.unref();\n    });\n    return true;\n  }\n\n  // https://tools.ietf.org/html/rfc7540#section-8.3\n  // :path and :scheme headers must be omitted when sending CONNECT\n\n  headers[HTTP2_HEADER_PATH] = path;\n  headers[HTTP2_HEADER_SCHEME] = 'https';\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = method === 'PUT' || method === 'POST' || method === 'PATCH';\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0);\n  }\n  let contentLength = util.bodyLength(body);\n  if (contentLength == null) {\n    contentLength = request.contentLength;\n  }\n  if (contentLength === 0 || !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null;\n  }\n\n  // https://github.com/nodejs/undici/issues/2046\n  // A user agent may send a Content-Length header with 0 value, this should be allowed.\n  if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      util.errorRequest(client, request, new RequestContentLengthMismatchError());\n      return false;\n    }\n    process.emitWarning(new RequestContentLengthMismatchError());\n  }\n  if (contentLength != null) {\n    assert(body, 'no body must not have content length');\n    headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;\n  }\n  session.ref();\n  const shouldEndStream = method === 'GET' || method === 'HEAD' || body === null;\n  if (expectContinue) {\n    headers[HTTP2_HEADER_EXPECT] = '100-continue';\n    stream = session.request(headers, {\n      endStream: shouldEndStream,\n      signal\n    });\n    stream.once('continue', writeBodyH2);\n  } else {\n    stream = session.request(headers, {\n      endStream: shouldEndStream,\n      signal\n    });\n    writeBodyH2();\n  }\n\n  // Increment counter as we have new streams open\n  ++session[kOpenStreams];\n  stream.once('response', headers => {\n    const {\n      [HTTP2_HEADER_STATUS]: statusCode,\n      ...realHeaders\n    } = headers;\n    request.onResponseStarted();\n\n    // Due to the stream nature, it is possible we face a race condition\n    // where the stream has been assigned, but the request has been aborted\n    // the request remains in-flight and headers hasn't been received yet\n    // for those scenarios, best effort is to destroy the stream immediately\n    // as there's no value to keep it open.\n    if (request.aborted) {\n      const err = new RequestAbortedError();\n      util.errorRequest(client, request, err);\n      util.destroy(stream, err);\n      return;\n    }\n    if (request.onHeaders(Number(statusCode), parseH2Headers(realHeaders), stream.resume.bind(stream), '') === false) {\n      stream.pause();\n    }\n    stream.on('data', chunk => {\n      if (request.onData(chunk) === false) {\n        stream.pause();\n      }\n    });\n  });\n  stream.once('end', () => {\n    // When state is null, it means we haven't consumed body and the stream still do not have\n    // a state.\n    // Present specially when using pipeline or stream\n    if (stream.state?.state == null || stream.state.state < 6) {\n      request.onComplete([]);\n      return;\n    }\n\n    // Stream is closed or half-closed-remote (6), decrement counter and cleanup\n    // It does not have sense to continue working with the stream as we do not\n    // have yet RST_STREAM support on client-side\n    if (session[kOpenStreams] === 0) {\n      session.unref();\n    }\n    abort(new InformationalError('HTTP/2: stream half-closed (remote)'));\n  });\n  stream.once('close', () => {\n    session[kOpenStreams] -= 1;\n    if (session[kOpenStreams] === 0) {\n      session.unref();\n    }\n  });\n  stream.once('error', function (err) {\n    abort(err);\n  });\n  stream.once('frameError', (type, code) => {\n    abort(new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`));\n  });\n\n  // stream.on('aborted', () => {\n  //   // TODO(HTTP/2): Support aborted\n  // })\n\n  // stream.on('timeout', () => {\n  //   // TODO(HTTP/2): Support timeout\n  // })\n\n  // stream.on('push', headers => {\n  //   // TODO(HTTP/2): Support push\n  // })\n\n  // stream.on('trailers', headers => {\n  //   // TODO(HTTP/2): Support trailers\n  // })\n\n  return true;\n  function writeBodyH2() {\n    /* istanbul ignore else: assertion */\n    if (!body || contentLength === 0) {\n      writeBuffer(abort, stream, null, client, request, client[kSocket], contentLength, expectsPayload);\n    } else if (util.isBuffer(body)) {\n      writeBuffer(abort, stream, body, client, request, client[kSocket], contentLength, expectsPayload);\n    } else if (util.isBlobLike(body)) {\n      if (typeof body.stream === 'function') {\n        writeIterable(abort, stream, body.stream(), client, request, client[kSocket], contentLength, expectsPayload);\n      } else {\n        writeBlob(abort, stream, body, client, request, client[kSocket], contentLength, expectsPayload);\n      }\n    } else if (util.isStream(body)) {\n      writeStream(abort, client[kSocket], expectsPayload, stream, body, client, request, contentLength);\n    } else if (util.isIterable(body)) {\n      writeIterable(abort, stream, body, client, request, client[kSocket], contentLength, expectsPayload);\n    } else {\n      assert(false);\n    }\n  }\n}\nfunction writeBuffer(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {\n  try {\n    if (body != null && util.isBuffer(body)) {\n      assert(contentLength === body.byteLength, 'buffer body must have content length');\n      h2stream.cork();\n      h2stream.write(body);\n      h2stream.uncork();\n      h2stream.end();\n      request.onBodySent(body);\n    }\n    if (!expectsPayload) {\n      socket[kReset] = true;\n    }\n    request.onRequestSent();\n    client[kResume]();\n  } catch (error) {\n    abort(error);\n  }\n}\nfunction writeStream(abort, socket, expectsPayload, h2stream, body, client, request, contentLength) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined');\n\n  // For HTTP/2, is enough to pipe the stream\n  const pipe = pipeline(body, h2stream, err => {\n    if (err) {\n      util.destroy(pipe, err);\n      abort(err);\n    } else {\n      util.removeAllListeners(pipe);\n      request.onRequestSent();\n      if (!expectsPayload) {\n        socket[kReset] = true;\n      }\n      client[kResume]();\n    }\n  });\n  util.addListener(pipe, 'data', onPipeData);\n  function onPipeData(chunk) {\n    request.onBodySent(chunk);\n  }\n}\nasync function writeBlob(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {\n  assert(contentLength === body.size, 'blob body must have content length');\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError();\n    }\n    const buffer = Buffer.from(await body.arrayBuffer());\n    h2stream.cork();\n    h2stream.write(buffer);\n    h2stream.uncork();\n    h2stream.end();\n    request.onBodySent(buffer);\n    request.onRequestSent();\n    if (!expectsPayload) {\n      socket[kReset] = true;\n    }\n    client[kResume]();\n  } catch (err) {\n    abort(err);\n  }\n}\nasync function writeIterable(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined');\n  let callback = null;\n  function onDrain() {\n    if (callback) {\n      const cb = callback;\n      callback = null;\n      cb();\n    }\n  }\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null);\n    if (socket[kError]) {\n      reject(socket[kError]);\n    } else {\n      callback = resolve;\n    }\n  });\n  h2stream.on('close', onDrain).on('drain', onDrain);\n  try {\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError];\n      }\n      const res = h2stream.write(chunk);\n      request.onBodySent(chunk);\n      if (!res) {\n        await waitForDrain();\n      }\n    }\n    h2stream.end();\n    request.onRequestSent();\n    if (!expectsPayload) {\n      socket[kReset] = true;\n    }\n    client[kResume]();\n  } catch (err) {\n    abort(err);\n  } finally {\n    h2stream.off('close', onDrain).off('drain', onDrain);\n  }\n}\nmodule.exports = connectH2;","map":{"version":3,"names":["assert","require","pipeline","util","RequestContentLengthMismatchError","RequestAbortedError","SocketError","InformationalError","kUrl","kReset","kClient","kRunning","kPending","kQueue","kPendingIdx","kRunningIdx","kError","kSocket","kStrictContentLength","kOnError","kMaxConcurrentStreams","kHTTP2Session","kResume","kOpenStreams","Symbol","h2ExperimentalWarned","http2","constants","HTTP2_HEADER_AUTHORITY","HTTP2_HEADER_METHOD","HTTP2_HEADER_PATH","HTTP2_HEADER_SCHEME","HTTP2_HEADER_CONTENT_LENGTH","HTTP2_HEADER_EXPECT","HTTP2_HEADER_STATUS","parseH2Headers","headers","result","name","value","Object","entries","Array","isArray","subvalue","push","Buffer","from","connectH2","client","socket","process","emitWarning","code","session","connect","createConnection","peerMaxConcurrentStreams","addListener","onHttp2SessionError","onHttp2FrameError","onHttp2SessionEnd","onHTTP2GoAway","err","getSocketInfo","destroyed","requests","splice","i","length","request","errorRequest","unref","destroy","emit","closed","on","version","defaultPipelining","Infinity","write","args","writeH2","resume","callback","queueMicrotask","busy","type","id","shouldSendContentLength","method","body","path","host","upgrade","expectContinue","signal","reqHeaders","Error","aborted","n","key","val","stream","hostname","port","abort","completed","onConnect","ref","endStream","pending","onUpgrade","once","expectsPayload","read","contentLength","bodyLength","shouldEndStream","writeBodyH2","statusCode","realHeaders","onResponseStarted","onHeaders","Number","bind","pause","chunk","onData","state","onComplete","writeBuffer","isBuffer","isBlobLike","writeIterable","writeBlob","isStream","writeStream","isIterable","h2stream","byteLength","cork","uncork","end","onBodySent","onRequestSent","error","pipe","removeAllListeners","onPipeData","size","buffer","arrayBuffer","onDrain","cb","waitForDrain","Promise","resolve","reject","res","off","module","exports"],"sources":["/Users/nataliia/PussyProjects/react-app/node_modules/undici/lib/dispatcher/client-h2.js"],"sourcesContent":["'use strict'\n\nconst assert = require('node:assert')\nconst { pipeline } = require('node:stream')\nconst util = require('../core/util.js')\nconst {\n  RequestContentLengthMismatchError,\n  RequestAbortedError,\n  SocketError,\n  InformationalError\n} = require('../core/errors.js')\nconst {\n  kUrl,\n  kReset,\n  kClient,\n  kRunning,\n  kPending,\n  kQueue,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kSocket,\n  kStrictContentLength,\n  kOnError,\n  kMaxConcurrentStreams,\n  kHTTP2Session,\n  kResume\n} = require('../core/symbols.js')\n\nconst kOpenStreams = Symbol('open streams')\n\n// Experimental\nlet h2ExperimentalWarned = false\n\n/** @type {import('http2')} */\nlet http2\ntry {\n  http2 = require('node:http2')\n} catch {\n  // @ts-ignore\n  http2 = { constants: {} }\n}\n\nconst {\n  constants: {\n    HTTP2_HEADER_AUTHORITY,\n    HTTP2_HEADER_METHOD,\n    HTTP2_HEADER_PATH,\n    HTTP2_HEADER_SCHEME,\n    HTTP2_HEADER_CONTENT_LENGTH,\n    HTTP2_HEADER_EXPECT,\n    HTTP2_HEADER_STATUS\n  }\n} = http2\n\nfunction parseH2Headers (headers) {\n  const result = []\n\n  for (const [name, value] of Object.entries(headers)) {\n    // h2 may concat the header value by array\n    // e.g. Set-Cookie\n    if (Array.isArray(value)) {\n      for (const subvalue of value) {\n        // we need to provide each header value of header name\n        // because the headers handler expect name-value pair\n        result.push(Buffer.from(name), Buffer.from(subvalue))\n      }\n    } else {\n      result.push(Buffer.from(name), Buffer.from(value))\n    }\n  }\n\n  return result\n}\n\nasync function connectH2 (client, socket) {\n  client[kSocket] = socket\n\n  if (!h2ExperimentalWarned) {\n    h2ExperimentalWarned = true\n    process.emitWarning('H2 support is experimental, expect them to change at any time.', {\n      code: 'UNDICI-H2'\n    })\n  }\n\n  const session = http2.connect(client[kUrl], {\n    createConnection: () => socket,\n    peerMaxConcurrentStreams: client[kMaxConcurrentStreams]\n  })\n\n  session[kOpenStreams] = 0\n  session[kClient] = client\n  session[kSocket] = socket\n\n  util.addListener(session, 'error', onHttp2SessionError)\n  util.addListener(session, 'frameError', onHttp2FrameError)\n  util.addListener(session, 'end', onHttp2SessionEnd)\n  util.addListener(session, 'goaway', onHTTP2GoAway)\n  util.addListener(session, 'close', function () {\n    const { [kClient]: client } = this\n    const { [kSocket]: socket } = client\n\n    const err = this[kSocket][kError] || this[kError] || new SocketError('closed', util.getSocketInfo(socket))\n\n    client[kHTTP2Session] = null\n\n    if (client.destroyed) {\n      assert(client[kPending] === 0)\n\n      // Fail entire queue.\n      const requests = client[kQueue].splice(client[kRunningIdx])\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i]\n        util.errorRequest(client, request, err)\n      }\n    }\n  })\n\n  session.unref()\n\n  client[kHTTP2Session] = session\n  socket[kHTTP2Session] = session\n\n  util.addListener(socket, 'error', function (err) {\n    assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n    this[kError] = err\n\n    this[kClient][kOnError](err)\n  })\n\n  util.addListener(socket, 'end', function () {\n    util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)))\n  })\n\n  util.addListener(socket, 'close', function () {\n    const err = this[kError] || new SocketError('closed', util.getSocketInfo(this))\n\n    client[kSocket] = null\n\n    if (this[kHTTP2Session] != null) {\n      this[kHTTP2Session].destroy(err)\n    }\n\n    client[kPendingIdx] = client[kRunningIdx]\n\n    assert(client[kRunning] === 0)\n\n    client.emit('disconnect', client[kUrl], [client], err)\n\n    client[kResume]()\n  })\n\n  let closed = false\n  socket.on('close', () => {\n    closed = true\n  })\n\n  return {\n    version: 'h2',\n    defaultPipelining: Infinity,\n    write (...args) {\n      // TODO (fix): return\n      writeH2(client, ...args)\n    },\n    resume () {\n\n    },\n    destroy (err, callback) {\n      if (closed) {\n        queueMicrotask(callback)\n      } else {\n        // Destroying the socket will trigger the session close\n        socket.destroy(err).on('close', callback)\n      }\n    },\n    get destroyed () {\n      return socket.destroyed\n    },\n    busy () {\n      return false\n    }\n  }\n}\n\nfunction onHttp2SessionError (err) {\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n  this[kSocket][kError] = err\n  this[kClient][kOnError](err)\n}\n\nfunction onHttp2FrameError (type, code, id) {\n  if (id === 0) {\n    const err = new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`)\n    this[kSocket][kError] = err\n    this[kClient][kOnError](err)\n  }\n}\n\nfunction onHttp2SessionEnd () {\n  const err = new SocketError('other side closed', util.getSocketInfo(this[kSocket]))\n  this.destroy(err)\n  util.destroy(this[kSocket], err)\n}\n\n/**\n * This is the root cause of #3011\n * We need to handle GOAWAY frames properly, and trigger the session close\n * along with the socket right away\n */\nfunction onHTTP2GoAway (code) {\n  const err = new RequestAbortedError(`HTTP/2: \"GOAWAY\" frame received with code ${code}`)\n\n  // We need to trigger the close cycle right away\n  // We need to destroy the session and the socket\n  // Requests should be failed with the error after the current one is handled\n  this[kSocket][kError] = err\n  this[kClient][kOnError](err)\n\n  this.unref()\n\n  util.destroy(this[kSocket], err)\n}\n\n// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2\nfunction shouldSendContentLength (method) {\n  return method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS' && method !== 'TRACE' && method !== 'CONNECT'\n}\n\nfunction writeH2 (client, request) {\n  const session = client[kHTTP2Session]\n  const { body, method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request\n\n  if (upgrade) {\n    util.errorRequest(client, request, new Error('Upgrade not supported for H2'))\n    return false\n  }\n\n  if (request.aborted) {\n    return false\n  }\n\n  const headers = {}\n  for (let n = 0; n < reqHeaders.length; n += 2) {\n    const key = reqHeaders[n + 0]\n    const val = reqHeaders[n + 1]\n\n    if (Array.isArray(val)) {\n      for (let i = 0; i < val.length; i++) {\n        if (headers[key]) {\n          headers[key] += `,${val[i]}`\n        } else {\n          headers[key] = val[i]\n        }\n      }\n    } else {\n      headers[key] = val\n    }\n  }\n\n  /** @type {import('node:http2').ClientHttp2Stream} */\n  let stream\n\n  const { hostname, port } = client[kUrl]\n\n  headers[HTTP2_HEADER_AUTHORITY] = host || `${hostname}${port ? `:${port}` : ''}`\n  headers[HTTP2_HEADER_METHOD] = method\n\n  const abort = (err) => {\n    if (request.aborted || request.completed) {\n      return\n    }\n\n    err = err || new RequestAbortedError()\n\n    util.errorRequest(client, request, err)\n\n    if (stream != null) {\n      util.destroy(stream, err)\n    }\n\n    // We do not destroy the socket as we can continue using the session\n    // the stream get's destroyed and the session remains to create new streams\n    util.destroy(body, err)\n  }\n\n  try {\n    // We are already connected, streams are pending.\n    // We can call on connect, and wait for abort\n    request.onConnect(abort)\n  } catch (err) {\n    util.errorRequest(client, request, err)\n  }\n\n  if (method === 'CONNECT') {\n    session.ref()\n    // We are already connected, streams are pending, first request\n    // will create a new stream. We trigger a request to create the stream and wait until\n    // `ready` event is triggered\n    // We disabled endStream to allow the user to write to the stream\n    stream = session.request(headers, { endStream: false, signal })\n\n    if (stream.id && !stream.pending) {\n      request.onUpgrade(null, null, stream)\n      ++session[kOpenStreams]\n    } else {\n      stream.once('ready', () => {\n        request.onUpgrade(null, null, stream)\n        ++session[kOpenStreams]\n      })\n    }\n\n    stream.once('close', () => {\n      session[kOpenStreams] -= 1\n      if (session[kOpenStreams] === 0) session.unref()\n    })\n\n    return true\n  }\n\n  // https://tools.ietf.org/html/rfc7540#section-8.3\n  // :path and :scheme headers must be omitted when sending CONNECT\n\n  headers[HTTP2_HEADER_PATH] = path\n  headers[HTTP2_HEADER_SCHEME] = 'https'\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = (\n    method === 'PUT' ||\n    method === 'POST' ||\n    method === 'PATCH'\n  )\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0)\n  }\n\n  let contentLength = util.bodyLength(body)\n\n  if (contentLength == null) {\n    contentLength = request.contentLength\n  }\n\n  if (contentLength === 0 || !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null\n  }\n\n  // https://github.com/nodejs/undici/issues/2046\n  // A user agent may send a Content-Length header with 0 value, this should be allowed.\n  if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      util.errorRequest(client, request, new RequestContentLengthMismatchError())\n      return false\n    }\n\n    process.emitWarning(new RequestContentLengthMismatchError())\n  }\n\n  if (contentLength != null) {\n    assert(body, 'no body must not have content length')\n    headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`\n  }\n\n  session.ref()\n\n  const shouldEndStream = method === 'GET' || method === 'HEAD' || body === null\n  if (expectContinue) {\n    headers[HTTP2_HEADER_EXPECT] = '100-continue'\n    stream = session.request(headers, { endStream: shouldEndStream, signal })\n\n    stream.once('continue', writeBodyH2)\n  } else {\n    stream = session.request(headers, {\n      endStream: shouldEndStream,\n      signal\n    })\n    writeBodyH2()\n  }\n\n  // Increment counter as we have new streams open\n  ++session[kOpenStreams]\n\n  stream.once('response', headers => {\n    const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers\n    request.onResponseStarted()\n\n    // Due to the stream nature, it is possible we face a race condition\n    // where the stream has been assigned, but the request has been aborted\n    // the request remains in-flight and headers hasn't been received yet\n    // for those scenarios, best effort is to destroy the stream immediately\n    // as there's no value to keep it open.\n    if (request.aborted) {\n      const err = new RequestAbortedError()\n      util.errorRequest(client, request, err)\n      util.destroy(stream, err)\n      return\n    }\n\n    if (request.onHeaders(Number(statusCode), parseH2Headers(realHeaders), stream.resume.bind(stream), '') === false) {\n      stream.pause()\n    }\n\n    stream.on('data', (chunk) => {\n      if (request.onData(chunk) === false) {\n        stream.pause()\n      }\n    })\n  })\n\n  stream.once('end', () => {\n    // When state is null, it means we haven't consumed body and the stream still do not have\n    // a state.\n    // Present specially when using pipeline or stream\n    if (stream.state?.state == null || stream.state.state < 6) {\n      request.onComplete([])\n      return\n    }\n\n    // Stream is closed or half-closed-remote (6), decrement counter and cleanup\n    // It does not have sense to continue working with the stream as we do not\n    // have yet RST_STREAM support on client-side\n    if (session[kOpenStreams] === 0) {\n      session.unref()\n    }\n\n    abort(new InformationalError('HTTP/2: stream half-closed (remote)'))\n  })\n\n  stream.once('close', () => {\n    session[kOpenStreams] -= 1\n    if (session[kOpenStreams] === 0) {\n      session.unref()\n    }\n  })\n\n  stream.once('error', function (err) {\n    abort(err)\n  })\n\n  stream.once('frameError', (type, code) => {\n    abort(new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`))\n  })\n\n  // stream.on('aborted', () => {\n  //   // TODO(HTTP/2): Support aborted\n  // })\n\n  // stream.on('timeout', () => {\n  //   // TODO(HTTP/2): Support timeout\n  // })\n\n  // stream.on('push', headers => {\n  //   // TODO(HTTP/2): Support push\n  // })\n\n  // stream.on('trailers', headers => {\n  //   // TODO(HTTP/2): Support trailers\n  // })\n\n  return true\n\n  function writeBodyH2 () {\n    /* istanbul ignore else: assertion */\n    if (!body || contentLength === 0) {\n      writeBuffer(\n        abort,\n        stream,\n        null,\n        client,\n        request,\n        client[kSocket],\n        contentLength,\n        expectsPayload\n      )\n    } else if (util.isBuffer(body)) {\n      writeBuffer(\n        abort,\n        stream,\n        body,\n        client,\n        request,\n        client[kSocket],\n        contentLength,\n        expectsPayload\n      )\n    } else if (util.isBlobLike(body)) {\n      if (typeof body.stream === 'function') {\n        writeIterable(\n          abort,\n          stream,\n          body.stream(),\n          client,\n          request,\n          client[kSocket],\n          contentLength,\n          expectsPayload\n        )\n      } else {\n        writeBlob(\n          abort,\n          stream,\n          body,\n          client,\n          request,\n          client[kSocket],\n          contentLength,\n          expectsPayload\n        )\n      }\n    } else if (util.isStream(body)) {\n      writeStream(\n        abort,\n        client[kSocket],\n        expectsPayload,\n        stream,\n        body,\n        client,\n        request,\n        contentLength\n      )\n    } else if (util.isIterable(body)) {\n      writeIterable(\n        abort,\n        stream,\n        body,\n        client,\n        request,\n        client[kSocket],\n        contentLength,\n        expectsPayload\n      )\n    } else {\n      assert(false)\n    }\n  }\n}\n\nfunction writeBuffer (abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {\n  try {\n    if (body != null && util.isBuffer(body)) {\n      assert(contentLength === body.byteLength, 'buffer body must have content length')\n      h2stream.cork()\n      h2stream.write(body)\n      h2stream.uncork()\n      h2stream.end()\n\n      request.onBodySent(body)\n    }\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    request.onRequestSent()\n    client[kResume]()\n  } catch (error) {\n    abort(error)\n  }\n}\n\nfunction writeStream (abort, socket, expectsPayload, h2stream, body, client, request, contentLength) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined')\n\n  // For HTTP/2, is enough to pipe the stream\n  const pipe = pipeline(\n    body,\n    h2stream,\n    (err) => {\n      if (err) {\n        util.destroy(pipe, err)\n        abort(err)\n      } else {\n        util.removeAllListeners(pipe)\n        request.onRequestSent()\n\n        if (!expectsPayload) {\n          socket[kReset] = true\n        }\n\n        client[kResume]()\n      }\n    }\n  )\n\n  util.addListener(pipe, 'data', onPipeData)\n\n  function onPipeData (chunk) {\n    request.onBodySent(chunk)\n  }\n}\n\nasync function writeBlob (abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {\n  assert(contentLength === body.size, 'blob body must have content length')\n\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError()\n    }\n\n    const buffer = Buffer.from(await body.arrayBuffer())\n\n    h2stream.cork()\n    h2stream.write(buffer)\n    h2stream.uncork()\n    h2stream.end()\n\n    request.onBodySent(buffer)\n    request.onRequestSent()\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    client[kResume]()\n  } catch (err) {\n    abort(err)\n  }\n}\n\nasync function writeIterable (abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined')\n\n  let callback = null\n  function onDrain () {\n    if (callback) {\n      const cb = callback\n      callback = null\n      cb()\n    }\n  }\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null)\n\n    if (socket[kError]) {\n      reject(socket[kError])\n    } else {\n      callback = resolve\n    }\n  })\n\n  h2stream\n    .on('close', onDrain)\n    .on('drain', onDrain)\n\n  try {\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError]\n      }\n\n      const res = h2stream.write(chunk)\n      request.onBodySent(chunk)\n      if (!res) {\n        await waitForDrain()\n      }\n    }\n\n    h2stream.end()\n\n    request.onRequestSent()\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    client[kResume]()\n  } catch (err) {\n    abort(err)\n  } finally {\n    h2stream\n      .off('close', onDrain)\n      .off('drain', onDrain)\n  }\n}\n\nmodule.exports = connectH2\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"'use strict';\n\nconst {\n  Transform\n} = require('node:stream');\nconst {\n  isASCIINumber,\n  isValidLastEventId\n} = require('./util');\n\n/**\n * @type {number[]} BOM\n */\nconst BOM = [0xEF, 0xBB, 0xBF];\n/**\n * @type {10} LF\n */\nconst LF = 0x0A;\n/**\n * @type {13} CR\n */\nconst CR = 0x0D;\n/**\n * @type {58} COLON\n */\nconst COLON = 0x3A;\n/**\n * @type {32} SPACE\n */\nconst SPACE = 0x20;\n\n/**\n * @typedef {object} EventSourceStreamEvent\n * @type {object}\n * @property {string} [event] The event type.\n * @property {string} [data] The data of the message.\n * @property {string} [id] A unique ID for the event.\n * @property {string} [retry] The reconnection time, in milliseconds.\n */\n\n/**\n * @typedef eventSourceSettings\n * @type {object}\n * @property {string} lastEventId The last event ID received from the server.\n * @property {string} origin The origin of the event source.\n * @property {number} reconnectionTime The reconnection time, in milliseconds.\n */\n\nclass EventSourceStream extends Transform {\n  /**\n   * @type {eventSourceSettings}\n   */\n  state = null;\n\n  /**\n   * Leading byte-order-mark check.\n   * @type {boolean}\n   */\n  checkBOM = true;\n\n  /**\n   * @type {boolean}\n   */\n  crlfCheck = false;\n\n  /**\n   * @type {boolean}\n   */\n  eventEndCheck = false;\n\n  /**\n   * @type {Buffer}\n   */\n  buffer = null;\n  pos = 0;\n  event = {\n    data: undefined,\n    event: undefined,\n    id: undefined,\n    retry: undefined\n  };\n\n  /**\n   * @param {object} options\n   * @param {eventSourceSettings} options.eventSourceSettings\n   * @param {Function} [options.push]\n   */\n  constructor(options = {}) {\n    // Enable object mode as EventSourceStream emits objects of shape\n    // EventSourceStreamEvent\n    options.readableObjectMode = true;\n    super(options);\n    this.state = options.eventSourceSettings || {};\n    if (options.push) {\n      this.push = options.push;\n    }\n  }\n\n  /**\n   * @param {Buffer} chunk\n   * @param {string} _encoding\n   * @param {Function} callback\n   * @returns {void}\n   */\n  _transform(chunk, _encoding, callback) {\n    if (chunk.length === 0) {\n      callback();\n      return;\n    }\n\n    // Cache the chunk in the buffer, as the data might not be complete while\n    // processing it\n    // TODO: Investigate if there is a more performant way to handle\n    // incoming chunks\n    // see: https://github.com/nodejs/undici/issues/2630\n    if (this.buffer) {\n      this.buffer = Buffer.concat([this.buffer, chunk]);\n    } else {\n      this.buffer = chunk;\n    }\n\n    // Strip leading byte-order-mark if we opened the stream and started\n    // the processing of the incoming data\n    if (this.checkBOM) {\n      switch (this.buffer.length) {\n        case 1:\n          // Check if the first byte is the same as the first byte of the BOM\n          if (this.buffer[0] === BOM[0]) {\n            // If it is, we need to wait for more data\n            callback();\n            return;\n          }\n          // Set the checkBOM flag to false as we don't need to check for the\n          // BOM anymore\n          this.checkBOM = false;\n\n          // The buffer only contains one byte so we need to wait for more data\n          callback();\n          return;\n        case 2:\n          // Check if the first two bytes are the same as the first two bytes\n          // of the BOM\n          if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1]) {\n            // If it is, we need to wait for more data, because the third byte\n            // is needed to determine if it is the BOM or not\n            callback();\n            return;\n          }\n\n          // Set the checkBOM flag to false as we don't need to check for the\n          // BOM anymore\n          this.checkBOM = false;\n          break;\n        case 3:\n          // Check if the first three bytes are the same as the first three\n          // bytes of the BOM\n          if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {\n            // If it is, we can drop the buffered data, as it is only the BOM\n            this.buffer = Buffer.alloc(0);\n            // Set the checkBOM flag to false as we don't need to check for the\n            // BOM anymore\n            this.checkBOM = false;\n\n            // Await more data\n            callback();\n            return;\n          }\n          // If it is not the BOM, we can start processing the data\n          this.checkBOM = false;\n          break;\n        default:\n          // The buffer is longer than 3 bytes, so we can drop the BOM if it is\n          // present\n          if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {\n            // Remove the BOM from the buffer\n            this.buffer = this.buffer.subarray(3);\n          }\n\n          // Set the checkBOM flag to false as we don't need to check for the\n          this.checkBOM = false;\n          break;\n      }\n    }\n    while (this.pos < this.buffer.length) {\n      // If the previous line ended with an end-of-line, we need to check\n      // if the next character is also an end-of-line.\n      if (this.eventEndCheck) {\n        // If the the current character is an end-of-line, then the event\n        // is finished and we can process it\n\n        // If the previous line ended with a carriage return, we need to\n        // check if the current character is a line feed and remove it\n        // from the buffer.\n        if (this.crlfCheck) {\n          // If the current character is a line feed, we can remove it\n          // from the buffer and reset the crlfCheck flag\n          if (this.buffer[this.pos] === LF) {\n            this.buffer = this.buffer.subarray(this.pos + 1);\n            this.pos = 0;\n            this.crlfCheck = false;\n\n            // It is possible that the line feed is not the end of the\n            // event. We need to check if the next character is an\n            // end-of-line character to determine if the event is\n            // finished. We simply continue the loop to check the next\n            // character.\n\n            // As we removed the line feed from the buffer and set the\n            // crlfCheck flag to false, we basically don't make any\n            // distinction between a line feed and a carriage return.\n            continue;\n          }\n          this.crlfCheck = false;\n        }\n        if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {\n          // If the current character is a carriage return, we need to\n          // set the crlfCheck flag to true, as we need to check if the\n          // next character is a line feed so we can remove it from the\n          // buffer\n          if (this.buffer[this.pos] === CR) {\n            this.crlfCheck = true;\n          }\n          this.buffer = this.buffer.subarray(this.pos + 1);\n          this.pos = 0;\n          if (this.event.data !== undefined || this.event.event || this.event.id || this.event.retry) {\n            this.processEvent(this.event);\n          }\n          this.clearEvent();\n          continue;\n        }\n        // If the current character is not an end-of-line, then the event\n        // is not finished and we have to reset the eventEndCheck flag\n        this.eventEndCheck = false;\n        continue;\n      }\n\n      // If the current character is an end-of-line, we can process the\n      // line\n      if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {\n        // If the current character is a carriage return, we need to\n        // set the crlfCheck flag to true, as we need to check if the\n        // next character is a line feed\n        if (this.buffer[this.pos] === CR) {\n          this.crlfCheck = true;\n        }\n\n        // In any case, we can process the line as we reached an\n        // end-of-line character\n        this.parseLine(this.buffer.subarray(0, this.pos), this.event);\n\n        // Remove the processed line from the buffer\n        this.buffer = this.buffer.subarray(this.pos + 1);\n        // Reset the position as we removed the processed line from the buffer\n        this.pos = 0;\n        // A line was processed and this could be the end of the event. We need\n        // to check if the next line is empty to determine if the event is\n        // finished.\n        this.eventEndCheck = true;\n        continue;\n      }\n      this.pos++;\n    }\n    callback();\n  }\n\n  /**\n   * @param {Buffer} line\n   * @param {EventStreamEvent} event\n   */\n  parseLine(line, event) {\n    // If the line is empty (a blank line)\n    // Dispatch the event, as defined below.\n    // This will be handled in the _transform method\n    if (line.length === 0) {\n      return;\n    }\n\n    // If the line starts with a U+003A COLON character (:)\n    // Ignore the line.\n    const colonPosition = line.indexOf(COLON);\n    if (colonPosition === 0) {\n      return;\n    }\n    let field = '';\n    let value = '';\n\n    // If the line contains a U+003A COLON character (:)\n    if (colonPosition !== -1) {\n      // Collect the characters on the line before the first U+003A COLON\n      // character (:), and let field be that string.\n      // TODO: Investigate if there is a more performant way to extract the\n      // field\n      // see: https://github.com/nodejs/undici/issues/2630\n      field = line.subarray(0, colonPosition).toString('utf8');\n\n      // Collect the characters on the line after the first U+003A COLON\n      // character (:), and let value be that string.\n      // If value starts with a U+0020 SPACE character, remove it from value.\n      let valueStart = colonPosition + 1;\n      if (line[valueStart] === SPACE) {\n        ++valueStart;\n      }\n      // TODO: Investigate if there is a more performant way to extract the\n      // value\n      // see: https://github.com/nodejs/undici/issues/2630\n      value = line.subarray(valueStart).toString('utf8');\n\n      // Otherwise, the string is not empty but does not contain a U+003A COLON\n      // character (:)\n    } else {\n      // Process the field using the steps described below, using the whole\n      // line as the field name, and the empty string as the field value.\n      field = line.toString('utf8');\n      value = '';\n    }\n\n    // Modify the event with the field name and value. The value is also\n    // decoded as UTF-8\n    switch (field) {\n      case 'data':\n        if (event[field] === undefined) {\n          event[field] = value;\n        } else {\n          event[field] += `\\n${value}`;\n        }\n        break;\n      case 'retry':\n        if (isASCIINumber(value)) {\n          event[field] = value;\n        }\n        break;\n      case 'id':\n        if (isValidLastEventId(value)) {\n          event[field] = value;\n        }\n        break;\n      case 'event':\n        if (value.length > 0) {\n          event[field] = value;\n        }\n        break;\n    }\n  }\n\n  /**\n   * @param {EventSourceStreamEvent} event\n   */\n  processEvent(event) {\n    if (event.retry && isASCIINumber(event.retry)) {\n      this.state.reconnectionTime = parseInt(event.retry, 10);\n    }\n    if (event.id && isValidLastEventId(event.id)) {\n      this.state.lastEventId = event.id;\n    }\n\n    // only dispatch event, when data is provided\n    if (event.data !== undefined) {\n      this.push({\n        type: event.event || 'message',\n        options: {\n          data: event.data,\n          lastEventId: this.state.lastEventId,\n          origin: this.state.origin\n        }\n      });\n    }\n  }\n  clearEvent() {\n    this.event = {\n      data: undefined,\n      event: undefined,\n      id: undefined,\n      retry: undefined\n    };\n  }\n}\nmodule.exports = {\n  EventSourceStream\n};","map":{"version":3,"names":["Transform","require","isASCIINumber","isValidLastEventId","BOM","LF","CR","COLON","SPACE","EventSourceStream","state","checkBOM","crlfCheck","eventEndCheck","buffer","pos","event","data","undefined","id","retry","constructor","options","readableObjectMode","eventSourceSettings","push","_transform","chunk","_encoding","callback","length","Buffer","concat","alloc","subarray","processEvent","clearEvent","parseLine","line","colonPosition","indexOf","field","value","toString","valueStart","reconnectionTime","parseInt","lastEventId","type","origin","module","exports"],"sources":["/Users/nataliia/PussyProjects/react-app/node_modules/undici/lib/web/eventsource/eventsource-stream.js"],"sourcesContent":["'use strict'\nconst { Transform } = require('node:stream')\nconst { isASCIINumber, isValidLastEventId } = require('./util')\n\n/**\n * @type {number[]} BOM\n */\nconst BOM = [0xEF, 0xBB, 0xBF]\n/**\n * @type {10} LF\n */\nconst LF = 0x0A\n/**\n * @type {13} CR\n */\nconst CR = 0x0D\n/**\n * @type {58} COLON\n */\nconst COLON = 0x3A\n/**\n * @type {32} SPACE\n */\nconst SPACE = 0x20\n\n/**\n * @typedef {object} EventSourceStreamEvent\n * @type {object}\n * @property {string} [event] The event type.\n * @property {string} [data] The data of the message.\n * @property {string} [id] A unique ID for the event.\n * @property {string} [retry] The reconnection time, in milliseconds.\n */\n\n/**\n * @typedef eventSourceSettings\n * @type {object}\n * @property {string} lastEventId The last event ID received from the server.\n * @property {string} origin The origin of the event source.\n * @property {number} reconnectionTime The reconnection time, in milliseconds.\n */\n\nclass EventSourceStream extends Transform {\n  /**\n   * @type {eventSourceSettings}\n   */\n  state = null\n\n  /**\n   * Leading byte-order-mark check.\n   * @type {boolean}\n   */\n  checkBOM = true\n\n  /**\n   * @type {boolean}\n   */\n  crlfCheck = false\n\n  /**\n   * @type {boolean}\n   */\n  eventEndCheck = false\n\n  /**\n   * @type {Buffer}\n   */\n  buffer = null\n\n  pos = 0\n\n  event = {\n    data: undefined,\n    event: undefined,\n    id: undefined,\n    retry: undefined\n  }\n\n  /**\n   * @param {object} options\n   * @param {eventSourceSettings} options.eventSourceSettings\n   * @param {Function} [options.push]\n   */\n  constructor (options = {}) {\n    // Enable object mode as EventSourceStream emits objects of shape\n    // EventSourceStreamEvent\n    options.readableObjectMode = true\n\n    super(options)\n\n    this.state = options.eventSourceSettings || {}\n    if (options.push) {\n      this.push = options.push\n    }\n  }\n\n  /**\n   * @param {Buffer} chunk\n   * @param {string} _encoding\n   * @param {Function} callback\n   * @returns {void}\n   */\n  _transform (chunk, _encoding, callback) {\n    if (chunk.length === 0) {\n      callback()\n      return\n    }\n\n    // Cache the chunk in the buffer, as the data might not be complete while\n    // processing it\n    // TODO: Investigate if there is a more performant way to handle\n    // incoming chunks\n    // see: https://github.com/nodejs/undici/issues/2630\n    if (this.buffer) {\n      this.buffer = Buffer.concat([this.buffer, chunk])\n    } else {\n      this.buffer = chunk\n    }\n\n    // Strip leading byte-order-mark if we opened the stream and started\n    // the processing of the incoming data\n    if (this.checkBOM) {\n      switch (this.buffer.length) {\n        case 1:\n          // Check if the first byte is the same as the first byte of the BOM\n          if (this.buffer[0] === BOM[0]) {\n            // If it is, we need to wait for more data\n            callback()\n            return\n          }\n          // Set the checkBOM flag to false as we don't need to check for the\n          // BOM anymore\n          this.checkBOM = false\n\n          // The buffer only contains one byte so we need to wait for more data\n          callback()\n          return\n        case 2:\n          // Check if the first two bytes are the same as the first two bytes\n          // of the BOM\n          if (\n            this.buffer[0] === BOM[0] &&\n            this.buffer[1] === BOM[1]\n          ) {\n            // If it is, we need to wait for more data, because the third byte\n            // is needed to determine if it is the BOM or not\n            callback()\n            return\n          }\n\n          // Set the checkBOM flag to false as we don't need to check for the\n          // BOM anymore\n          this.checkBOM = false\n          break\n        case 3:\n          // Check if the first three bytes are the same as the first three\n          // bytes of the BOM\n          if (\n            this.buffer[0] === BOM[0] &&\n            this.buffer[1] === BOM[1] &&\n            this.buffer[2] === BOM[2]\n          ) {\n            // If it is, we can drop the buffered data, as it is only the BOM\n            this.buffer = Buffer.alloc(0)\n            // Set the checkBOM flag to false as we don't need to check for the\n            // BOM anymore\n            this.checkBOM = false\n\n            // Await more data\n            callback()\n            return\n          }\n          // If it is not the BOM, we can start processing the data\n          this.checkBOM = false\n          break\n        default:\n          // The buffer is longer than 3 bytes, so we can drop the BOM if it is\n          // present\n          if (\n            this.buffer[0] === BOM[0] &&\n            this.buffer[1] === BOM[1] &&\n            this.buffer[2] === BOM[2]\n          ) {\n            // Remove the BOM from the buffer\n            this.buffer = this.buffer.subarray(3)\n          }\n\n          // Set the checkBOM flag to false as we don't need to check for the\n          this.checkBOM = false\n          break\n      }\n    }\n\n    while (this.pos < this.buffer.length) {\n      // If the previous line ended with an end-of-line, we need to check\n      // if the next character is also an end-of-line.\n      if (this.eventEndCheck) {\n        // If the the current character is an end-of-line, then the event\n        // is finished and we can process it\n\n        // If the previous line ended with a carriage return, we need to\n        // check if the current character is a line feed and remove it\n        // from the buffer.\n        if (this.crlfCheck) {\n          // If the current character is a line feed, we can remove it\n          // from the buffer and reset the crlfCheck flag\n          if (this.buffer[this.pos] === LF) {\n            this.buffer = this.buffer.subarray(this.pos + 1)\n            this.pos = 0\n            this.crlfCheck = false\n\n            // It is possible that the line feed is not the end of the\n            // event. We need to check if the next character is an\n            // end-of-line character to determine if the event is\n            // finished. We simply continue the loop to check the next\n            // character.\n\n            // As we removed the line feed from the buffer and set the\n            // crlfCheck flag to false, we basically don't make any\n            // distinction between a line feed and a carriage return.\n            continue\n          }\n          this.crlfCheck = false\n        }\n\n        if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {\n          // If the current character is a carriage return, we need to\n          // set the crlfCheck flag to true, as we need to check if the\n          // next character is a line feed so we can remove it from the\n          // buffer\n          if (this.buffer[this.pos] === CR) {\n            this.crlfCheck = true\n          }\n\n          this.buffer = this.buffer.subarray(this.pos + 1)\n          this.pos = 0\n          if (\n            this.event.data !== undefined || this.event.event || this.event.id || this.event.retry) {\n            this.processEvent(this.event)\n          }\n          this.clearEvent()\n          continue\n        }\n        // If the current character is not an end-of-line, then the event\n        // is not finished and we have to reset the eventEndCheck flag\n        this.eventEndCheck = false\n        continue\n      }\n\n      // If the current character is an end-of-line, we can process the\n      // line\n      if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {\n        // If the current character is a carriage return, we need to\n        // set the crlfCheck flag to true, as we need to check if the\n        // next character is a line feed\n        if (this.buffer[this.pos] === CR) {\n          this.crlfCheck = true\n        }\n\n        // In any case, we can process the line as we reached an\n        // end-of-line character\n        this.parseLine(this.buffer.subarray(0, this.pos), this.event)\n\n        // Remove the processed line from the buffer\n        this.buffer = this.buffer.subarray(this.pos + 1)\n        // Reset the position as we removed the processed line from the buffer\n        this.pos = 0\n        // A line was processed and this could be the end of the event. We need\n        // to check if the next line is empty to determine if the event is\n        // finished.\n        this.eventEndCheck = true\n        continue\n      }\n\n      this.pos++\n    }\n\n    callback()\n  }\n\n  /**\n   * @param {Buffer} line\n   * @param {EventStreamEvent} event\n   */\n  parseLine (line, event) {\n    // If the line is empty (a blank line)\n    // Dispatch the event, as defined below.\n    // This will be handled in the _transform method\n    if (line.length === 0) {\n      return\n    }\n\n    // If the line starts with a U+003A COLON character (:)\n    // Ignore the line.\n    const colonPosition = line.indexOf(COLON)\n    if (colonPosition === 0) {\n      return\n    }\n\n    let field = ''\n    let value = ''\n\n    // If the line contains a U+003A COLON character (:)\n    if (colonPosition !== -1) {\n      // Collect the characters on the line before the first U+003A COLON\n      // character (:), and let field be that string.\n      // TODO: Investigate if there is a more performant way to extract the\n      // field\n      // see: https://github.com/nodejs/undici/issues/2630\n      field = line.subarray(0, colonPosition).toString('utf8')\n\n      // Collect the characters on the line after the first U+003A COLON\n      // character (:), and let value be that string.\n      // If value starts with a U+0020 SPACE character, remove it from value.\n      let valueStart = colonPosition + 1\n      if (line[valueStart] === SPACE) {\n        ++valueStart\n      }\n      // TODO: Investigate if there is a more performant way to extract the\n      // value\n      // see: https://github.com/nodejs/undici/issues/2630\n      value = line.subarray(valueStart).toString('utf8')\n\n      // Otherwise, the string is not empty but does not contain a U+003A COLON\n      // character (:)\n    } else {\n      // Process the field using the steps described below, using the whole\n      // line as the field name, and the empty string as the field value.\n      field = line.toString('utf8')\n      value = ''\n    }\n\n    // Modify the event with the field name and value. The value is also\n    // decoded as UTF-8\n    switch (field) {\n      case 'data':\n        if (event[field] === undefined) {\n          event[field] = value\n        } else {\n          event[field] += `\\n${value}`\n        }\n        break\n      case 'retry':\n        if (isASCIINumber(value)) {\n          event[field] = value\n        }\n        break\n      case 'id':\n        if (isValidLastEventId(value)) {\n          event[field] = value\n        }\n        break\n      case 'event':\n        if (value.length > 0) {\n          event[field] = value\n        }\n        break\n    }\n  }\n\n  /**\n   * @param {EventSourceStreamEvent} event\n   */\n  processEvent (event) {\n    if (event.retry && isASCIINumber(event.retry)) {\n      this.state.reconnectionTime = parseInt(event.retry, 10)\n    }\n\n    if (event.id && isValidLastEventId(event.id)) {\n      this.state.lastEventId = event.id\n    }\n\n    // only dispatch event, when data is provided\n    if (event.data !== undefined) {\n      this.push({\n        type: event.event || 'message',\n        options: {\n          data: event.data,\n          lastEventId: this.state.lastEventId,\n          origin: this.state.origin\n        }\n      })\n    }\n  }\n\n  clearEvent () {\n    this.event = {\n      data: undefined,\n      event: undefined,\n      id: undefined,\n      retry: undefined\n    }\n  }\n}\n\nmodule.exports = {\n  EventSourceStream\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
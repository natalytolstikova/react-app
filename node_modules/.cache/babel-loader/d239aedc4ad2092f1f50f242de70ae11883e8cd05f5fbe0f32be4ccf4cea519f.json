{"ast":null,"code":"'use strict';\n\nconst {\n  kReadyState,\n  kController,\n  kResponse,\n  kBinaryType,\n  kWebSocketURL\n} = require('./symbols');\nconst {\n  states,\n  opcodes\n} = require('./constants');\nconst {\n  ErrorEvent,\n  createFastMessageEvent\n} = require('./events');\nconst {\n  isUtf8\n} = require('node:buffer');\nconst {\n  collectASequenceOfCodePointsFast,\n  removeHTTPWhitespace\n} = require('../fetch/data-url');\n\n/* globals Blob */\n\n/**\n * @param {import('./websocket').WebSocket} ws\n * @returns {boolean}\n */\nfunction isConnecting(ws) {\n  // If the WebSocket connection is not yet established, and the connection\n  // is not yet closed, then the WebSocket connection is in the CONNECTING state.\n  return ws[kReadyState] === states.CONNECTING;\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n * @returns {boolean}\n */\nfunction isEstablished(ws) {\n  // If the server's response is validated as provided for above, it is\n  // said that _The WebSocket Connection is Established_ and that the\n  // WebSocket Connection is in the OPEN state.\n  return ws[kReadyState] === states.OPEN;\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n * @returns {boolean}\n */\nfunction isClosing(ws) {\n  // Upon either sending or receiving a Close control frame, it is said\n  // that _The WebSocket Closing Handshake is Started_ and that the\n  // WebSocket connection is in the CLOSING state.\n  return ws[kReadyState] === states.CLOSING;\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n * @returns {boolean}\n */\nfunction isClosed(ws) {\n  return ws[kReadyState] === states.CLOSED;\n}\n\n/**\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e\n * @param {EventTarget} target\n * @param {(...args: ConstructorParameters<typeof Event>) => Event} eventFactory\n * @param {EventInit | undefined} eventInitDict\n */\nfunction fireEvent(e, target, eventFactory = (type, init) => new Event(type, init), eventInitDict = {}) {\n  // 1. If eventConstructor is not given, then let eventConstructor be Event.\n\n  // 2. Let event be the result of creating an event given eventConstructor,\n  //    in the relevant realm of target.\n  // 3. Initialize event’s type attribute to e.\n  const event = eventFactory(e, eventInitDict);\n\n  // 4. Initialize any other IDL attributes of event as described in the\n  //    invocation of this algorithm.\n\n  // 5. Return the result of dispatching event at target, with legacy target\n  //    override flag set if set.\n  target.dispatchEvent(event);\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @param {import('./websocket').WebSocket} ws\n * @param {number} type Opcode\n * @param {Buffer} data application data\n */\nfunction websocketMessageReceived(ws, type, data) {\n  // 1. If ready state is not OPEN (1), then return.\n  if (ws[kReadyState] !== states.OPEN) {\n    return;\n  }\n\n  // 2. Let dataForEvent be determined by switching on type and binary type:\n  let dataForEvent;\n  if (type === opcodes.TEXT) {\n    // -> type indicates that the data is Text\n    //      a new DOMString containing data\n    try {\n      dataForEvent = utf8Decode(data);\n    } catch {\n      failWebsocketConnection(ws, 'Received invalid UTF-8 in text frame.');\n      return;\n    }\n  } else if (type === opcodes.BINARY) {\n    if (ws[kBinaryType] === 'blob') {\n      // -> type indicates that the data is Binary and binary type is \"blob\"\n      //      a new Blob object, created in the relevant Realm of the WebSocket\n      //      object, that represents data as its raw data\n      dataForEvent = new Blob([data]);\n    } else {\n      // -> type indicates that the data is Binary and binary type is \"arraybuffer\"\n      //      a new ArrayBuffer object, created in the relevant Realm of the\n      //      WebSocket object, whose contents are data\n      dataForEvent = toArrayBuffer(data);\n    }\n  }\n\n  // 3. Fire an event named message at the WebSocket object, using MessageEvent,\n  //    with the origin attribute initialized to the serialization of the WebSocket\n  //    object’s url's origin, and the data attribute initialized to dataForEvent.\n  fireEvent('message', ws, createFastMessageEvent, {\n    origin: ws[kWebSocketURL].origin,\n    data: dataForEvent\n  });\n}\nfunction toArrayBuffer(buffer) {\n  if (buffer.byteLength === buffer.buffer.byteLength) {\n    return buffer.buffer;\n  }\n  return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455\n * @see https://datatracker.ietf.org/doc/html/rfc2616\n * @see https://bugs.chromium.org/p/chromium/issues/detail?id=398407\n * @param {string} protocol\n */\nfunction isValidSubprotocol(protocol) {\n  // If present, this value indicates one\n  // or more comma-separated subprotocol the client wishes to speak,\n  // ordered by preference.  The elements that comprise this value\n  // MUST be non-empty strings with characters in the range U+0021 to\n  // U+007E not including separator characters as defined in\n  // [RFC2616] and MUST all be unique strings.\n  if (protocol.length === 0) {\n    return false;\n  }\n  for (let i = 0; i < protocol.length; ++i) {\n    const code = protocol.charCodeAt(i);\n    if (code < 0x21 ||\n    // CTL, contains SP (0x20) and HT (0x09)\n    code > 0x7E || code === 0x22 ||\n    // \"\n    code === 0x28 ||\n    // (\n    code === 0x29 ||\n    // )\n    code === 0x2C ||\n    // ,\n    code === 0x2F ||\n    // /\n    code === 0x3A ||\n    // :\n    code === 0x3B ||\n    // ;\n    code === 0x3C ||\n    // <\n    code === 0x3D ||\n    // =\n    code === 0x3E ||\n    // >\n    code === 0x3F ||\n    // ?\n    code === 0x40 ||\n    // @\n    code === 0x5B ||\n    // [\n    code === 0x5C ||\n    // \\\n    code === 0x5D ||\n    // ]\n    code === 0x7B ||\n    // {\n    code === 0x7D // }\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7-4\n * @param {number} code\n */\nfunction isValidStatusCode(code) {\n  if (code >= 1000 && code < 1015) {\n    return code !== 1004 &&\n    // reserved\n    code !== 1005 &&\n    // \"MUST NOT be set as a status code\"\n    code !== 1006 // \"MUST NOT be set as a status code\"\n    ;\n  }\n  return code >= 3000 && code <= 4999;\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n * @param {string|undefined} reason\n */\nfunction failWebsocketConnection(ws, reason) {\n  const {\n    [kController]: controller,\n    [kResponse]: response\n  } = ws;\n  controller.abort();\n  if (response?.socket && !response.socket.destroyed) {\n    response.socket.destroy();\n  }\n  if (reason) {\n    // TODO: process.nextTick\n    fireEvent('error', ws, (type, init) => new ErrorEvent(type, init), {\n      error: new Error(reason),\n      message: reason\n    });\n  }\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-5.5\n * @param {number} opcode\n */\nfunction isControlFrame(opcode) {\n  return opcode === opcodes.CLOSE || opcode === opcodes.PING || opcode === opcodes.PONG;\n}\nfunction isContinuationFrame(opcode) {\n  return opcode === opcodes.CONTINUATION;\n}\nfunction isTextBinaryFrame(opcode) {\n  return opcode === opcodes.TEXT || opcode === opcodes.BINARY;\n}\nfunction isValidOpcode(opcode) {\n  return isTextBinaryFrame(opcode) || isContinuationFrame(opcode) || isControlFrame(opcode);\n}\n\n/**\n * Parses a Sec-WebSocket-Extensions header value.\n * @param {string} extensions\n * @returns {Map<string, string>}\n */\n// TODO(@Uzlopak, @KhafraDev): make compliant https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\nfunction parseExtensions(extensions) {\n  const position = {\n    position: 0\n  };\n  const extensionList = new Map();\n  while (position.position < extensions.length) {\n    const pair = collectASequenceOfCodePointsFast(';', extensions, position);\n    const [name, value = ''] = pair.split('=');\n    extensionList.set(removeHTTPWhitespace(name, true, false), removeHTTPWhitespace(value, false, true));\n    position.position++;\n  }\n  return extensionList;\n}\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc7692#section-7.1.2.2\n * @description \"client-max-window-bits = 1*DIGIT\"\n * @param {string} value\n */\nfunction isValidClientWindowBits(value) {\n  for (let i = 0; i < value.length; i++) {\n    const byte = value.charCodeAt(i);\n    if (byte < 0x30 || byte > 0x39) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// https://nodejs.org/api/intl.html#detecting-internationalization-support\nconst hasIntl = typeof process.versions.icu === 'string';\nconst fatalDecoder = hasIntl ? new TextDecoder('utf-8', {\n  fatal: true\n}) : undefined;\n\n/**\n * Converts a Buffer to utf-8, even on platforms without icu.\n * @param {Buffer} buffer\n */\nconst utf8Decode = hasIntl ? fatalDecoder.decode.bind(fatalDecoder) : function (buffer) {\n  if (isUtf8(buffer)) {\n    return buffer.toString('utf-8');\n  }\n  throw new TypeError('Invalid utf-8 received.');\n};\nmodule.exports = {\n  isConnecting,\n  isEstablished,\n  isClosing,\n  isClosed,\n  fireEvent,\n  isValidSubprotocol,\n  isValidStatusCode,\n  failWebsocketConnection,\n  websocketMessageReceived,\n  utf8Decode,\n  isControlFrame,\n  isContinuationFrame,\n  isTextBinaryFrame,\n  isValidOpcode,\n  parseExtensions,\n  isValidClientWindowBits\n};","map":{"version":3,"names":["kReadyState","kController","kResponse","kBinaryType","kWebSocketURL","require","states","opcodes","ErrorEvent","createFastMessageEvent","isUtf8","collectASequenceOfCodePointsFast","removeHTTPWhitespace","isConnecting","ws","CONNECTING","isEstablished","OPEN","isClosing","CLOSING","isClosed","CLOSED","fireEvent","e","target","eventFactory","type","init","Event","eventInitDict","event","dispatchEvent","websocketMessageReceived","data","dataForEvent","TEXT","utf8Decode","failWebsocketConnection","BINARY","Blob","toArrayBuffer","origin","buffer","byteLength","slice","byteOffset","isValidSubprotocol","protocol","length","i","code","charCodeAt","isValidStatusCode","reason","controller","response","abort","socket","destroyed","destroy","error","Error","message","isControlFrame","opcode","CLOSE","PING","PONG","isContinuationFrame","CONTINUATION","isTextBinaryFrame","isValidOpcode","parseExtensions","extensions","position","extensionList","Map","pair","name","value","split","set","isValidClientWindowBits","byte","hasIntl","process","versions","icu","fatalDecoder","TextDecoder","fatal","undefined","decode","bind","toString","TypeError","module","exports"],"sources":["/Users/nataliia/PussyProjects/react-app/node_modules/undici/lib/web/websocket/util.js"],"sourcesContent":["'use strict'\n\nconst { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = require('./symbols')\nconst { states, opcodes } = require('./constants')\nconst { ErrorEvent, createFastMessageEvent } = require('./events')\nconst { isUtf8 } = require('node:buffer')\nconst { collectASequenceOfCodePointsFast, removeHTTPWhitespace } = require('../fetch/data-url')\n\n/* globals Blob */\n\n/**\n * @param {import('./websocket').WebSocket} ws\n * @returns {boolean}\n */\nfunction isConnecting (ws) {\n  // If the WebSocket connection is not yet established, and the connection\n  // is not yet closed, then the WebSocket connection is in the CONNECTING state.\n  return ws[kReadyState] === states.CONNECTING\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n * @returns {boolean}\n */\nfunction isEstablished (ws) {\n  // If the server's response is validated as provided for above, it is\n  // said that _The WebSocket Connection is Established_ and that the\n  // WebSocket Connection is in the OPEN state.\n  return ws[kReadyState] === states.OPEN\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n * @returns {boolean}\n */\nfunction isClosing (ws) {\n  // Upon either sending or receiving a Close control frame, it is said\n  // that _The WebSocket Closing Handshake is Started_ and that the\n  // WebSocket connection is in the CLOSING state.\n  return ws[kReadyState] === states.CLOSING\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n * @returns {boolean}\n */\nfunction isClosed (ws) {\n  return ws[kReadyState] === states.CLOSED\n}\n\n/**\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e\n * @param {EventTarget} target\n * @param {(...args: ConstructorParameters<typeof Event>) => Event} eventFactory\n * @param {EventInit | undefined} eventInitDict\n */\nfunction fireEvent (e, target, eventFactory = (type, init) => new Event(type, init), eventInitDict = {}) {\n  // 1. If eventConstructor is not given, then let eventConstructor be Event.\n\n  // 2. Let event be the result of creating an event given eventConstructor,\n  //    in the relevant realm of target.\n  // 3. Initialize event’s type attribute to e.\n  const event = eventFactory(e, eventInitDict)\n\n  // 4. Initialize any other IDL attributes of event as described in the\n  //    invocation of this algorithm.\n\n  // 5. Return the result of dispatching event at target, with legacy target\n  //    override flag set if set.\n  target.dispatchEvent(event)\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @param {import('./websocket').WebSocket} ws\n * @param {number} type Opcode\n * @param {Buffer} data application data\n */\nfunction websocketMessageReceived (ws, type, data) {\n  // 1. If ready state is not OPEN (1), then return.\n  if (ws[kReadyState] !== states.OPEN) {\n    return\n  }\n\n  // 2. Let dataForEvent be determined by switching on type and binary type:\n  let dataForEvent\n\n  if (type === opcodes.TEXT) {\n    // -> type indicates that the data is Text\n    //      a new DOMString containing data\n    try {\n      dataForEvent = utf8Decode(data)\n    } catch {\n      failWebsocketConnection(ws, 'Received invalid UTF-8 in text frame.')\n      return\n    }\n  } else if (type === opcodes.BINARY) {\n    if (ws[kBinaryType] === 'blob') {\n      // -> type indicates that the data is Binary and binary type is \"blob\"\n      //      a new Blob object, created in the relevant Realm of the WebSocket\n      //      object, that represents data as its raw data\n      dataForEvent = new Blob([data])\n    } else {\n      // -> type indicates that the data is Binary and binary type is \"arraybuffer\"\n      //      a new ArrayBuffer object, created in the relevant Realm of the\n      //      WebSocket object, whose contents are data\n      dataForEvent = toArrayBuffer(data)\n    }\n  }\n\n  // 3. Fire an event named message at the WebSocket object, using MessageEvent,\n  //    with the origin attribute initialized to the serialization of the WebSocket\n  //    object’s url's origin, and the data attribute initialized to dataForEvent.\n  fireEvent('message', ws, createFastMessageEvent, {\n    origin: ws[kWebSocketURL].origin,\n    data: dataForEvent\n  })\n}\n\nfunction toArrayBuffer (buffer) {\n  if (buffer.byteLength === buffer.buffer.byteLength) {\n    return buffer.buffer\n  }\n  return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength)\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455\n * @see https://datatracker.ietf.org/doc/html/rfc2616\n * @see https://bugs.chromium.org/p/chromium/issues/detail?id=398407\n * @param {string} protocol\n */\nfunction isValidSubprotocol (protocol) {\n  // If present, this value indicates one\n  // or more comma-separated subprotocol the client wishes to speak,\n  // ordered by preference.  The elements that comprise this value\n  // MUST be non-empty strings with characters in the range U+0021 to\n  // U+007E not including separator characters as defined in\n  // [RFC2616] and MUST all be unique strings.\n  if (protocol.length === 0) {\n    return false\n  }\n\n  for (let i = 0; i < protocol.length; ++i) {\n    const code = protocol.charCodeAt(i)\n\n    if (\n      code < 0x21 || // CTL, contains SP (0x20) and HT (0x09)\n      code > 0x7E ||\n      code === 0x22 || // \"\n      code === 0x28 || // (\n      code === 0x29 || // )\n      code === 0x2C || // ,\n      code === 0x2F || // /\n      code === 0x3A || // :\n      code === 0x3B || // ;\n      code === 0x3C || // <\n      code === 0x3D || // =\n      code === 0x3E || // >\n      code === 0x3F || // ?\n      code === 0x40 || // @\n      code === 0x5B || // [\n      code === 0x5C || // \\\n      code === 0x5D || // ]\n      code === 0x7B || // {\n      code === 0x7D // }\n    ) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7-4\n * @param {number} code\n */\nfunction isValidStatusCode (code) {\n  if (code >= 1000 && code < 1015) {\n    return (\n      code !== 1004 && // reserved\n      code !== 1005 && // \"MUST NOT be set as a status code\"\n      code !== 1006 // \"MUST NOT be set as a status code\"\n    )\n  }\n\n  return code >= 3000 && code <= 4999\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n * @param {string|undefined} reason\n */\nfunction failWebsocketConnection (ws, reason) {\n  const { [kController]: controller, [kResponse]: response } = ws\n\n  controller.abort()\n\n  if (response?.socket && !response.socket.destroyed) {\n    response.socket.destroy()\n  }\n\n  if (reason) {\n    // TODO: process.nextTick\n    fireEvent('error', ws, (type, init) => new ErrorEvent(type, init), {\n      error: new Error(reason),\n      message: reason\n    })\n  }\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-5.5\n * @param {number} opcode\n */\nfunction isControlFrame (opcode) {\n  return (\n    opcode === opcodes.CLOSE ||\n    opcode === opcodes.PING ||\n    opcode === opcodes.PONG\n  )\n}\n\nfunction isContinuationFrame (opcode) {\n  return opcode === opcodes.CONTINUATION\n}\n\nfunction isTextBinaryFrame (opcode) {\n  return opcode === opcodes.TEXT || opcode === opcodes.BINARY\n}\n\nfunction isValidOpcode (opcode) {\n  return isTextBinaryFrame(opcode) || isContinuationFrame(opcode) || isControlFrame(opcode)\n}\n\n/**\n * Parses a Sec-WebSocket-Extensions header value.\n * @param {string} extensions\n * @returns {Map<string, string>}\n */\n// TODO(@Uzlopak, @KhafraDev): make compliant https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\nfunction parseExtensions (extensions) {\n  const position = { position: 0 }\n  const extensionList = new Map()\n\n  while (position.position < extensions.length) {\n    const pair = collectASequenceOfCodePointsFast(';', extensions, position)\n    const [name, value = ''] = pair.split('=')\n\n    extensionList.set(\n      removeHTTPWhitespace(name, true, false),\n      removeHTTPWhitespace(value, false, true)\n    )\n\n    position.position++\n  }\n\n  return extensionList\n}\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc7692#section-7.1.2.2\n * @description \"client-max-window-bits = 1*DIGIT\"\n * @param {string} value\n */\nfunction isValidClientWindowBits (value) {\n  for (let i = 0; i < value.length; i++) {\n    const byte = value.charCodeAt(i)\n\n    if (byte < 0x30 || byte > 0x39) {\n      return false\n    }\n  }\n\n  return true\n}\n\n// https://nodejs.org/api/intl.html#detecting-internationalization-support\nconst hasIntl = typeof process.versions.icu === 'string'\nconst fatalDecoder = hasIntl ? new TextDecoder('utf-8', { fatal: true }) : undefined\n\n/**\n * Converts a Buffer to utf-8, even on platforms without icu.\n * @param {Buffer} buffer\n */\nconst utf8Decode = hasIntl\n  ? fatalDecoder.decode.bind(fatalDecoder)\n  : function (buffer) {\n    if (isUtf8(buffer)) {\n      return buffer.toString('utf-8')\n    }\n    throw new TypeError('Invalid utf-8 received.')\n  }\n\nmodule.exports = {\n  isConnecting,\n  isEstablished,\n  isClosing,\n  isClosed,\n  fireEvent,\n  isValidSubprotocol,\n  isValidStatusCode,\n  failWebsocketConnection,\n  websocketMessageReceived,\n  utf8Decode,\n  isControlFrame,\n  isContinuationFrame,\n  isTextBinaryFrame,\n  isValidOpcode,\n  parseExtensions,\n  isValidClientWindowBits\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
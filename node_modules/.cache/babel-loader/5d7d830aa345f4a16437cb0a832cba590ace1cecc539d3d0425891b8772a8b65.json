{"ast":null,"code":"'use strict';\n\nconst {\n  InvalidArgumentError,\n  SocketError\n} = require('../core/errors');\nconst {\n  AsyncResource\n} = require('node:async_hooks');\nconst util = require('../core/util');\nconst {\n  addSignal,\n  removeSignal\n} = require('./abort-signal');\nconst assert = require('node:assert');\nclass UpgradeHandler extends AsyncResource {\n  constructor(opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts');\n    }\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback');\n    }\n    const {\n      signal,\n      opaque,\n      responseHeaders\n    } = opts;\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');\n    }\n    super('UNDICI_UPGRADE');\n    this.responseHeaders = responseHeaders || null;\n    this.opaque = opaque || null;\n    this.callback = callback;\n    this.abort = null;\n    this.context = null;\n    addSignal(this, signal);\n  }\n  onConnect(abort, context) {\n    if (this.reason) {\n      abort(this.reason);\n      return;\n    }\n    assert(this.callback);\n    this.abort = abort;\n    this.context = null;\n  }\n  onHeaders() {\n    throw new SocketError('bad upgrade', null);\n  }\n  onUpgrade(statusCode, rawHeaders, socket) {\n    const {\n      callback,\n      opaque,\n      context\n    } = this;\n    assert.strictEqual(statusCode, 101);\n    removeSignal(this);\n    this.callback = null;\n    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n    this.runInAsyncScope(callback, null, null, {\n      headers,\n      socket,\n      opaque,\n      context\n    });\n  }\n  onError(err) {\n    const {\n      callback,\n      opaque\n    } = this;\n    removeSignal(this);\n    if (callback) {\n      this.callback = null;\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, {\n          opaque\n        });\n      });\n    }\n  }\n}\nfunction upgrade(opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      upgrade.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data);\n      });\n    });\n  }\n  try {\n    const upgradeHandler = new UpgradeHandler(opts, callback);\n    this.dispatch({\n      ...opts,\n      method: opts.method || 'GET',\n      upgrade: opts.protocol || 'Websocket'\n    }, upgradeHandler);\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err;\n    }\n    const opaque = opts?.opaque;\n    queueMicrotask(() => callback(err, {\n      opaque\n    }));\n  }\n}\nmodule.exports = upgrade;","map":{"version":3,"names":["InvalidArgumentError","SocketError","require","AsyncResource","util","addSignal","removeSignal","assert","UpgradeHandler","constructor","opts","callback","signal","opaque","responseHeaders","on","addEventListener","abort","context","onConnect","reason","onHeaders","onUpgrade","statusCode","rawHeaders","socket","strictEqual","headers","parseRawHeaders","parseHeaders","runInAsyncScope","onError","err","queueMicrotask","upgrade","undefined","Promise","resolve","reject","call","data","upgradeHandler","dispatch","method","protocol","module","exports"],"sources":["/Users/nataliia/PussyProjects/react-app/node_modules/undici/lib/api/api-upgrade.js"],"sourcesContent":["'use strict'\n\nconst { InvalidArgumentError, SocketError } = require('../core/errors')\nconst { AsyncResource } = require('node:async_hooks')\nconst util = require('../core/util')\nconst { addSignal, removeSignal } = require('./abort-signal')\nconst assert = require('node:assert')\n\nclass UpgradeHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    const { signal, opaque, responseHeaders } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    super('UNDICI_UPGRADE')\n\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.callback = callback\n    this.abort = null\n    this.context = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(this.callback)\n\n    this.abort = abort\n    this.context = null\n  }\n\n  onHeaders () {\n    throw new SocketError('bad upgrade', null)\n  }\n\n  onUpgrade (statusCode, rawHeaders, socket) {\n    const { callback, opaque, context } = this\n\n    assert.strictEqual(statusCode, 101)\n\n    removeSignal(this)\n\n    this.callback = null\n    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n    this.runInAsyncScope(callback, null, null, {\n      headers,\n      socket,\n      opaque,\n      context\n    })\n  }\n\n  onError (err) {\n    const { callback, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n  }\n}\n\nfunction upgrade (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      upgrade.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    const upgradeHandler = new UpgradeHandler(opts, callback)\n    this.dispatch({\n      ...opts,\n      method: opts.method || 'GET',\n      upgrade: opts.protocol || 'Websocket'\n    }, upgradeHandler)\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts?.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = upgrade\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
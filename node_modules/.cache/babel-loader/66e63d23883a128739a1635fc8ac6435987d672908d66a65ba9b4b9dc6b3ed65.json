{"ast":null,"code":"'use strict';\n\nconst {\n  uid,\n  states,\n  sentCloseFrameState,\n  emptyBuffer,\n  opcodes\n} = require('./constants');\nconst {\n  kReadyState,\n  kSentClose,\n  kByteParser,\n  kReceivedClose,\n  kResponse\n} = require('./symbols');\nconst {\n  fireEvent,\n  failWebsocketConnection,\n  isClosing,\n  isClosed,\n  isEstablished,\n  parseExtensions\n} = require('./util');\nconst {\n  channels\n} = require('../../core/diagnostics');\nconst {\n  CloseEvent\n} = require('./events');\nconst {\n  makeRequest\n} = require('../fetch/request');\nconst {\n  fetching\n} = require('../fetch/index');\nconst {\n  Headers,\n  getHeadersList\n} = require('../fetch/headers');\nconst {\n  getDecodeSplit\n} = require('../fetch/util');\nconst {\n  WebsocketFrameSend\n} = require('./frame');\n\n/** @type {import('crypto')} */\nlet crypto;\ntry {\n  crypto = require('node:crypto');\n  /* c8 ignore next 3 */\n} catch {}\n\n/**\n * @see https://websockets.spec.whatwg.org/#concept-websocket-establish\n * @param {URL} url\n * @param {string|string[]} protocols\n * @param {import('./websocket').WebSocket} ws\n * @param {(response: any, extensions: string[] | undefined) => void} onEstablish\n * @param {Partial<import('../../types/websocket').WebSocketInit>} options\n */\nfunction establishWebSocketConnection(url, protocols, client, ws, onEstablish, options) {\n  // 1. Let requestURL be a copy of url, with its scheme set to \"http\", if url’s\n  //    scheme is \"ws\", and to \"https\" otherwise.\n  const requestURL = url;\n  requestURL.protocol = url.protocol === 'ws:' ? 'http:' : 'https:';\n\n  // 2. Let request be a new request, whose URL is requestURL, client is client,\n  //    service-workers mode is \"none\", referrer is \"no-referrer\", mode is\n  //    \"websocket\", credentials mode is \"include\", cache mode is \"no-store\" ,\n  //    and redirect mode is \"error\".\n  const request = makeRequest({\n    urlList: [requestURL],\n    client,\n    serviceWorkers: 'none',\n    referrer: 'no-referrer',\n    mode: 'websocket',\n    credentials: 'include',\n    cache: 'no-store',\n    redirect: 'error'\n  });\n\n  // Note: undici extension, allow setting custom headers.\n  if (options.headers) {\n    const headersList = getHeadersList(new Headers(options.headers));\n    request.headersList = headersList;\n  }\n\n  // 3. Append (`Upgrade`, `websocket`) to request’s header list.\n  // 4. Append (`Connection`, `Upgrade`) to request’s header list.\n  // Note: both of these are handled by undici currently.\n  // https://github.com/nodejs/undici/blob/68c269c4144c446f3f1220951338daef4a6b5ec4/lib/client.js#L1397\n\n  // 5. Let keyValue be a nonce consisting of a randomly selected\n  //    16-byte value that has been forgiving-base64-encoded and\n  //    isomorphic encoded.\n  const keyValue = crypto.randomBytes(16).toString('base64');\n\n  // 6. Append (`Sec-WebSocket-Key`, keyValue) to request’s\n  //    header list.\n  request.headersList.append('sec-websocket-key', keyValue);\n\n  // 7. Append (`Sec-WebSocket-Version`, `13`) to request’s\n  //    header list.\n  request.headersList.append('sec-websocket-version', '13');\n\n  // 8. For each protocol in protocols, combine\n  //    (`Sec-WebSocket-Protocol`, protocol) in request’s header\n  //    list.\n  for (const protocol of protocols) {\n    request.headersList.append('sec-websocket-protocol', protocol);\n  }\n\n  // 9. Let permessageDeflate be a user-agent defined\n  //    \"permessage-deflate\" extension header value.\n  // https://github.com/mozilla/gecko-dev/blob/ce78234f5e653a5d3916813ff990f053510227bc/netwerk/protocol/websocket/WebSocketChannel.cpp#L2673\n  const permessageDeflate = 'permessage-deflate; client_max_window_bits';\n\n  // 10. Append (`Sec-WebSocket-Extensions`, permessageDeflate) to\n  //     request’s header list.\n  request.headersList.append('sec-websocket-extensions', permessageDeflate);\n\n  // 11. Fetch request with useParallelQueue set to true, and\n  //     processResponse given response being these steps:\n  const controller = fetching({\n    request,\n    useParallelQueue: true,\n    dispatcher: options.dispatcher,\n    processResponse(response) {\n      // 1. If response is a network error or its status is not 101,\n      //    fail the WebSocket connection.\n      if (response.type === 'error' || response.status !== 101) {\n        failWebsocketConnection(ws, 'Received network error or non-101 status code.');\n        return;\n      }\n\n      // 2. If protocols is not the empty list and extracting header\n      //    list values given `Sec-WebSocket-Protocol` and response’s\n      //    header list results in null, failure, or the empty byte\n      //    sequence, then fail the WebSocket connection.\n      if (protocols.length !== 0 && !response.headersList.get('Sec-WebSocket-Protocol')) {\n        failWebsocketConnection(ws, 'Server did not respond with sent protocols.');\n        return;\n      }\n\n      // 3. Follow the requirements stated step 2 to step 6, inclusive,\n      //    of the last set of steps in section 4.1 of The WebSocket\n      //    Protocol to validate response. This either results in fail\n      //    the WebSocket connection or the WebSocket connection is\n      //    established.\n\n      // 2. If the response lacks an |Upgrade| header field or the |Upgrade|\n      //    header field contains a value that is not an ASCII case-\n      //    insensitive match for the value \"websocket\", the client MUST\n      //    _Fail the WebSocket Connection_.\n      if (response.headersList.get('Upgrade')?.toLowerCase() !== 'websocket') {\n        failWebsocketConnection(ws, 'Server did not set Upgrade header to \"websocket\".');\n        return;\n      }\n\n      // 3. If the response lacks a |Connection| header field or the\n      //    |Connection| header field doesn't contain a token that is an\n      //    ASCII case-insensitive match for the value \"Upgrade\", the client\n      //    MUST _Fail the WebSocket Connection_.\n      if (response.headersList.get('Connection')?.toLowerCase() !== 'upgrade') {\n        failWebsocketConnection(ws, 'Server did not set Connection header to \"upgrade\".');\n        return;\n      }\n\n      // 4. If the response lacks a |Sec-WebSocket-Accept| header field or\n      //    the |Sec-WebSocket-Accept| contains a value other than the\n      //    base64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-\n      //    Key| (as a string, not base64-decoded) with the string \"258EAFA5-\n      //    E914-47DA-95CA-C5AB0DC85B11\" but ignoring any leading and\n      //    trailing whitespace, the client MUST _Fail the WebSocket\n      //    Connection_.\n      const secWSAccept = response.headersList.get('Sec-WebSocket-Accept');\n      const digest = crypto.createHash('sha1').update(keyValue + uid).digest('base64');\n      if (secWSAccept !== digest) {\n        failWebsocketConnection(ws, 'Incorrect hash received in Sec-WebSocket-Accept header.');\n        return;\n      }\n\n      // 5. If the response includes a |Sec-WebSocket-Extensions| header\n      //    field and this header field indicates the use of an extension\n      //    that was not present in the client's handshake (the server has\n      //    indicated an extension not requested by the client), the client\n      //    MUST _Fail the WebSocket Connection_.  (The parsing of this\n      //    header field to determine which extensions are requested is\n      //    discussed in Section 9.1.)\n      const secExtension = response.headersList.get('Sec-WebSocket-Extensions');\n      let extensions;\n      if (secExtension !== null) {\n        extensions = parseExtensions(secExtension);\n        if (!extensions.has('permessage-deflate')) {\n          failWebsocketConnection(ws, 'Sec-WebSocket-Extensions header does not match.');\n          return;\n        }\n      }\n\n      // 6. If the response includes a |Sec-WebSocket-Protocol| header field\n      //    and this header field indicates the use of a subprotocol that was\n      //    not present in the client's handshake (the server has indicated a\n      //    subprotocol not requested by the client), the client MUST _Fail\n      //    the WebSocket Connection_.\n      const secProtocol = response.headersList.get('Sec-WebSocket-Protocol');\n      if (secProtocol !== null) {\n        const requestProtocols = getDecodeSplit('sec-websocket-protocol', request.headersList);\n\n        // The client can request that the server use a specific subprotocol by\n        // including the |Sec-WebSocket-Protocol| field in its handshake.  If it\n        // is specified, the server needs to include the same field and one of\n        // the selected subprotocol values in its response for the connection to\n        // be established.\n        if (!requestProtocols.includes(secProtocol)) {\n          failWebsocketConnection(ws, 'Protocol was not set in the opening handshake.');\n          return;\n        }\n      }\n      response.socket.on('data', onSocketData);\n      response.socket.on('close', onSocketClose);\n      response.socket.on('error', onSocketError);\n      if (channels.open.hasSubscribers) {\n        channels.open.publish({\n          address: response.socket.address(),\n          protocol: secProtocol,\n          extensions: secExtension\n        });\n      }\n      onEstablish(response, extensions);\n    }\n  });\n  return controller;\n}\nfunction closeWebSocketConnection(ws, code, reason, reasonByteLength) {\n  if (isClosing(ws) || isClosed(ws)) {\n    // If this's ready state is CLOSING (2) or CLOSED (3)\n    // Do nothing.\n  } else if (!isEstablished(ws)) {\n    // If the WebSocket connection is not yet established\n    // Fail the WebSocket connection and set this's ready state\n    // to CLOSING (2).\n    failWebsocketConnection(ws, 'Connection was closed before it was established.');\n    ws[kReadyState] = states.CLOSING;\n  } else if (ws[kSentClose] === sentCloseFrameState.NOT_SENT) {\n    // If the WebSocket closing handshake has not yet been started\n    // Start the WebSocket closing handshake and set this's ready\n    // state to CLOSING (2).\n    // - If neither code nor reason is present, the WebSocket Close\n    //   message must not have a body.\n    // - If code is present, then the status code to use in the\n    //   WebSocket Close message must be the integer given by code.\n    // - If reason is also present, then reasonBytes must be\n    //   provided in the Close message after the status code.\n\n    ws[kSentClose] = sentCloseFrameState.PROCESSING;\n    const frame = new WebsocketFrameSend();\n\n    // If neither code nor reason is present, the WebSocket Close\n    // message must not have a body.\n\n    // If code is present, then the status code to use in the\n    // WebSocket Close message must be the integer given by code.\n    if (code !== undefined && reason === undefined) {\n      frame.frameData = Buffer.allocUnsafe(2);\n      frame.frameData.writeUInt16BE(code, 0);\n    } else if (code !== undefined && reason !== undefined) {\n      // If reason is also present, then reasonBytes must be\n      // provided in the Close message after the status code.\n      frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);\n      frame.frameData.writeUInt16BE(code, 0);\n      // the body MAY contain UTF-8-encoded data with value /reason/\n      frame.frameData.write(reason, 2, 'utf-8');\n    } else {\n      frame.frameData = emptyBuffer;\n    }\n\n    /** @type {import('stream').Duplex} */\n    const socket = ws[kResponse].socket;\n    socket.write(frame.createFrame(opcodes.CLOSE));\n    ws[kSentClose] = sentCloseFrameState.SENT;\n\n    // Upon either sending or receiving a Close control frame, it is said\n    // that _The WebSocket Closing Handshake is Started_ and that the\n    // WebSocket connection is in the CLOSING state.\n    ws[kReadyState] = states.CLOSING;\n  } else {\n    // Otherwise\n    // Set this's ready state to CLOSING (2).\n    ws[kReadyState] = states.CLOSING;\n  }\n}\n\n/**\n * @param {Buffer} chunk\n */\nfunction onSocketData(chunk) {\n  if (!this.ws[kByteParser].write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4\n */\nfunction onSocketClose() {\n  const {\n    ws\n  } = this;\n  const {\n    [kResponse]: response\n  } = ws;\n  response.socket.off('data', onSocketData);\n  response.socket.off('close', onSocketClose);\n  response.socket.off('error', onSocketError);\n\n  // If the TCP connection was closed after the\n  // WebSocket closing handshake was completed, the WebSocket connection\n  // is said to have been closed _cleanly_.\n  const wasClean = ws[kSentClose] === sentCloseFrameState.SENT && ws[kReceivedClose];\n  let code = 1005;\n  let reason = '';\n  const result = ws[kByteParser].closingInfo;\n  if (result && !result.error) {\n    code = result.code ?? 1005;\n    reason = result.reason;\n  } else if (!ws[kReceivedClose]) {\n    // If _The WebSocket\n    // Connection is Closed_ and no Close control frame was received by the\n    // endpoint (such as could occur if the underlying transport connection\n    // is lost), _The WebSocket Connection Close Code_ is considered to be\n    // 1006.\n    code = 1006;\n  }\n\n  // 1. Change the ready state to CLOSED (3).\n  ws[kReadyState] = states.CLOSED;\n\n  // 2. If the user agent was required to fail the WebSocket\n  //    connection, or if the WebSocket connection was closed\n  //    after being flagged as full, fire an event named error\n  //    at the WebSocket object.\n  // TODO\n\n  // 3. Fire an event named close at the WebSocket object,\n  //    using CloseEvent, with the wasClean attribute\n  //    initialized to true if the connection closed cleanly\n  //    and false otherwise, the code attribute initialized to\n  //    the WebSocket connection close code, and the reason\n  //    attribute initialized to the result of applying UTF-8\n  //    decode without BOM to the WebSocket connection close\n  //    reason.\n  // TODO: process.nextTick\n  fireEvent('close', ws, (type, init) => new CloseEvent(type, init), {\n    wasClean,\n    code,\n    reason\n  });\n  if (channels.close.hasSubscribers) {\n    channels.close.publish({\n      websocket: ws,\n      code,\n      reason\n    });\n  }\n}\nfunction onSocketError(error) {\n  const {\n    ws\n  } = this;\n  ws[kReadyState] = states.CLOSING;\n  if (channels.socketError.hasSubscribers) {\n    channels.socketError.publish(error);\n  }\n  this.destroy();\n}\nmodule.exports = {\n  establishWebSocketConnection,\n  closeWebSocketConnection\n};","map":{"version":3,"names":["uid","states","sentCloseFrameState","emptyBuffer","opcodes","require","kReadyState","kSentClose","kByteParser","kReceivedClose","kResponse","fireEvent","failWebsocketConnection","isClosing","isClosed","isEstablished","parseExtensions","channels","CloseEvent","makeRequest","fetching","Headers","getHeadersList","getDecodeSplit","WebsocketFrameSend","crypto","establishWebSocketConnection","url","protocols","client","ws","onEstablish","options","requestURL","protocol","request","urlList","serviceWorkers","referrer","mode","credentials","cache","redirect","headers","headersList","keyValue","randomBytes","toString","append","permessageDeflate","controller","useParallelQueue","dispatcher","processResponse","response","type","status","length","get","toLowerCase","secWSAccept","digest","createHash","update","secExtension","extensions","has","secProtocol","requestProtocols","includes","socket","on","onSocketData","onSocketClose","onSocketError","open","hasSubscribers","publish","address","closeWebSocketConnection","code","reason","reasonByteLength","CLOSING","NOT_SENT","PROCESSING","frame","undefined","frameData","Buffer","allocUnsafe","writeUInt16BE","write","createFrame","CLOSE","SENT","chunk","pause","off","wasClean","result","closingInfo","error","CLOSED","init","close","websocket","socketError","destroy","module","exports"],"sources":["/Users/nataliia/PussyProjects/react-app/node_modules/undici/lib/web/websocket/connection.js"],"sourcesContent":["'use strict'\n\nconst { uid, states, sentCloseFrameState, emptyBuffer, opcodes } = require('./constants')\nconst {\n  kReadyState,\n  kSentClose,\n  kByteParser,\n  kReceivedClose,\n  kResponse\n} = require('./symbols')\nconst { fireEvent, failWebsocketConnection, isClosing, isClosed, isEstablished, parseExtensions } = require('./util')\nconst { channels } = require('../../core/diagnostics')\nconst { CloseEvent } = require('./events')\nconst { makeRequest } = require('../fetch/request')\nconst { fetching } = require('../fetch/index')\nconst { Headers, getHeadersList } = require('../fetch/headers')\nconst { getDecodeSplit } = require('../fetch/util')\nconst { WebsocketFrameSend } = require('./frame')\n\n/** @type {import('crypto')} */\nlet crypto\ntry {\n  crypto = require('node:crypto')\n/* c8 ignore next 3 */\n} catch {\n\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#concept-websocket-establish\n * @param {URL} url\n * @param {string|string[]} protocols\n * @param {import('./websocket').WebSocket} ws\n * @param {(response: any, extensions: string[] | undefined) => void} onEstablish\n * @param {Partial<import('../../types/websocket').WebSocketInit>} options\n */\nfunction establishWebSocketConnection (url, protocols, client, ws, onEstablish, options) {\n  // 1. Let requestURL be a copy of url, with its scheme set to \"http\", if url’s\n  //    scheme is \"ws\", and to \"https\" otherwise.\n  const requestURL = url\n\n  requestURL.protocol = url.protocol === 'ws:' ? 'http:' : 'https:'\n\n  // 2. Let request be a new request, whose URL is requestURL, client is client,\n  //    service-workers mode is \"none\", referrer is \"no-referrer\", mode is\n  //    \"websocket\", credentials mode is \"include\", cache mode is \"no-store\" ,\n  //    and redirect mode is \"error\".\n  const request = makeRequest({\n    urlList: [requestURL],\n    client,\n    serviceWorkers: 'none',\n    referrer: 'no-referrer',\n    mode: 'websocket',\n    credentials: 'include',\n    cache: 'no-store',\n    redirect: 'error'\n  })\n\n  // Note: undici extension, allow setting custom headers.\n  if (options.headers) {\n    const headersList = getHeadersList(new Headers(options.headers))\n\n    request.headersList = headersList\n  }\n\n  // 3. Append (`Upgrade`, `websocket`) to request’s header list.\n  // 4. Append (`Connection`, `Upgrade`) to request’s header list.\n  // Note: both of these are handled by undici currently.\n  // https://github.com/nodejs/undici/blob/68c269c4144c446f3f1220951338daef4a6b5ec4/lib/client.js#L1397\n\n  // 5. Let keyValue be a nonce consisting of a randomly selected\n  //    16-byte value that has been forgiving-base64-encoded and\n  //    isomorphic encoded.\n  const keyValue = crypto.randomBytes(16).toString('base64')\n\n  // 6. Append (`Sec-WebSocket-Key`, keyValue) to request’s\n  //    header list.\n  request.headersList.append('sec-websocket-key', keyValue)\n\n  // 7. Append (`Sec-WebSocket-Version`, `13`) to request’s\n  //    header list.\n  request.headersList.append('sec-websocket-version', '13')\n\n  // 8. For each protocol in protocols, combine\n  //    (`Sec-WebSocket-Protocol`, protocol) in request’s header\n  //    list.\n  for (const protocol of protocols) {\n    request.headersList.append('sec-websocket-protocol', protocol)\n  }\n\n  // 9. Let permessageDeflate be a user-agent defined\n  //    \"permessage-deflate\" extension header value.\n  // https://github.com/mozilla/gecko-dev/blob/ce78234f5e653a5d3916813ff990f053510227bc/netwerk/protocol/websocket/WebSocketChannel.cpp#L2673\n  const permessageDeflate = 'permessage-deflate; client_max_window_bits'\n\n  // 10. Append (`Sec-WebSocket-Extensions`, permessageDeflate) to\n  //     request’s header list.\n  request.headersList.append('sec-websocket-extensions', permessageDeflate)\n\n  // 11. Fetch request with useParallelQueue set to true, and\n  //     processResponse given response being these steps:\n  const controller = fetching({\n    request,\n    useParallelQueue: true,\n    dispatcher: options.dispatcher,\n    processResponse (response) {\n      // 1. If response is a network error or its status is not 101,\n      //    fail the WebSocket connection.\n      if (response.type === 'error' || response.status !== 101) {\n        failWebsocketConnection(ws, 'Received network error or non-101 status code.')\n        return\n      }\n\n      // 2. If protocols is not the empty list and extracting header\n      //    list values given `Sec-WebSocket-Protocol` and response’s\n      //    header list results in null, failure, or the empty byte\n      //    sequence, then fail the WebSocket connection.\n      if (protocols.length !== 0 && !response.headersList.get('Sec-WebSocket-Protocol')) {\n        failWebsocketConnection(ws, 'Server did not respond with sent protocols.')\n        return\n      }\n\n      // 3. Follow the requirements stated step 2 to step 6, inclusive,\n      //    of the last set of steps in section 4.1 of The WebSocket\n      //    Protocol to validate response. This either results in fail\n      //    the WebSocket connection or the WebSocket connection is\n      //    established.\n\n      // 2. If the response lacks an |Upgrade| header field or the |Upgrade|\n      //    header field contains a value that is not an ASCII case-\n      //    insensitive match for the value \"websocket\", the client MUST\n      //    _Fail the WebSocket Connection_.\n      if (response.headersList.get('Upgrade')?.toLowerCase() !== 'websocket') {\n        failWebsocketConnection(ws, 'Server did not set Upgrade header to \"websocket\".')\n        return\n      }\n\n      // 3. If the response lacks a |Connection| header field or the\n      //    |Connection| header field doesn't contain a token that is an\n      //    ASCII case-insensitive match for the value \"Upgrade\", the client\n      //    MUST _Fail the WebSocket Connection_.\n      if (response.headersList.get('Connection')?.toLowerCase() !== 'upgrade') {\n        failWebsocketConnection(ws, 'Server did not set Connection header to \"upgrade\".')\n        return\n      }\n\n      // 4. If the response lacks a |Sec-WebSocket-Accept| header field or\n      //    the |Sec-WebSocket-Accept| contains a value other than the\n      //    base64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-\n      //    Key| (as a string, not base64-decoded) with the string \"258EAFA5-\n      //    E914-47DA-95CA-C5AB0DC85B11\" but ignoring any leading and\n      //    trailing whitespace, the client MUST _Fail the WebSocket\n      //    Connection_.\n      const secWSAccept = response.headersList.get('Sec-WebSocket-Accept')\n      const digest = crypto.createHash('sha1').update(keyValue + uid).digest('base64')\n      if (secWSAccept !== digest) {\n        failWebsocketConnection(ws, 'Incorrect hash received in Sec-WebSocket-Accept header.')\n        return\n      }\n\n      // 5. If the response includes a |Sec-WebSocket-Extensions| header\n      //    field and this header field indicates the use of an extension\n      //    that was not present in the client's handshake (the server has\n      //    indicated an extension not requested by the client), the client\n      //    MUST _Fail the WebSocket Connection_.  (The parsing of this\n      //    header field to determine which extensions are requested is\n      //    discussed in Section 9.1.)\n      const secExtension = response.headersList.get('Sec-WebSocket-Extensions')\n      let extensions\n\n      if (secExtension !== null) {\n        extensions = parseExtensions(secExtension)\n\n        if (!extensions.has('permessage-deflate')) {\n          failWebsocketConnection(ws, 'Sec-WebSocket-Extensions header does not match.')\n          return\n        }\n      }\n\n      // 6. If the response includes a |Sec-WebSocket-Protocol| header field\n      //    and this header field indicates the use of a subprotocol that was\n      //    not present in the client's handshake (the server has indicated a\n      //    subprotocol not requested by the client), the client MUST _Fail\n      //    the WebSocket Connection_.\n      const secProtocol = response.headersList.get('Sec-WebSocket-Protocol')\n\n      if (secProtocol !== null) {\n        const requestProtocols = getDecodeSplit('sec-websocket-protocol', request.headersList)\n\n        // The client can request that the server use a specific subprotocol by\n        // including the |Sec-WebSocket-Protocol| field in its handshake.  If it\n        // is specified, the server needs to include the same field and one of\n        // the selected subprotocol values in its response for the connection to\n        // be established.\n        if (!requestProtocols.includes(secProtocol)) {\n          failWebsocketConnection(ws, 'Protocol was not set in the opening handshake.')\n          return\n        }\n      }\n\n      response.socket.on('data', onSocketData)\n      response.socket.on('close', onSocketClose)\n      response.socket.on('error', onSocketError)\n\n      if (channels.open.hasSubscribers) {\n        channels.open.publish({\n          address: response.socket.address(),\n          protocol: secProtocol,\n          extensions: secExtension\n        })\n      }\n\n      onEstablish(response, extensions)\n    }\n  })\n\n  return controller\n}\n\nfunction closeWebSocketConnection (ws, code, reason, reasonByteLength) {\n  if (isClosing(ws) || isClosed(ws)) {\n    // If this's ready state is CLOSING (2) or CLOSED (3)\n    // Do nothing.\n  } else if (!isEstablished(ws)) {\n    // If the WebSocket connection is not yet established\n    // Fail the WebSocket connection and set this's ready state\n    // to CLOSING (2).\n    failWebsocketConnection(ws, 'Connection was closed before it was established.')\n    ws[kReadyState] = states.CLOSING\n  } else if (ws[kSentClose] === sentCloseFrameState.NOT_SENT) {\n    // If the WebSocket closing handshake has not yet been started\n    // Start the WebSocket closing handshake and set this's ready\n    // state to CLOSING (2).\n    // - If neither code nor reason is present, the WebSocket Close\n    //   message must not have a body.\n    // - If code is present, then the status code to use in the\n    //   WebSocket Close message must be the integer given by code.\n    // - If reason is also present, then reasonBytes must be\n    //   provided in the Close message after the status code.\n\n    ws[kSentClose] = sentCloseFrameState.PROCESSING\n\n    const frame = new WebsocketFrameSend()\n\n    // If neither code nor reason is present, the WebSocket Close\n    // message must not have a body.\n\n    // If code is present, then the status code to use in the\n    // WebSocket Close message must be the integer given by code.\n    if (code !== undefined && reason === undefined) {\n      frame.frameData = Buffer.allocUnsafe(2)\n      frame.frameData.writeUInt16BE(code, 0)\n    } else if (code !== undefined && reason !== undefined) {\n      // If reason is also present, then reasonBytes must be\n      // provided in the Close message after the status code.\n      frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength)\n      frame.frameData.writeUInt16BE(code, 0)\n      // the body MAY contain UTF-8-encoded data with value /reason/\n      frame.frameData.write(reason, 2, 'utf-8')\n    } else {\n      frame.frameData = emptyBuffer\n    }\n\n    /** @type {import('stream').Duplex} */\n    const socket = ws[kResponse].socket\n\n    socket.write(frame.createFrame(opcodes.CLOSE))\n\n    ws[kSentClose] = sentCloseFrameState.SENT\n\n    // Upon either sending or receiving a Close control frame, it is said\n    // that _The WebSocket Closing Handshake is Started_ and that the\n    // WebSocket connection is in the CLOSING state.\n    ws[kReadyState] = states.CLOSING\n  } else {\n    // Otherwise\n    // Set this's ready state to CLOSING (2).\n    ws[kReadyState] = states.CLOSING\n  }\n}\n\n/**\n * @param {Buffer} chunk\n */\nfunction onSocketData (chunk) {\n  if (!this.ws[kByteParser].write(chunk)) {\n    this.pause()\n  }\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4\n */\nfunction onSocketClose () {\n  const { ws } = this\n  const { [kResponse]: response } = ws\n\n  response.socket.off('data', onSocketData)\n  response.socket.off('close', onSocketClose)\n  response.socket.off('error', onSocketError)\n\n  // If the TCP connection was closed after the\n  // WebSocket closing handshake was completed, the WebSocket connection\n  // is said to have been closed _cleanly_.\n  const wasClean = ws[kSentClose] === sentCloseFrameState.SENT && ws[kReceivedClose]\n\n  let code = 1005\n  let reason = ''\n\n  const result = ws[kByteParser].closingInfo\n\n  if (result && !result.error) {\n    code = result.code ?? 1005\n    reason = result.reason\n  } else if (!ws[kReceivedClose]) {\n    // If _The WebSocket\n    // Connection is Closed_ and no Close control frame was received by the\n    // endpoint (such as could occur if the underlying transport connection\n    // is lost), _The WebSocket Connection Close Code_ is considered to be\n    // 1006.\n    code = 1006\n  }\n\n  // 1. Change the ready state to CLOSED (3).\n  ws[kReadyState] = states.CLOSED\n\n  // 2. If the user agent was required to fail the WebSocket\n  //    connection, or if the WebSocket connection was closed\n  //    after being flagged as full, fire an event named error\n  //    at the WebSocket object.\n  // TODO\n\n  // 3. Fire an event named close at the WebSocket object,\n  //    using CloseEvent, with the wasClean attribute\n  //    initialized to true if the connection closed cleanly\n  //    and false otherwise, the code attribute initialized to\n  //    the WebSocket connection close code, and the reason\n  //    attribute initialized to the result of applying UTF-8\n  //    decode without BOM to the WebSocket connection close\n  //    reason.\n  // TODO: process.nextTick\n  fireEvent('close', ws, (type, init) => new CloseEvent(type, init), {\n    wasClean, code, reason\n  })\n\n  if (channels.close.hasSubscribers) {\n    channels.close.publish({\n      websocket: ws,\n      code,\n      reason\n    })\n  }\n}\n\nfunction onSocketError (error) {\n  const { ws } = this\n\n  ws[kReadyState] = states.CLOSING\n\n  if (channels.socketError.hasSubscribers) {\n    channels.socketError.publish(error)\n  }\n\n  this.destroy()\n}\n\nmodule.exports = {\n  establishWebSocketConnection,\n  closeWebSocketConnection\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
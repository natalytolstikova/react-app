{"ast":null,"code":"// @ts-check\n\n'use strict';\n\nconst assert = require('node:assert');\nconst net = require('node:net');\nconst http = require('node:http');\nconst util = require('../core/util.js');\nconst {\n  channels\n} = require('../core/diagnostics.js');\nconst Request = require('../core/request.js');\nconst DispatcherBase = require('./dispatcher-base');\nconst {\n  InvalidArgumentError,\n  InformationalError,\n  ClientDestroyedError\n} = require('../core/errors.js');\nconst buildConnector = require('../core/connect.js');\nconst {\n  kUrl,\n  kServerName,\n  kClient,\n  kBusy,\n  kConnect,\n  kResuming,\n  kRunning,\n  kPending,\n  kSize,\n  kQueue,\n  kConnected,\n  kConnecting,\n  kNeedDrain,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kPipelining,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kConnector,\n  kMaxRedirections,\n  kMaxRequests,\n  kCounter,\n  kClose,\n  kDestroy,\n  kDispatch,\n  kInterceptors,\n  kLocalAddress,\n  kMaxResponseSize,\n  kOnError,\n  kHTTPContext,\n  kMaxConcurrentStreams,\n  kResume\n} = require('../core/symbols.js');\nconst connectH1 = require('./client-h1.js');\nconst connectH2 = require('./client-h2.js');\nlet deprecatedInterceptorWarned = false;\nconst kClosedResolve = Symbol('kClosedResolve');\nfunction getPipelining(client) {\n  return client[kPipelining] ?? client[kHTTPContext]?.defaultPipelining ?? 1;\n}\n\n/**\n * @type {import('../../types/client.js').default}\n */\nclass Client extends DispatcherBase {\n  /**\n   *\n   * @param {string|URL} url\n   * @param {import('../../types/client.js').Client.Options} options\n   */\n  constructor(url, {\n    interceptors,\n    maxHeaderSize,\n    headersTimeout,\n    socketTimeout,\n    requestTimeout,\n    connectTimeout,\n    bodyTimeout,\n    idleTimeout,\n    keepAlive,\n    keepAliveTimeout,\n    maxKeepAliveTimeout,\n    keepAliveMaxTimeout,\n    keepAliveTimeoutThreshold,\n    socketPath,\n    pipelining,\n    tls,\n    strictContentLength,\n    maxCachedSessions,\n    maxRedirections,\n    connect,\n    maxRequestsPerClient,\n    localAddress,\n    maxResponseSize,\n    autoSelectFamily,\n    autoSelectFamilyAttemptTimeout,\n    // h2\n    maxConcurrentStreams,\n    allowH2\n  } = {}) {\n    super();\n    if (keepAlive !== undefined) {\n      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead');\n    }\n    if (socketTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead');\n    }\n    if (requestTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead');\n    }\n    if (idleTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead');\n    }\n    if (maxKeepAliveTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead');\n    }\n    if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n      throw new InvalidArgumentError('invalid maxHeaderSize');\n    }\n    if (socketPath != null && typeof socketPath !== 'string') {\n      throw new InvalidArgumentError('invalid socketPath');\n    }\n    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n      throw new InvalidArgumentError('invalid connectTimeout');\n    }\n    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeout');\n    }\n    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveMaxTimeout');\n    }\n    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold');\n    }\n    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero');\n    }\n    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero');\n    }\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object');\n    }\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number');\n    }\n    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number');\n    }\n    if (localAddress != null && (typeof localAddress !== 'string' || net.isIP(localAddress) === 0)) {\n      throw new InvalidArgumentError('localAddress must be valid string IP address');\n    }\n    if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {\n      throw new InvalidArgumentError('maxResponseSize must be a positive number');\n    }\n    if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {\n      throw new InvalidArgumentError('autoSelectFamilyAttemptTimeout must be a positive number');\n    }\n\n    // h2\n    if (allowH2 != null && typeof allowH2 !== 'boolean') {\n      throw new InvalidArgumentError('allowH2 must be a valid boolean value');\n    }\n    if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== 'number' || maxConcurrentStreams < 1)) {\n      throw new InvalidArgumentError('maxConcurrentStreams must be a positive integer, greater than 0');\n    }\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        allowH2,\n        socketPath,\n        timeout: connectTimeout,\n        ...(autoSelectFamily ? {\n          autoSelectFamily,\n          autoSelectFamilyAttemptTimeout\n        } : undefined),\n        ...connect\n      });\n    }\n    if (interceptors?.Client && Array.isArray(interceptors.Client)) {\n      this[kInterceptors] = interceptors.Client;\n      if (!deprecatedInterceptorWarned) {\n        deprecatedInterceptorWarned = true;\n        process.emitWarning('Client.Options#interceptor is deprecated. Use Dispatcher#compose instead.', {\n          code: 'UNDICI-CLIENT-INTERCEPTOR-DEPRECATED'\n        });\n      }\n    } else {\n      this[kInterceptors] = [createRedirectInterceptor({\n        maxRedirections\n      })];\n    }\n    this[kUrl] = util.parseOrigin(url);\n    this[kConnector] = connect;\n    this[kPipelining] = pipelining != null ? pipelining : 1;\n    this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;\n    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;\n    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout;\n    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 2e3 : keepAliveTimeoutThreshold;\n    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];\n    this[kServerName] = null;\n    this[kLocalAddress] = localAddress != null ? localAddress : null;\n    this[kResuming] = 0; // 0, idle, 1, scheduled, 2 resuming\n    this[kNeedDrain] = 0; // 0, idle, 1, scheduled, 2 resuming\n    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\\r\\n`;\n    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300e3;\n    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300e3;\n    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;\n    this[kMaxRedirections] = maxRedirections;\n    this[kMaxRequests] = maxRequestsPerClient;\n    this[kClosedResolve] = null;\n    this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;\n    this[kMaxConcurrentStreams] = maxConcurrentStreams != null ? maxConcurrentStreams : 100; // Max peerConcurrentStreams for a Node h2 server\n    this[kHTTPContext] = null;\n\n    // kQueue is built up of 3 sections separated by\n    // the kRunningIdx and kPendingIdx indices.\n    // |   complete   |   running   |   pending   |\n    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n    // kRunningIdx points to the first running element.\n    // kPendingIdx points to the first pending element.\n    // This implements a fast queue with an amortized\n    // time of O(1).\n\n    this[kQueue] = [];\n    this[kRunningIdx] = 0;\n    this[kPendingIdx] = 0;\n    this[kResume] = sync => resume(this, sync);\n    this[kOnError] = err => onError(this, err);\n  }\n  get pipelining() {\n    return this[kPipelining];\n  }\n  set pipelining(value) {\n    this[kPipelining] = value;\n    this[kResume](true);\n  }\n  get [kPending]() {\n    return this[kQueue].length - this[kPendingIdx];\n  }\n  get [kRunning]() {\n    return this[kPendingIdx] - this[kRunningIdx];\n  }\n  get [kSize]() {\n    return this[kQueue].length - this[kRunningIdx];\n  }\n  get [kConnected]() {\n    return !!this[kHTTPContext] && !this[kConnecting] && !this[kHTTPContext].destroyed;\n  }\n  get [kBusy]() {\n    return Boolean(this[kHTTPContext]?.busy(null) || this[kSize] >= (getPipelining(this) || 1) || this[kPending] > 0);\n  }\n\n  /* istanbul ignore: only used for test */\n  [kConnect](cb) {\n    connect(this);\n    this.once('connect', cb);\n  }\n  [kDispatch](opts, handler) {\n    const origin = opts.origin || this[kUrl].origin;\n    const request = new Request(origin, opts, handler);\n    this[kQueue].push(request);\n    if (this[kResuming]) {\n      // Do nothing.\n    } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n      // Wait a tick in case stream/iterator is ended in the same tick.\n      this[kResuming] = 1;\n      queueMicrotask(() => resume(this));\n    } else {\n      this[kResume](true);\n    }\n    if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n      this[kNeedDrain] = 2;\n    }\n    return this[kNeedDrain] < 2;\n  }\n  async [kClose]() {\n    // TODO: for H2 we need to gracefully flush the remaining enqueued\n    // request and close each stream.\n    return new Promise(resolve => {\n      if (this[kSize]) {\n        this[kClosedResolve] = resolve;\n      } else {\n        resolve(null);\n      }\n    });\n  }\n  async [kDestroy](err) {\n    return new Promise(resolve => {\n      const requests = this[kQueue].splice(this[kPendingIdx]);\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i];\n        util.errorRequest(this, request, err);\n      }\n      const callback = () => {\n        if (this[kClosedResolve]) {\n          // TODO (fix): Should we error here with ClientDestroyedError?\n          this[kClosedResolve]();\n          this[kClosedResolve] = null;\n        }\n        resolve(null);\n      };\n      if (this[kHTTPContext]) {\n        this[kHTTPContext].destroy(err, callback);\n        this[kHTTPContext] = null;\n      } else {\n        queueMicrotask(callback);\n      }\n      this[kResume]();\n    });\n  }\n}\nconst createRedirectInterceptor = require('../interceptor/redirect-interceptor.js');\nfunction onError(client, err) {\n  if (client[kRunning] === 0 && err.code !== 'UND_ERR_INFO' && err.code !== 'UND_ERR_SOCKET') {\n    // Error is not caused by running request and not a recoverable\n    // socket error.\n\n    assert(client[kPendingIdx] === client[kRunningIdx]);\n    const requests = client[kQueue].splice(client[kRunningIdx]);\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i];\n      util.errorRequest(client, request, err);\n    }\n    assert(client[kSize] === 0);\n  }\n}\nasync function connect(client) {\n  assert(!client[kConnecting]);\n  assert(!client[kHTTPContext]);\n  let {\n    host,\n    hostname,\n    protocol,\n    port\n  } = client[kUrl];\n\n  // Resolve ipv6\n  if (hostname[0] === '[') {\n    const idx = hostname.indexOf(']');\n    assert(idx !== -1);\n    const ip = hostname.substring(1, idx);\n    assert(net.isIP(ip));\n    hostname = ip;\n  }\n  client[kConnecting] = true;\n  if (channels.beforeConnect.hasSubscribers) {\n    channels.beforeConnect.publish({\n      connectParams: {\n        host,\n        hostname,\n        protocol,\n        port,\n        version: client[kHTTPContext]?.version,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      },\n      connector: client[kConnector]\n    });\n  }\n  try {\n    const socket = await new Promise((resolve, reject) => {\n      client[kConnector]({\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      }, (err, socket) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(socket);\n        }\n      });\n    });\n    if (client.destroyed) {\n      util.destroy(socket.on('error', () => {}), new ClientDestroyedError());\n      return;\n    }\n    assert(socket);\n    try {\n      client[kHTTPContext] = socket.alpnProtocol === 'h2' ? await connectH2(client, socket) : await connectH1(client, socket);\n    } catch (err) {\n      socket.destroy().on('error', () => {});\n      throw err;\n    }\n    client[kConnecting] = false;\n    socket[kCounter] = 0;\n    socket[kMaxRequests] = client[kMaxRequests];\n    socket[kClient] = client;\n    socket[kError] = null;\n    if (channels.connected.hasSubscribers) {\n      channels.connected.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          version: client[kHTTPContext]?.version,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        socket\n      });\n    }\n    client.emit('connect', client[kUrl], [client]);\n  } catch (err) {\n    if (client.destroyed) {\n      return;\n    }\n    client[kConnecting] = false;\n    if (channels.connectError.hasSubscribers) {\n      channels.connectError.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          version: client[kHTTPContext]?.version,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        error: err\n      });\n    }\n    if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n      assert(client[kRunning] === 0);\n      while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {\n        const request = client[kQueue][client[kPendingIdx]++];\n        util.errorRequest(client, request, err);\n      }\n    } else {\n      onError(client, err);\n    }\n    client.emit('connectionError', client[kUrl], [client], err);\n  }\n  client[kResume]();\n}\nfunction emitDrain(client) {\n  client[kNeedDrain] = 0;\n  client.emit('drain', client[kUrl], [client]);\n}\nfunction resume(client, sync) {\n  if (client[kResuming] === 2) {\n    return;\n  }\n  client[kResuming] = 2;\n  _resume(client, sync);\n  client[kResuming] = 0;\n  if (client[kRunningIdx] > 256) {\n    client[kQueue].splice(0, client[kRunningIdx]);\n    client[kPendingIdx] -= client[kRunningIdx];\n    client[kRunningIdx] = 0;\n  }\n}\nfunction _resume(client, sync) {\n  while (true) {\n    if (client.destroyed) {\n      assert(client[kPending] === 0);\n      return;\n    }\n    if (client[kClosedResolve] && !client[kSize]) {\n      client[kClosedResolve]();\n      client[kClosedResolve] = null;\n      return;\n    }\n    if (client[kHTTPContext]) {\n      client[kHTTPContext].resume();\n    }\n    if (client[kBusy]) {\n      client[kNeedDrain] = 2;\n    } else if (client[kNeedDrain] === 2) {\n      if (sync) {\n        client[kNeedDrain] = 1;\n        queueMicrotask(() => emitDrain(client));\n      } else {\n        emitDrain(client);\n      }\n      continue;\n    }\n    if (client[kPending] === 0) {\n      return;\n    }\n    if (client[kRunning] >= (getPipelining(client) || 1)) {\n      return;\n    }\n    const request = client[kQueue][client[kPendingIdx]];\n    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {\n      if (client[kRunning] > 0) {\n        return;\n      }\n      client[kServerName] = request.servername;\n      client[kHTTPContext]?.destroy(new InformationalError('servername changed'), () => {\n        client[kHTTPContext] = null;\n        resume(client);\n      });\n    }\n    if (client[kConnecting]) {\n      return;\n    }\n    if (!client[kHTTPContext]) {\n      connect(client);\n      return;\n    }\n    if (client[kHTTPContext].destroyed) {\n      return;\n    }\n    if (client[kHTTPContext].busy(request)) {\n      return;\n    }\n    if (!request.aborted && client[kHTTPContext].write(request)) {\n      client[kPendingIdx]++;\n    } else {\n      client[kQueue].splice(client[kPendingIdx], 1);\n    }\n  }\n}\nmodule.exports = Client;","map":{"version":3,"names":["assert","require","net","http","util","channels","Request","DispatcherBase","InvalidArgumentError","InformationalError","ClientDestroyedError","buildConnector","kUrl","kServerName","kClient","kBusy","kConnect","kResuming","kRunning","kPending","kSize","kQueue","kConnected","kConnecting","kNeedDrain","kKeepAliveDefaultTimeout","kHostHeader","kPendingIdx","kRunningIdx","kError","kPipelining","kKeepAliveTimeoutValue","kMaxHeadersSize","kKeepAliveMaxTimeout","kKeepAliveTimeoutThreshold","kHeadersTimeout","kBodyTimeout","kStrictContentLength","kConnector","kMaxRedirections","kMaxRequests","kCounter","kClose","kDestroy","kDispatch","kInterceptors","kLocalAddress","kMaxResponseSize","kOnError","kHTTPContext","kMaxConcurrentStreams","kResume","connectH1","connectH2","deprecatedInterceptorWarned","kClosedResolve","Symbol","getPipelining","client","defaultPipelining","Client","constructor","url","interceptors","maxHeaderSize","headersTimeout","socketTimeout","requestTimeout","connectTimeout","bodyTimeout","idleTimeout","keepAlive","keepAliveTimeout","maxKeepAliveTimeout","keepAliveMaxTimeout","keepAliveTimeoutThreshold","socketPath","pipelining","tls","strictContentLength","maxCachedSessions","maxRedirections","connect","maxRequestsPerClient","localAddress","maxResponseSize","autoSelectFamily","autoSelectFamilyAttemptTimeout","maxConcurrentStreams","allowH2","undefined","Number","isFinite","isInteger","isIP","timeout","Array","isArray","process","emitWarning","code","createRedirectInterceptor","parseOrigin","hostname","port","sync","resume","err","onError","value","length","destroyed","Boolean","busy","cb","once","opts","handler","origin","request","push","bodyLength","body","isIterable","queueMicrotask","Promise","resolve","requests","splice","i","errorRequest","callback","destroy","host","protocol","idx","indexOf","ip","substring","beforeConnect","hasSubscribers","publish","connectParams","version","servername","connector","socket","reject","on","alpnProtocol","connected","emit","connectError","error","emitDrain","_resume","aborted","write","module","exports"],"sources":["/Users/nataliia/PussyProjects/react-app/node_modules/undici/lib/dispatcher/client.js"],"sourcesContent":["// @ts-check\n\n'use strict'\n\nconst assert = require('node:assert')\nconst net = require('node:net')\nconst http = require('node:http')\nconst util = require('../core/util.js')\nconst { channels } = require('../core/diagnostics.js')\nconst Request = require('../core/request.js')\nconst DispatcherBase = require('./dispatcher-base')\nconst {\n  InvalidArgumentError,\n  InformationalError,\n  ClientDestroyedError\n} = require('../core/errors.js')\nconst buildConnector = require('../core/connect.js')\nconst {\n  kUrl,\n  kServerName,\n  kClient,\n  kBusy,\n  kConnect,\n  kResuming,\n  kRunning,\n  kPending,\n  kSize,\n  kQueue,\n  kConnected,\n  kConnecting,\n  kNeedDrain,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kPipelining,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kConnector,\n  kMaxRedirections,\n  kMaxRequests,\n  kCounter,\n  kClose,\n  kDestroy,\n  kDispatch,\n  kInterceptors,\n  kLocalAddress,\n  kMaxResponseSize,\n  kOnError,\n  kHTTPContext,\n  kMaxConcurrentStreams,\n  kResume\n} = require('../core/symbols.js')\nconst connectH1 = require('./client-h1.js')\nconst connectH2 = require('./client-h2.js')\nlet deprecatedInterceptorWarned = false\n\nconst kClosedResolve = Symbol('kClosedResolve')\n\nfunction getPipelining (client) {\n  return client[kPipelining] ?? client[kHTTPContext]?.defaultPipelining ?? 1\n}\n\n/**\n * @type {import('../../types/client.js').default}\n */\nclass Client extends DispatcherBase {\n  /**\n   *\n   * @param {string|URL} url\n   * @param {import('../../types/client.js').Client.Options} options\n   */\n  constructor (url, {\n    interceptors,\n    maxHeaderSize,\n    headersTimeout,\n    socketTimeout,\n    requestTimeout,\n    connectTimeout,\n    bodyTimeout,\n    idleTimeout,\n    keepAlive,\n    keepAliveTimeout,\n    maxKeepAliveTimeout,\n    keepAliveMaxTimeout,\n    keepAliveTimeoutThreshold,\n    socketPath,\n    pipelining,\n    tls,\n    strictContentLength,\n    maxCachedSessions,\n    maxRedirections,\n    connect,\n    maxRequestsPerClient,\n    localAddress,\n    maxResponseSize,\n    autoSelectFamily,\n    autoSelectFamilyAttemptTimeout,\n    // h2\n    maxConcurrentStreams,\n    allowH2\n  } = {}) {\n    super()\n\n    if (keepAlive !== undefined) {\n      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead')\n    }\n\n    if (socketTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (requestTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (idleTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead')\n    }\n\n    if (maxKeepAliveTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead')\n    }\n\n    if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n      throw new InvalidArgumentError('invalid maxHeaderSize')\n    }\n\n    if (socketPath != null && typeof socketPath !== 'string') {\n      throw new InvalidArgumentError('invalid socketPath')\n    }\n\n    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n      throw new InvalidArgumentError('invalid connectTimeout')\n    }\n\n    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeout')\n    }\n\n    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveMaxTimeout')\n    }\n\n    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold')\n    }\n\n    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero')\n    }\n\n    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number')\n    }\n\n    if (localAddress != null && (typeof localAddress !== 'string' || net.isIP(localAddress) === 0)) {\n      throw new InvalidArgumentError('localAddress must be valid string IP address')\n    }\n\n    if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {\n      throw new InvalidArgumentError('maxResponseSize must be a positive number')\n    }\n\n    if (\n      autoSelectFamilyAttemptTimeout != null &&\n      (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)\n    ) {\n      throw new InvalidArgumentError('autoSelectFamilyAttemptTimeout must be a positive number')\n    }\n\n    // h2\n    if (allowH2 != null && typeof allowH2 !== 'boolean') {\n      throw new InvalidArgumentError('allowH2 must be a valid boolean value')\n    }\n\n    if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== 'number' || maxConcurrentStreams < 1)) {\n      throw new InvalidArgumentError('maxConcurrentStreams must be a positive integer, greater than 0')\n    }\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        allowH2,\n        socketPath,\n        timeout: connectTimeout,\n        ...(autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined),\n        ...connect\n      })\n    }\n\n    if (interceptors?.Client && Array.isArray(interceptors.Client)) {\n      this[kInterceptors] = interceptors.Client\n      if (!deprecatedInterceptorWarned) {\n        deprecatedInterceptorWarned = true\n        process.emitWarning('Client.Options#interceptor is deprecated. Use Dispatcher#compose instead.', {\n          code: 'UNDICI-CLIENT-INTERCEPTOR-DEPRECATED'\n        })\n      }\n    } else {\n      this[kInterceptors] = [createRedirectInterceptor({ maxRedirections })]\n    }\n\n    this[kUrl] = util.parseOrigin(url)\n    this[kConnector] = connect\n    this[kPipelining] = pipelining != null ? pipelining : 1\n    this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize\n    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout\n    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout\n    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 2e3 : keepAliveTimeoutThreshold\n    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout]\n    this[kServerName] = null\n    this[kLocalAddress] = localAddress != null ? localAddress : null\n    this[kResuming] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kNeedDrain] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\\r\\n`\n    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300e3\n    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300e3\n    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength\n    this[kMaxRedirections] = maxRedirections\n    this[kMaxRequests] = maxRequestsPerClient\n    this[kClosedResolve] = null\n    this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1\n    this[kMaxConcurrentStreams] = maxConcurrentStreams != null ? maxConcurrentStreams : 100 // Max peerConcurrentStreams for a Node h2 server\n    this[kHTTPContext] = null\n\n    // kQueue is built up of 3 sections separated by\n    // the kRunningIdx and kPendingIdx indices.\n    // |   complete   |   running   |   pending   |\n    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n    // kRunningIdx points to the first running element.\n    // kPendingIdx points to the first pending element.\n    // This implements a fast queue with an amortized\n    // time of O(1).\n\n    this[kQueue] = []\n    this[kRunningIdx] = 0\n    this[kPendingIdx] = 0\n\n    this[kResume] = (sync) => resume(this, sync)\n    this[kOnError] = (err) => onError(this, err)\n  }\n\n  get pipelining () {\n    return this[kPipelining]\n  }\n\n  set pipelining (value) {\n    this[kPipelining] = value\n    this[kResume](true)\n  }\n\n  get [kPending] () {\n    return this[kQueue].length - this[kPendingIdx]\n  }\n\n  get [kRunning] () {\n    return this[kPendingIdx] - this[kRunningIdx]\n  }\n\n  get [kSize] () {\n    return this[kQueue].length - this[kRunningIdx]\n  }\n\n  get [kConnected] () {\n    return !!this[kHTTPContext] && !this[kConnecting] && !this[kHTTPContext].destroyed\n  }\n\n  get [kBusy] () {\n    return Boolean(\n      this[kHTTPContext]?.busy(null) ||\n      (this[kSize] >= (getPipelining(this) || 1)) ||\n      this[kPending] > 0\n    )\n  }\n\n  /* istanbul ignore: only used for test */\n  [kConnect] (cb) {\n    connect(this)\n    this.once('connect', cb)\n  }\n\n  [kDispatch] (opts, handler) {\n    const origin = opts.origin || this[kUrl].origin\n    const request = new Request(origin, opts, handler)\n\n    this[kQueue].push(request)\n    if (this[kResuming]) {\n      // Do nothing.\n    } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n      // Wait a tick in case stream/iterator is ended in the same tick.\n      this[kResuming] = 1\n      queueMicrotask(() => resume(this))\n    } else {\n      this[kResume](true)\n    }\n\n    if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n      this[kNeedDrain] = 2\n    }\n\n    return this[kNeedDrain] < 2\n  }\n\n  async [kClose] () {\n    // TODO: for H2 we need to gracefully flush the remaining enqueued\n    // request and close each stream.\n    return new Promise((resolve) => {\n      if (this[kSize]) {\n        this[kClosedResolve] = resolve\n      } else {\n        resolve(null)\n      }\n    })\n  }\n\n  async [kDestroy] (err) {\n    return new Promise((resolve) => {\n      const requests = this[kQueue].splice(this[kPendingIdx])\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i]\n        util.errorRequest(this, request, err)\n      }\n\n      const callback = () => {\n        if (this[kClosedResolve]) {\n          // TODO (fix): Should we error here with ClientDestroyedError?\n          this[kClosedResolve]()\n          this[kClosedResolve] = null\n        }\n        resolve(null)\n      }\n\n      if (this[kHTTPContext]) {\n        this[kHTTPContext].destroy(err, callback)\n        this[kHTTPContext] = null\n      } else {\n        queueMicrotask(callback)\n      }\n\n      this[kResume]()\n    })\n  }\n}\n\nconst createRedirectInterceptor = require('../interceptor/redirect-interceptor.js')\n\nfunction onError (client, err) {\n  if (\n    client[kRunning] === 0 &&\n    err.code !== 'UND_ERR_INFO' &&\n    err.code !== 'UND_ERR_SOCKET'\n  ) {\n    // Error is not caused by running request and not a recoverable\n    // socket error.\n\n    assert(client[kPendingIdx] === client[kRunningIdx])\n\n    const requests = client[kQueue].splice(client[kRunningIdx])\n\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      util.errorRequest(client, request, err)\n    }\n    assert(client[kSize] === 0)\n  }\n}\n\nasync function connect (client) {\n  assert(!client[kConnecting])\n  assert(!client[kHTTPContext])\n\n  let { host, hostname, protocol, port } = client[kUrl]\n\n  // Resolve ipv6\n  if (hostname[0] === '[') {\n    const idx = hostname.indexOf(']')\n\n    assert(idx !== -1)\n    const ip = hostname.substring(1, idx)\n\n    assert(net.isIP(ip))\n    hostname = ip\n  }\n\n  client[kConnecting] = true\n\n  if (channels.beforeConnect.hasSubscribers) {\n    channels.beforeConnect.publish({\n      connectParams: {\n        host,\n        hostname,\n        protocol,\n        port,\n        version: client[kHTTPContext]?.version,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      },\n      connector: client[kConnector]\n    })\n  }\n\n  try {\n    const socket = await new Promise((resolve, reject) => {\n      client[kConnector]({\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      }, (err, socket) => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve(socket)\n        }\n      })\n    })\n\n    if (client.destroyed) {\n      util.destroy(socket.on('error', () => {}), new ClientDestroyedError())\n      return\n    }\n\n    assert(socket)\n\n    try {\n      client[kHTTPContext] = socket.alpnProtocol === 'h2'\n        ? await connectH2(client, socket)\n        : await connectH1(client, socket)\n    } catch (err) {\n      socket.destroy().on('error', () => {})\n      throw err\n    }\n\n    client[kConnecting] = false\n\n    socket[kCounter] = 0\n    socket[kMaxRequests] = client[kMaxRequests]\n    socket[kClient] = client\n    socket[kError] = null\n\n    if (channels.connected.hasSubscribers) {\n      channels.connected.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          version: client[kHTTPContext]?.version,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        socket\n      })\n    }\n    client.emit('connect', client[kUrl], [client])\n  } catch (err) {\n    if (client.destroyed) {\n      return\n    }\n\n    client[kConnecting] = false\n\n    if (channels.connectError.hasSubscribers) {\n      channels.connectError.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          version: client[kHTTPContext]?.version,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        error: err\n      })\n    }\n\n    if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n      assert(client[kRunning] === 0)\n      while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {\n        const request = client[kQueue][client[kPendingIdx]++]\n        util.errorRequest(client, request, err)\n      }\n    } else {\n      onError(client, err)\n    }\n\n    client.emit('connectionError', client[kUrl], [client], err)\n  }\n\n  client[kResume]()\n}\n\nfunction emitDrain (client) {\n  client[kNeedDrain] = 0\n  client.emit('drain', client[kUrl], [client])\n}\n\nfunction resume (client, sync) {\n  if (client[kResuming] === 2) {\n    return\n  }\n\n  client[kResuming] = 2\n\n  _resume(client, sync)\n  client[kResuming] = 0\n\n  if (client[kRunningIdx] > 256) {\n    client[kQueue].splice(0, client[kRunningIdx])\n    client[kPendingIdx] -= client[kRunningIdx]\n    client[kRunningIdx] = 0\n  }\n}\n\nfunction _resume (client, sync) {\n  while (true) {\n    if (client.destroyed) {\n      assert(client[kPending] === 0)\n      return\n    }\n\n    if (client[kClosedResolve] && !client[kSize]) {\n      client[kClosedResolve]()\n      client[kClosedResolve] = null\n      return\n    }\n\n    if (client[kHTTPContext]) {\n      client[kHTTPContext].resume()\n    }\n\n    if (client[kBusy]) {\n      client[kNeedDrain] = 2\n    } else if (client[kNeedDrain] === 2) {\n      if (sync) {\n        client[kNeedDrain] = 1\n        queueMicrotask(() => emitDrain(client))\n      } else {\n        emitDrain(client)\n      }\n      continue\n    }\n\n    if (client[kPending] === 0) {\n      return\n    }\n\n    if (client[kRunning] >= (getPipelining(client) || 1)) {\n      return\n    }\n\n    const request = client[kQueue][client[kPendingIdx]]\n\n    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {\n      if (client[kRunning] > 0) {\n        return\n      }\n\n      client[kServerName] = request.servername\n      client[kHTTPContext]?.destroy(new InformationalError('servername changed'), () => {\n        client[kHTTPContext] = null\n        resume(client)\n      })\n    }\n\n    if (client[kConnecting]) {\n      return\n    }\n\n    if (!client[kHTTPContext]) {\n      connect(client)\n      return\n    }\n\n    if (client[kHTTPContext].destroyed) {\n      return\n    }\n\n    if (client[kHTTPContext].busy(request)) {\n      return\n    }\n\n    if (!request.aborted && client[kHTTPContext].write(request)) {\n      client[kPendingIdx]++\n    } else {\n      client[kQueue].splice(client[kPendingIdx], 1)\n    }\n  }\n}\n\nmodule.exports = Client\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
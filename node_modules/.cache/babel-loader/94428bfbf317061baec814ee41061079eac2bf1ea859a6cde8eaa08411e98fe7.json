{"ast":null,"code":"'use strict';\n\nconst {\n  MockNotMatchedError\n} = require('./mock-errors');\nconst {\n  kDispatches,\n  kMockAgent,\n  kOriginalDispatch,\n  kOrigin,\n  kGetNetConnect\n} = require('./mock-symbols');\nconst {\n  buildURL\n} = require('../core/util');\nconst {\n  STATUS_CODES\n} = require('node:http');\nconst {\n  types: {\n    isPromise\n  }\n} = require('node:util');\nfunction matchValue(match, value) {\n  if (typeof match === 'string') {\n    return match === value;\n  }\n  if (match instanceof RegExp) {\n    return match.test(value);\n  }\n  if (typeof match === 'function') {\n    return match(value) === true;\n  }\n  return false;\n}\nfunction lowerCaseEntries(headers) {\n  return Object.fromEntries(Object.entries(headers).map(([headerName, headerValue]) => {\n    return [headerName.toLocaleLowerCase(), headerValue];\n  }));\n}\n\n/**\n * @param {import('../../index').Headers|string[]|Record<string, string>} headers\n * @param {string} key\n */\nfunction getHeaderByName(headers, key) {\n  if (Array.isArray(headers)) {\n    for (let i = 0; i < headers.length; i += 2) {\n      if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {\n        return headers[i + 1];\n      }\n    }\n    return undefined;\n  } else if (typeof headers.get === 'function') {\n    return headers.get(key);\n  } else {\n    return lowerCaseEntries(headers)[key.toLocaleLowerCase()];\n  }\n}\n\n/** @param {string[]} headers */\nfunction buildHeadersFromArray(headers) {\n  // fetch HeadersList\n  const clone = headers.slice();\n  const entries = [];\n  for (let index = 0; index < clone.length; index += 2) {\n    entries.push([clone[index], clone[index + 1]]);\n  }\n  return Object.fromEntries(entries);\n}\nfunction matchHeaders(mockDispatch, headers) {\n  if (typeof mockDispatch.headers === 'function') {\n    if (Array.isArray(headers)) {\n      // fetch HeadersList\n      headers = buildHeadersFromArray(headers);\n    }\n    return mockDispatch.headers(headers ? lowerCaseEntries(headers) : {});\n  }\n  if (typeof mockDispatch.headers === 'undefined') {\n    return true;\n  }\n  if (typeof headers !== 'object' || typeof mockDispatch.headers !== 'object') {\n    return false;\n  }\n  for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)) {\n    const headerValue = getHeaderByName(headers, matchHeaderName);\n    if (!matchValue(matchHeaderValue, headerValue)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction safeUrl(path) {\n  if (typeof path !== 'string') {\n    return path;\n  }\n  const pathSegments = path.split('?');\n  if (pathSegments.length !== 2) {\n    return path;\n  }\n  const qp = new URLSearchParams(pathSegments.pop());\n  qp.sort();\n  return [...pathSegments, qp.toString()].join('?');\n}\nfunction matchKey(mockDispatch, {\n  path,\n  method,\n  body,\n  headers\n}) {\n  const pathMatch = matchValue(mockDispatch.path, path);\n  const methodMatch = matchValue(mockDispatch.method, method);\n  const bodyMatch = typeof mockDispatch.body !== 'undefined' ? matchValue(mockDispatch.body, body) : true;\n  const headersMatch = matchHeaders(mockDispatch, headers);\n  return pathMatch && methodMatch && bodyMatch && headersMatch;\n}\nfunction getResponseData(data) {\n  if (Buffer.isBuffer(data)) {\n    return data;\n  } else if (typeof data === 'object') {\n    return JSON.stringify(data);\n  } else {\n    return data.toString();\n  }\n}\nfunction getMockDispatch(mockDispatches, key) {\n  const basePath = key.query ? buildURL(key.path, key.query) : key.path;\n  const resolvedPath = typeof basePath === 'string' ? safeUrl(basePath) : basePath;\n\n  // Match path\n  let matchedMockDispatches = mockDispatches.filter(({\n    consumed\n  }) => !consumed).filter(({\n    path\n  }) => matchValue(safeUrl(path), resolvedPath));\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);\n  }\n\n  // Match method\n  matchedMockDispatches = matchedMockDispatches.filter(({\n    method\n  }) => matchValue(method, key.method));\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}' on path '${resolvedPath}'`);\n  }\n\n  // Match body\n  matchedMockDispatches = matchedMockDispatches.filter(({\n    body\n  }) => typeof body !== 'undefined' ? matchValue(body, key.body) : true);\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}' on path '${resolvedPath}'`);\n  }\n\n  // Match headers\n  matchedMockDispatches = matchedMockDispatches.filter(mockDispatch => matchHeaders(mockDispatch, key.headers));\n  if (matchedMockDispatches.length === 0) {\n    const headers = typeof key.headers === 'object' ? JSON.stringify(key.headers) : key.headers;\n    throw new MockNotMatchedError(`Mock dispatch not matched for headers '${headers}' on path '${resolvedPath}'`);\n  }\n  return matchedMockDispatches[0];\n}\nfunction addMockDispatch(mockDispatches, key, data) {\n  const baseData = {\n    timesInvoked: 0,\n    times: 1,\n    persist: false,\n    consumed: false\n  };\n  const replyData = typeof data === 'function' ? {\n    callback: data\n  } : {\n    ...data\n  };\n  const newMockDispatch = {\n    ...baseData,\n    ...key,\n    pending: true,\n    data: {\n      error: null,\n      ...replyData\n    }\n  };\n  mockDispatches.push(newMockDispatch);\n  return newMockDispatch;\n}\nfunction deleteMockDispatch(mockDispatches, key) {\n  const index = mockDispatches.findIndex(dispatch => {\n    if (!dispatch.consumed) {\n      return false;\n    }\n    return matchKey(dispatch, key);\n  });\n  if (index !== -1) {\n    mockDispatches.splice(index, 1);\n  }\n}\nfunction buildKey(opts) {\n  const {\n    path,\n    method,\n    body,\n    headers,\n    query\n  } = opts;\n  return {\n    path,\n    method,\n    body,\n    headers,\n    query\n  };\n}\nfunction generateKeyValues(data) {\n  const keys = Object.keys(data);\n  const result = [];\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    const value = data[key];\n    const name = Buffer.from(`${key}`);\n    if (Array.isArray(value)) {\n      for (let j = 0; j < value.length; ++j) {\n        result.push(name, Buffer.from(`${value[j]}`));\n      }\n    } else {\n      result.push(name, Buffer.from(`${value}`));\n    }\n  }\n  return result;\n}\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\n * @param {number} statusCode\n */\nfunction getStatusText(statusCode) {\n  return STATUS_CODES[statusCode] || 'unknown';\n}\nasync function getResponse(body) {\n  const buffers = [];\n  for await (const data of body) {\n    buffers.push(data);\n  }\n  return Buffer.concat(buffers).toString('utf8');\n}\n\n/**\n * Mock dispatch function used to simulate undici dispatches\n */\nfunction mockDispatch(opts, handler) {\n  // Get mock dispatch from built key\n  const key = buildKey(opts);\n  const mockDispatch = getMockDispatch(this[kDispatches], key);\n  mockDispatch.timesInvoked++;\n\n  // Here's where we resolve a callback if a callback is present for the dispatch data.\n  if (mockDispatch.data.callback) {\n    mockDispatch.data = {\n      ...mockDispatch.data,\n      ...mockDispatch.data.callback(opts)\n    };\n  }\n\n  // Parse mockDispatch data\n  const {\n    data: {\n      statusCode,\n      data,\n      headers,\n      trailers,\n      error\n    },\n    delay,\n    persist\n  } = mockDispatch;\n  const {\n    timesInvoked,\n    times\n  } = mockDispatch;\n\n  // If it's used up and not persistent, mark as consumed\n  mockDispatch.consumed = !persist && timesInvoked >= times;\n  mockDispatch.pending = timesInvoked < times;\n\n  // If specified, trigger dispatch error\n  if (error !== null) {\n    deleteMockDispatch(this[kDispatches], key);\n    handler.onError(error);\n    return true;\n  }\n\n  // Handle the request with a delay if necessary\n  if (typeof delay === 'number' && delay > 0) {\n    setTimeout(() => {\n      handleReply(this[kDispatches]);\n    }, delay);\n  } else {\n    handleReply(this[kDispatches]);\n  }\n  function handleReply(mockDispatches, _data = data) {\n    // fetch's HeadersList is a 1D string array\n    const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;\n    const body = typeof _data === 'function' ? _data({\n      ...opts,\n      headers: optsHeaders\n    }) : _data;\n\n    // util.types.isPromise is likely needed for jest.\n    if (isPromise(body)) {\n      // If handleReply is asynchronous, throwing an error\n      // in the callback will reject the promise, rather than\n      // synchronously throw the error, which breaks some tests.\n      // Rather, we wait for the callback to resolve if it is a\n      // promise, and then re-run handleReply with the new body.\n      body.then(newData => handleReply(mockDispatches, newData));\n      return;\n    }\n    const responseData = getResponseData(body);\n    const responseHeaders = generateKeyValues(headers);\n    const responseTrailers = generateKeyValues(trailers);\n    handler.onConnect?.(err => handler.onError(err), null);\n    handler.onHeaders?.(statusCode, responseHeaders, resume, getStatusText(statusCode));\n    handler.onData?.(Buffer.from(responseData));\n    handler.onComplete?.(responseTrailers);\n    deleteMockDispatch(mockDispatches, key);\n  }\n  function resume() {}\n  return true;\n}\nfunction buildMockDispatch() {\n  const agent = this[kMockAgent];\n  const origin = this[kOrigin];\n  const originalDispatch = this[kOriginalDispatch];\n  return function dispatch(opts, handler) {\n    if (agent.isMockActive) {\n      try {\n        mockDispatch.call(this, opts, handler);\n      } catch (error) {\n        if (error instanceof MockNotMatchedError) {\n          const netConnect = agent[kGetNetConnect]();\n          if (netConnect === false) {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);\n          }\n          if (checkNetConnect(netConnect, origin)) {\n            originalDispatch.call(this, opts, handler);\n          } else {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);\n          }\n        } else {\n          throw error;\n        }\n      }\n    } else {\n      originalDispatch.call(this, opts, handler);\n    }\n  };\n}\nfunction checkNetConnect(netConnect, origin) {\n  const url = new URL(origin);\n  if (netConnect === true) {\n    return true;\n  } else if (Array.isArray(netConnect) && netConnect.some(matcher => matchValue(matcher, url.host))) {\n    return true;\n  }\n  return false;\n}\nfunction buildMockOptions(opts) {\n  if (opts) {\n    const {\n      agent,\n      ...mockOptions\n    } = opts;\n    return mockOptions;\n  }\n}\nmodule.exports = {\n  getResponseData,\n  getMockDispatch,\n  addMockDispatch,\n  deleteMockDispatch,\n  buildKey,\n  generateKeyValues,\n  matchValue,\n  getResponse,\n  getStatusText,\n  mockDispatch,\n  buildMockDispatch,\n  checkNetConnect,\n  buildMockOptions,\n  getHeaderByName,\n  buildHeadersFromArray\n};","map":{"version":3,"names":["MockNotMatchedError","require","kDispatches","kMockAgent","kOriginalDispatch","kOrigin","kGetNetConnect","buildURL","STATUS_CODES","types","isPromise","matchValue","match","value","RegExp","test","lowerCaseEntries","headers","Object","fromEntries","entries","map","headerName","headerValue","toLocaleLowerCase","getHeaderByName","key","Array","isArray","i","length","undefined","get","buildHeadersFromArray","clone","slice","index","push","matchHeaders","mockDispatch","matchHeaderName","matchHeaderValue","safeUrl","path","pathSegments","split","qp","URLSearchParams","pop","sort","toString","join","matchKey","method","body","pathMatch","methodMatch","bodyMatch","headersMatch","getResponseData","data","Buffer","isBuffer","JSON","stringify","getMockDispatch","mockDispatches","basePath","query","resolvedPath","matchedMockDispatches","filter","consumed","addMockDispatch","baseData","timesInvoked","times","persist","replyData","callback","newMockDispatch","pending","error","deleteMockDispatch","findIndex","dispatch","splice","buildKey","opts","generateKeyValues","keys","result","name","from","j","getStatusText","statusCode","getResponse","buffers","concat","handler","trailers","delay","onError","setTimeout","handleReply","_data","optsHeaders","then","newData","responseData","responseHeaders","responseTrailers","onConnect","err","onHeaders","resume","onData","onComplete","buildMockDispatch","agent","origin","originalDispatch","isMockActive","call","netConnect","message","checkNetConnect","url","URL","some","matcher","host","buildMockOptions","mockOptions","module","exports"],"sources":["/Users/nataliia/PussyProjects/react-app/node_modules/undici/lib/mock/mock-utils.js"],"sourcesContent":["'use strict'\n\nconst { MockNotMatchedError } = require('./mock-errors')\nconst {\n  kDispatches,\n  kMockAgent,\n  kOriginalDispatch,\n  kOrigin,\n  kGetNetConnect\n} = require('./mock-symbols')\nconst { buildURL } = require('../core/util')\nconst { STATUS_CODES } = require('node:http')\nconst {\n  types: {\n    isPromise\n  }\n} = require('node:util')\n\nfunction matchValue (match, value) {\n  if (typeof match === 'string') {\n    return match === value\n  }\n  if (match instanceof RegExp) {\n    return match.test(value)\n  }\n  if (typeof match === 'function') {\n    return match(value) === true\n  }\n  return false\n}\n\nfunction lowerCaseEntries (headers) {\n  return Object.fromEntries(\n    Object.entries(headers).map(([headerName, headerValue]) => {\n      return [headerName.toLocaleLowerCase(), headerValue]\n    })\n  )\n}\n\n/**\n * @param {import('../../index').Headers|string[]|Record<string, string>} headers\n * @param {string} key\n */\nfunction getHeaderByName (headers, key) {\n  if (Array.isArray(headers)) {\n    for (let i = 0; i < headers.length; i += 2) {\n      if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {\n        return headers[i + 1]\n      }\n    }\n\n    return undefined\n  } else if (typeof headers.get === 'function') {\n    return headers.get(key)\n  } else {\n    return lowerCaseEntries(headers)[key.toLocaleLowerCase()]\n  }\n}\n\n/** @param {string[]} headers */\nfunction buildHeadersFromArray (headers) { // fetch HeadersList\n  const clone = headers.slice()\n  const entries = []\n  for (let index = 0; index < clone.length; index += 2) {\n    entries.push([clone[index], clone[index + 1]])\n  }\n  return Object.fromEntries(entries)\n}\n\nfunction matchHeaders (mockDispatch, headers) {\n  if (typeof mockDispatch.headers === 'function') {\n    if (Array.isArray(headers)) { // fetch HeadersList\n      headers = buildHeadersFromArray(headers)\n    }\n    return mockDispatch.headers(headers ? lowerCaseEntries(headers) : {})\n  }\n  if (typeof mockDispatch.headers === 'undefined') {\n    return true\n  }\n  if (typeof headers !== 'object' || typeof mockDispatch.headers !== 'object') {\n    return false\n  }\n\n  for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)) {\n    const headerValue = getHeaderByName(headers, matchHeaderName)\n\n    if (!matchValue(matchHeaderValue, headerValue)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction safeUrl (path) {\n  if (typeof path !== 'string') {\n    return path\n  }\n\n  const pathSegments = path.split('?')\n\n  if (pathSegments.length !== 2) {\n    return path\n  }\n\n  const qp = new URLSearchParams(pathSegments.pop())\n  qp.sort()\n  return [...pathSegments, qp.toString()].join('?')\n}\n\nfunction matchKey (mockDispatch, { path, method, body, headers }) {\n  const pathMatch = matchValue(mockDispatch.path, path)\n  const methodMatch = matchValue(mockDispatch.method, method)\n  const bodyMatch = typeof mockDispatch.body !== 'undefined' ? matchValue(mockDispatch.body, body) : true\n  const headersMatch = matchHeaders(mockDispatch, headers)\n  return pathMatch && methodMatch && bodyMatch && headersMatch\n}\n\nfunction getResponseData (data) {\n  if (Buffer.isBuffer(data)) {\n    return data\n  } else if (typeof data === 'object') {\n    return JSON.stringify(data)\n  } else {\n    return data.toString()\n  }\n}\n\nfunction getMockDispatch (mockDispatches, key) {\n  const basePath = key.query ? buildURL(key.path, key.query) : key.path\n  const resolvedPath = typeof basePath === 'string' ? safeUrl(basePath) : basePath\n\n  // Match path\n  let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(safeUrl(path), resolvedPath))\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`)\n  }\n\n  // Match method\n  matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method))\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}' on path '${resolvedPath}'`)\n  }\n\n  // Match body\n  matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== 'undefined' ? matchValue(body, key.body) : true)\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}' on path '${resolvedPath}'`)\n  }\n\n  // Match headers\n  matchedMockDispatches = matchedMockDispatches.filter((mockDispatch) => matchHeaders(mockDispatch, key.headers))\n  if (matchedMockDispatches.length === 0) {\n    const headers = typeof key.headers === 'object' ? JSON.stringify(key.headers) : key.headers\n    throw new MockNotMatchedError(`Mock dispatch not matched for headers '${headers}' on path '${resolvedPath}'`)\n  }\n\n  return matchedMockDispatches[0]\n}\n\nfunction addMockDispatch (mockDispatches, key, data) {\n  const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false }\n  const replyData = typeof data === 'function' ? { callback: data } : { ...data }\n  const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } }\n  mockDispatches.push(newMockDispatch)\n  return newMockDispatch\n}\n\nfunction deleteMockDispatch (mockDispatches, key) {\n  const index = mockDispatches.findIndex(dispatch => {\n    if (!dispatch.consumed) {\n      return false\n    }\n    return matchKey(dispatch, key)\n  })\n  if (index !== -1) {\n    mockDispatches.splice(index, 1)\n  }\n}\n\nfunction buildKey (opts) {\n  const { path, method, body, headers, query } = opts\n  return {\n    path,\n    method,\n    body,\n    headers,\n    query\n  }\n}\n\nfunction generateKeyValues (data) {\n  const keys = Object.keys(data)\n  const result = []\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i]\n    const value = data[key]\n    const name = Buffer.from(`${key}`)\n    if (Array.isArray(value)) {\n      for (let j = 0; j < value.length; ++j) {\n        result.push(name, Buffer.from(`${value[j]}`))\n      }\n    } else {\n      result.push(name, Buffer.from(`${value}`))\n    }\n  }\n  return result\n}\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\n * @param {number} statusCode\n */\nfunction getStatusText (statusCode) {\n  return STATUS_CODES[statusCode] || 'unknown'\n}\n\nasync function getResponse (body) {\n  const buffers = []\n  for await (const data of body) {\n    buffers.push(data)\n  }\n  return Buffer.concat(buffers).toString('utf8')\n}\n\n/**\n * Mock dispatch function used to simulate undici dispatches\n */\nfunction mockDispatch (opts, handler) {\n  // Get mock dispatch from built key\n  const key = buildKey(opts)\n  const mockDispatch = getMockDispatch(this[kDispatches], key)\n\n  mockDispatch.timesInvoked++\n\n  // Here's where we resolve a callback if a callback is present for the dispatch data.\n  if (mockDispatch.data.callback) {\n    mockDispatch.data = { ...mockDispatch.data, ...mockDispatch.data.callback(opts) }\n  }\n\n  // Parse mockDispatch data\n  const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch\n  const { timesInvoked, times } = mockDispatch\n\n  // If it's used up and not persistent, mark as consumed\n  mockDispatch.consumed = !persist && timesInvoked >= times\n  mockDispatch.pending = timesInvoked < times\n\n  // If specified, trigger dispatch error\n  if (error !== null) {\n    deleteMockDispatch(this[kDispatches], key)\n    handler.onError(error)\n    return true\n  }\n\n  // Handle the request with a delay if necessary\n  if (typeof delay === 'number' && delay > 0) {\n    setTimeout(() => {\n      handleReply(this[kDispatches])\n    }, delay)\n  } else {\n    handleReply(this[kDispatches])\n  }\n\n  function handleReply (mockDispatches, _data = data) {\n    // fetch's HeadersList is a 1D string array\n    const optsHeaders = Array.isArray(opts.headers)\n      ? buildHeadersFromArray(opts.headers)\n      : opts.headers\n    const body = typeof _data === 'function'\n      ? _data({ ...opts, headers: optsHeaders })\n      : _data\n\n    // util.types.isPromise is likely needed for jest.\n    if (isPromise(body)) {\n      // If handleReply is asynchronous, throwing an error\n      // in the callback will reject the promise, rather than\n      // synchronously throw the error, which breaks some tests.\n      // Rather, we wait for the callback to resolve if it is a\n      // promise, and then re-run handleReply with the new body.\n      body.then((newData) => handleReply(mockDispatches, newData))\n      return\n    }\n\n    const responseData = getResponseData(body)\n    const responseHeaders = generateKeyValues(headers)\n    const responseTrailers = generateKeyValues(trailers)\n\n    handler.onConnect?.(err => handler.onError(err), null)\n    handler.onHeaders?.(statusCode, responseHeaders, resume, getStatusText(statusCode))\n    handler.onData?.(Buffer.from(responseData))\n    handler.onComplete?.(responseTrailers)\n    deleteMockDispatch(mockDispatches, key)\n  }\n\n  function resume () {}\n\n  return true\n}\n\nfunction buildMockDispatch () {\n  const agent = this[kMockAgent]\n  const origin = this[kOrigin]\n  const originalDispatch = this[kOriginalDispatch]\n\n  return function dispatch (opts, handler) {\n    if (agent.isMockActive) {\n      try {\n        mockDispatch.call(this, opts, handler)\n      } catch (error) {\n        if (error instanceof MockNotMatchedError) {\n          const netConnect = agent[kGetNetConnect]()\n          if (netConnect === false) {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`)\n          }\n          if (checkNetConnect(netConnect, origin)) {\n            originalDispatch.call(this, opts, handler)\n          } else {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`)\n          }\n        } else {\n          throw error\n        }\n      }\n    } else {\n      originalDispatch.call(this, opts, handler)\n    }\n  }\n}\n\nfunction checkNetConnect (netConnect, origin) {\n  const url = new URL(origin)\n  if (netConnect === true) {\n    return true\n  } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {\n    return true\n  }\n  return false\n}\n\nfunction buildMockOptions (opts) {\n  if (opts) {\n    const { agent, ...mockOptions } = opts\n    return mockOptions\n  }\n}\n\nmodule.exports = {\n  getResponseData,\n  getMockDispatch,\n  addMockDispatch,\n  deleteMockDispatch,\n  buildKey,\n  generateKeyValues,\n  matchValue,\n  getResponse,\n  getStatusText,\n  mockDispatch,\n  buildMockDispatch,\n  checkNetConnect,\n  buildMockOptions,\n  getHeaderByName,\n  buildHeadersFromArray\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"'use strict';\n\nconst {\n  Transform\n} = require('node:stream');\nconst zlib = require('node:zlib');\nconst {\n  redirectStatusSet,\n  referrerPolicySet: referrerPolicyTokens,\n  badPortsSet\n} = require('./constants');\nconst {\n  getGlobalOrigin\n} = require('./global');\nconst {\n  collectASequenceOfCodePoints,\n  collectAnHTTPQuotedString,\n  removeChars,\n  parseMIMEType\n} = require('./data-url');\nconst {\n  performance\n} = require('node:perf_hooks');\nconst {\n  isBlobLike,\n  ReadableStreamFrom,\n  isValidHTTPToken,\n  normalizedMethodRecordsBase\n} = require('../../core/util');\nconst assert = require('node:assert');\nconst {\n  isUint8Array\n} = require('node:util/types');\nconst {\n  webidl\n} = require('./webidl');\nlet supportedHashes = [];\n\n// https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable\n/** @type {import('crypto')} */\nlet crypto;\ntry {\n  crypto = require('node:crypto');\n  const possibleRelevantHashes = ['sha256', 'sha384', 'sha512'];\n  supportedHashes = crypto.getHashes().filter(hash => possibleRelevantHashes.includes(hash));\n  /* c8 ignore next 3 */\n} catch {}\nfunction responseURL(response) {\n  // https://fetch.spec.whatwg.org/#responses\n  // A response has an associated URL. It is a pointer to the last URL\n  // in response’s URL list and null if response’s URL list is empty.\n  const urlList = response.urlList;\n  const length = urlList.length;\n  return length === 0 ? null : urlList[length - 1].toString();\n}\n\n// https://fetch.spec.whatwg.org/#concept-response-location-url\nfunction responseLocationURL(response, requestFragment) {\n  // 1. If response’s status is not a redirect status, then return null.\n  if (!redirectStatusSet.has(response.status)) {\n    return null;\n  }\n\n  // 2. Let location be the result of extracting header list values given\n  // `Location` and response’s header list.\n  let location = response.headersList.get('location', true);\n\n  // 3. If location is a header value, then set location to the result of\n  //    parsing location with response’s URL.\n  if (location !== null && isValidHeaderValue(location)) {\n    if (!isValidEncodedURL(location)) {\n      // Some websites respond location header in UTF-8 form without encoding them as ASCII\n      // and major browsers redirect them to correctly UTF-8 encoded addresses.\n      // Here, we handle that behavior in the same way.\n      location = normalizeBinaryStringToUtf8(location);\n    }\n    location = new URL(location, responseURL(response));\n  }\n\n  // 4. If location is a URL whose fragment is null, then set location’s\n  // fragment to requestFragment.\n  if (location && !location.hash) {\n    location.hash = requestFragment;\n  }\n\n  // 5. Return location.\n  return location;\n}\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc1738#section-2.2\n * @param {string} url\n * @returns {boolean}\n */\nfunction isValidEncodedURL(url) {\n  for (let i = 0; i < url.length; ++i) {\n    const code = url.charCodeAt(i);\n    if (code > 0x7E ||\n    // Non-US-ASCII + DEL\n    code < 0x20 // Control characters NUL - US\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * If string contains non-ASCII characters, assumes it's UTF-8 encoded and decodes it.\n * Since UTF-8 is a superset of ASCII, this will work for ASCII strings as well.\n * @param {string} value\n * @returns {string}\n */\nfunction normalizeBinaryStringToUtf8(value) {\n  return Buffer.from(value, 'binary').toString('utf8');\n}\n\n/** @returns {URL} */\nfunction requestCurrentURL(request) {\n  return request.urlList[request.urlList.length - 1];\n}\nfunction requestBadPort(request) {\n  // 1. Let url be request’s current URL.\n  const url = requestCurrentURL(request);\n\n  // 2. If url’s scheme is an HTTP(S) scheme and url’s port is a bad port,\n  // then return blocked.\n  if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {\n    return 'blocked';\n  }\n\n  // 3. Return allowed.\n  return 'allowed';\n}\nfunction isErrorLike(object) {\n  return object instanceof Error || object?.constructor?.name === 'Error' || object?.constructor?.name === 'DOMException';\n}\n\n// Check whether |statusText| is a ByteString and\n// matches the Reason-Phrase token production.\n// RFC 2616: https://tools.ietf.org/html/rfc2616\n// RFC 7230: https://tools.ietf.org/html/rfc7230\n// \"reason-phrase = *( HTAB / SP / VCHAR / obs-text )\"\n// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116\nfunction isValidReasonPhrase(statusText) {\n  for (let i = 0; i < statusText.length; ++i) {\n    const c = statusText.charCodeAt(i);\n    if (!(c === 0x09 ||\n    // HTAB\n    c >= 0x20 && c <= 0x7e ||\n    // SP / VCHAR\n    c >= 0x80 && c <= 0xff\n    // obs-text\n    )) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-name\n * @param {string} potentialValue\n */\nconst isValidHeaderName = isValidHTTPToken;\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-value\n * @param {string} potentialValue\n */\nfunction isValidHeaderValue(potentialValue) {\n  // - Has no leading or trailing HTTP tab or space bytes.\n  // - Contains no 0x00 (NUL) or HTTP newline bytes.\n  return (potentialValue[0] === '\\t' || potentialValue[0] === ' ' || potentialValue[potentialValue.length - 1] === '\\t' || potentialValue[potentialValue.length - 1] === ' ' || potentialValue.includes('\\n') || potentialValue.includes('\\r') || potentialValue.includes('\\0')) === false;\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect\nfunction setRequestReferrerPolicyOnRedirect(request, actualResponse) {\n  //  Given a request request and a response actualResponse, this algorithm\n  //  updates request’s referrer policy according to the Referrer-Policy\n  //  header (if any) in actualResponse.\n\n  // 1. Let policy be the result of executing § 8.1 Parse a referrer policy\n  // from a Referrer-Policy header on actualResponse.\n\n  // 8.1 Parse a referrer policy from a Referrer-Policy header\n  // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy` and response’s header list.\n  const {\n    headersList\n  } = actualResponse;\n  // 2. Let policy be the empty string.\n  // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty string, then set policy to token.\n  // 4. Return policy.\n  const policyHeader = (headersList.get('referrer-policy', true) ?? '').split(',');\n\n  // Note: As the referrer-policy can contain multiple policies\n  // separated by comma, we need to loop through all of them\n  // and pick the first valid one.\n  // Ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy#specify_a_fallback_policy\n  let policy = '';\n  if (policyHeader.length > 0) {\n    // The right-most policy takes precedence.\n    // The left-most policy is the fallback.\n    for (let i = policyHeader.length; i !== 0; i--) {\n      const token = policyHeader[i - 1].trim();\n      if (referrerPolicyTokens.has(token)) {\n        policy = token;\n        break;\n      }\n    }\n  }\n\n  // 2. If policy is not the empty string, then set request’s referrer policy to policy.\n  if (policy !== '') {\n    request.referrerPolicy = policy;\n  }\n}\n\n// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check\nfunction crossOriginResourcePolicyCheck() {\n  // TODO\n  return 'allowed';\n}\n\n// https://fetch.spec.whatwg.org/#concept-cors-check\nfunction corsCheck() {\n  // TODO\n  return 'success';\n}\n\n// https://fetch.spec.whatwg.org/#concept-tao-check\nfunction TAOCheck() {\n  // TODO\n  return 'success';\n}\nfunction appendFetchMetadata(httpRequest) {\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header\n\n  //  1. Assert: r’s url is a potentially trustworthy URL.\n  //  TODO\n\n  //  2. Let header be a Structured Header whose value is a token.\n  let header = null;\n\n  //  3. Set header’s value to r’s mode.\n  header = httpRequest.mode;\n\n  //  4. Set a structured field value `Sec-Fetch-Mode`/header in r’s header list.\n  httpRequest.headersList.set('sec-fetch-mode', header, true);\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header\n  //  TODO\n}\n\n// https://fetch.spec.whatwg.org/#append-a-request-origin-header\nfunction appendRequestOriginHeader(request) {\n  // 1. Let serializedOrigin be the result of byte-serializing a request origin\n  //    with request.\n  // TODO: implement \"byte-serializing a request origin\"\n  let serializedOrigin = request.origin;\n\n  // - \"'client' is changed to an origin during fetching.\"\n  //   This doesn't happen in undici (in most cases) because undici, by default,\n  //   has no concept of origin.\n  // - request.origin can also be set to request.client.origin (client being\n  //   an environment settings object), which is undefined without using\n  //   setGlobalOrigin.\n  if (serializedOrigin === 'client' || serializedOrigin === undefined) {\n    return;\n  }\n\n  // 2. If request’s response tainting is \"cors\" or request’s mode is \"websocket\",\n  //    then append (`Origin`, serializedOrigin) to request’s header list.\n  // 3. Otherwise, if request’s method is neither `GET` nor `HEAD`, then:\n  if (request.responseTainting === 'cors' || request.mode === 'websocket') {\n    request.headersList.append('origin', serializedOrigin, true);\n  } else if (request.method !== 'GET' && request.method !== 'HEAD') {\n    // 1. Switch on request’s referrer policy:\n    switch (request.referrerPolicy) {\n      case 'no-referrer':\n        // Set serializedOrigin to `null`.\n        serializedOrigin = null;\n        break;\n      case 'no-referrer-when-downgrade':\n      case 'strict-origin':\n      case 'strict-origin-when-cross-origin':\n        // If request’s origin is a tuple origin, its scheme is \"https\", and\n        // request’s current URL’s scheme is not \"https\", then set\n        // serializedOrigin to `null`.\n        if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {\n          serializedOrigin = null;\n        }\n        break;\n      case 'same-origin':\n        // If request’s origin is not same origin with request’s current URL’s\n        // origin, then set serializedOrigin to `null`.\n        if (!sameOrigin(request, requestCurrentURL(request))) {\n          serializedOrigin = null;\n        }\n        break;\n      default:\n      // Do nothing.\n    }\n\n    // 2. Append (`Origin`, serializedOrigin) to request’s header list.\n    request.headersList.append('origin', serializedOrigin, true);\n  }\n}\n\n// https://w3c.github.io/hr-time/#dfn-coarsen-time\nfunction coarsenTime(timestamp, crossOriginIsolatedCapability) {\n  // TODO\n  return timestamp;\n}\n\n// https://fetch.spec.whatwg.org/#clamp-and-coarsen-connection-timing-info\nfunction clampAndCoarsenConnectionTimingInfo(connectionTimingInfo, defaultStartTime, crossOriginIsolatedCapability) {\n  if (!connectionTimingInfo?.startTime || connectionTimingInfo.startTime < defaultStartTime) {\n    return {\n      domainLookupStartTime: defaultStartTime,\n      domainLookupEndTime: defaultStartTime,\n      connectionStartTime: defaultStartTime,\n      connectionEndTime: defaultStartTime,\n      secureConnectionStartTime: defaultStartTime,\n      ALPNNegotiatedProtocol: connectionTimingInfo?.ALPNNegotiatedProtocol\n    };\n  }\n  return {\n    domainLookupStartTime: coarsenTime(connectionTimingInfo.domainLookupStartTime, crossOriginIsolatedCapability),\n    domainLookupEndTime: coarsenTime(connectionTimingInfo.domainLookupEndTime, crossOriginIsolatedCapability),\n    connectionStartTime: coarsenTime(connectionTimingInfo.connectionStartTime, crossOriginIsolatedCapability),\n    connectionEndTime: coarsenTime(connectionTimingInfo.connectionEndTime, crossOriginIsolatedCapability),\n    secureConnectionStartTime: coarsenTime(connectionTimingInfo.secureConnectionStartTime, crossOriginIsolatedCapability),\n    ALPNNegotiatedProtocol: connectionTimingInfo.ALPNNegotiatedProtocol\n  };\n}\n\n// https://w3c.github.io/hr-time/#dfn-coarsened-shared-current-time\nfunction coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {\n  return coarsenTime(performance.now(), crossOriginIsolatedCapability);\n}\n\n// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info\nfunction createOpaqueTimingInfo(timingInfo) {\n  return {\n    startTime: timingInfo.startTime ?? 0,\n    redirectStartTime: 0,\n    redirectEndTime: 0,\n    postRedirectStartTime: timingInfo.startTime ?? 0,\n    finalServiceWorkerStartTime: 0,\n    finalNetworkResponseStartTime: 0,\n    finalNetworkRequestStartTime: 0,\n    endTime: 0,\n    encodedBodySize: 0,\n    decodedBodySize: 0,\n    finalConnectionTimingInfo: null\n  };\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#policy-container\nfunction makePolicyContainer() {\n  // Note: the fetch spec doesn't make use of embedder policy or CSP list\n  return {\n    referrerPolicy: 'strict-origin-when-cross-origin'\n  };\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container\nfunction clonePolicyContainer(policyContainer) {\n  return {\n    referrerPolicy: policyContainer.referrerPolicy\n  };\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer\nfunction determineRequestsReferrer(request) {\n  // 1. Let policy be request's referrer policy.\n  const policy = request.referrerPolicy;\n\n  // Note: policy cannot (shouldn't) be null or an empty string.\n  assert(policy);\n\n  // 2. Let environment be request’s client.\n\n  let referrerSource = null;\n\n  // 3. Switch on request’s referrer:\n  if (request.referrer === 'client') {\n    // Note: node isn't a browser and doesn't implement document/iframes,\n    // so we bypass this step and replace it with our own.\n\n    const globalOrigin = getGlobalOrigin();\n    if (!globalOrigin || globalOrigin.origin === 'null') {\n      return 'no-referrer';\n    }\n\n    // note: we need to clone it as it's mutated\n    referrerSource = new URL(globalOrigin);\n  } else if (request.referrer instanceof URL) {\n    // Let referrerSource be request’s referrer.\n    referrerSource = request.referrer;\n  }\n\n  // 4. Let request’s referrerURL be the result of stripping referrerSource for\n  //    use as a referrer.\n  let referrerURL = stripURLForReferrer(referrerSource);\n\n  // 5. Let referrerOrigin be the result of stripping referrerSource for use as\n  //    a referrer, with the origin-only flag set to true.\n  const referrerOrigin = stripURLForReferrer(referrerSource, true);\n\n  // 6. If the result of serializing referrerURL is a string whose length is\n  //    greater than 4096, set referrerURL to referrerOrigin.\n  if (referrerURL.toString().length > 4096) {\n    referrerURL = referrerOrigin;\n  }\n  const areSameOrigin = sameOrigin(request, referrerURL);\n  const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);\n\n  // 8. Execute the switch statements corresponding to the value of policy:\n  switch (policy) {\n    case 'origin':\n      return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);\n    case 'unsafe-url':\n      return referrerURL;\n    case 'same-origin':\n      return areSameOrigin ? referrerOrigin : 'no-referrer';\n    case 'origin-when-cross-origin':\n      return areSameOrigin ? referrerURL : referrerOrigin;\n    case 'strict-origin-when-cross-origin':\n      {\n        const currentURL = requestCurrentURL(request);\n\n        // 1. If the origin of referrerURL and the origin of request’s current\n        //    URL are the same, then return referrerURL.\n        if (sameOrigin(referrerURL, currentURL)) {\n          return referrerURL;\n        }\n\n        // 2. If referrerURL is a potentially trustworthy URL and request’s\n        //    current URL is not a potentially trustworthy URL, then return no\n        //    referrer.\n        if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {\n          return 'no-referrer';\n        }\n\n        // 3. Return referrerOrigin.\n        return referrerOrigin;\n      }\n    case 'strict-origin': // eslint-disable-line\n    /**\n       * 1. If referrerURL is a potentially trustworthy URL and\n       * request’s current URL is not a potentially trustworthy URL,\n       * then return no referrer.\n       * 2. Return referrerOrigin\n      */\n    case 'no-referrer-when-downgrade': // eslint-disable-line\n    /**\n     * 1. If referrerURL is a potentially trustworthy URL and\n     * request’s current URL is not a potentially trustworthy URL,\n     * then return no referrer.\n     * 2. Return referrerOrigin\n    */\n\n    default:\n      // eslint-disable-line\n      return isNonPotentiallyTrustWorthy ? 'no-referrer' : referrerOrigin;\n  }\n}\n\n/**\n * @see https://w3c.github.io/webappsec-referrer-policy/#strip-url\n * @param {URL} url\n * @param {boolean|undefined} originOnly\n */\nfunction stripURLForReferrer(url, originOnly) {\n  // 1. Assert: url is a URL.\n  assert(url instanceof URL);\n  url = new URL(url);\n\n  // 2. If url’s scheme is a local scheme, then return no referrer.\n  if (url.protocol === 'file:' || url.protocol === 'about:' || url.protocol === 'blank:') {\n    return 'no-referrer';\n  }\n\n  // 3. Set url’s username to the empty string.\n  url.username = '';\n\n  // 4. Set url’s password to the empty string.\n  url.password = '';\n\n  // 5. Set url’s fragment to null.\n  url.hash = '';\n\n  // 6. If the origin-only flag is true, then:\n  if (originOnly) {\n    // 1. Set url’s path to « the empty string ».\n    url.pathname = '';\n\n    // 2. Set url’s query to null.\n    url.search = '';\n  }\n\n  // 7. Return url.\n  return url;\n}\nfunction isURLPotentiallyTrustworthy(url) {\n  if (!(url instanceof URL)) {\n    return false;\n  }\n\n  // If child of about, return true\n  if (url.href === 'about:blank' || url.href === 'about:srcdoc') {\n    return true;\n  }\n\n  // If scheme is data, return true\n  if (url.protocol === 'data:') return true;\n\n  // If file, return true\n  if (url.protocol === 'file:') return true;\n  return isOriginPotentiallyTrustworthy(url.origin);\n  function isOriginPotentiallyTrustworthy(origin) {\n    // If origin is explicitly null, return false\n    if (origin == null || origin === 'null') return false;\n    const originAsURL = new URL(origin);\n\n    // If secure, return true\n    if (originAsURL.protocol === 'https:' || originAsURL.protocol === 'wss:') {\n      return true;\n    }\n\n    // If localhost or variants, return true\n    if (/^127(?:\\.[0-9]+){0,2}\\.[0-9]+$|^\\[(?:0*:)*?:?0*1\\]$/.test(originAsURL.hostname) || originAsURL.hostname === 'localhost' || originAsURL.hostname.includes('localhost.') || originAsURL.hostname.endsWith('.localhost')) {\n      return true;\n    }\n\n    // If any other, return false\n    return false;\n  }\n}\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist\n * @param {Uint8Array} bytes\n * @param {string} metadataList\n */\nfunction bytesMatch(bytes, metadataList) {\n  // If node is not built with OpenSSL support, we cannot check\n  // a request's integrity, so allow it by default (the spec will\n  // allow requests if an invalid hash is given, as precedence).\n  /* istanbul ignore if: only if node is built with --without-ssl */\n  if (crypto === undefined) {\n    return true;\n  }\n\n  // 1. Let parsedMetadata be the result of parsing metadataList.\n  const parsedMetadata = parseMetadata(metadataList);\n\n  // 2. If parsedMetadata is no metadata, return true.\n  if (parsedMetadata === 'no metadata') {\n    return true;\n  }\n\n  // 3. If response is not eligible for integrity validation, return false.\n  // TODO\n\n  // 4. If parsedMetadata is the empty set, return true.\n  if (parsedMetadata.length === 0) {\n    return true;\n  }\n\n  // 5. Let metadata be the result of getting the strongest\n  //    metadata from parsedMetadata.\n  const strongest = getStrongestMetadata(parsedMetadata);\n  const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);\n\n  // 6. For each item in metadata:\n  for (const item of metadata) {\n    // 1. Let algorithm be the alg component of item.\n    const algorithm = item.algo;\n\n    // 2. Let expectedValue be the val component of item.\n    const expectedValue = item.hash;\n\n    // See https://github.com/web-platform-tests/wpt/commit/e4c5cc7a5e48093220528dfdd1c4012dc3837a0e\n    // \"be liberal with padding\". This is annoying, and it's not even in the spec.\n\n    // 3. Let actualValue be the result of applying algorithm to bytes.\n    let actualValue = crypto.createHash(algorithm).update(bytes).digest('base64');\n    if (actualValue[actualValue.length - 1] === '=') {\n      if (actualValue[actualValue.length - 2] === '=') {\n        actualValue = actualValue.slice(0, -2);\n      } else {\n        actualValue = actualValue.slice(0, -1);\n      }\n    }\n\n    // 4. If actualValue is a case-sensitive match for expectedValue,\n    //    return true.\n    if (compareBase64Mixed(actualValue, expectedValue)) {\n      return true;\n    }\n  }\n\n  // 7. Return false.\n  return false;\n}\n\n// https://w3c.github.io/webappsec-subresource-integrity/#grammardef-hash-with-options\n// https://www.w3.org/TR/CSP2/#source-list-syntax\n// https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1\nconst parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\\s|$)( +[!-~]*)?)?/i;\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n * @param {string} metadata\n */\nfunction parseMetadata(metadata) {\n  // 1. Let result be the empty set.\n  /** @type {{ algo: string, hash: string }[]} */\n  const result = [];\n\n  // 2. Let empty be equal to true.\n  let empty = true;\n\n  // 3. For each token returned by splitting metadata on spaces:\n  for (const token of metadata.split(' ')) {\n    // 1. Set empty to false.\n    empty = false;\n\n    // 2. Parse token as a hash-with-options.\n    const parsedToken = parseHashWithOptions.exec(token);\n\n    // 3. If token does not parse, continue to the next token.\n    if (parsedToken === null || parsedToken.groups === undefined || parsedToken.groups.algo === undefined) {\n      // Note: Chromium blocks the request at this point, but Firefox\n      // gives a warning that an invalid integrity was given. The\n      // correct behavior is to ignore these, and subsequently not\n      // check the integrity of the resource.\n      continue;\n    }\n\n    // 4. Let algorithm be the hash-algo component of token.\n    const algorithm = parsedToken.groups.algo.toLowerCase();\n\n    // 5. If algorithm is a hash function recognized by the user\n    //    agent, add the parsed token to result.\n    if (supportedHashes.includes(algorithm)) {\n      result.push(parsedToken.groups);\n    }\n  }\n\n  // 4. Return no metadata if empty is true, otherwise return result.\n  if (empty === true) {\n    return 'no metadata';\n  }\n  return result;\n}\n\n/**\n * @param {{ algo: 'sha256' | 'sha384' | 'sha512' }[]} metadataList\n */\nfunction getStrongestMetadata(metadataList) {\n  // Let algorithm be the algo component of the first item in metadataList.\n  // Can be sha256\n  let algorithm = metadataList[0].algo;\n  // If the algorithm is sha512, then it is the strongest\n  // and we can return immediately\n  if (algorithm[3] === '5') {\n    return algorithm;\n  }\n  for (let i = 1; i < metadataList.length; ++i) {\n    const metadata = metadataList[i];\n    // If the algorithm is sha512, then it is the strongest\n    // and we can break the loop immediately\n    if (metadata.algo[3] === '5') {\n      algorithm = 'sha512';\n      break;\n      // If the algorithm is sha384, then a potential sha256 or sha384 is ignored\n    } else if (algorithm[3] === '3') {\n      continue;\n      // algorithm is sha256, check if algorithm is sha384 and if so, set it as\n      // the strongest\n    } else if (metadata.algo[3] === '3') {\n      algorithm = 'sha384';\n    }\n  }\n  return algorithm;\n}\nfunction filterMetadataListByAlgorithm(metadataList, algorithm) {\n  if (metadataList.length === 1) {\n    return metadataList;\n  }\n  let pos = 0;\n  for (let i = 0; i < metadataList.length; ++i) {\n    if (metadataList[i].algo === algorithm) {\n      metadataList[pos++] = metadataList[i];\n    }\n  }\n  metadataList.length = pos;\n  return metadataList;\n}\n\n/**\n * Compares two base64 strings, allowing for base64url\n * in the second string.\n *\n* @param {string} actualValue always base64\n * @param {string} expectedValue base64 or base64url\n * @returns {boolean}\n */\nfunction compareBase64Mixed(actualValue, expectedValue) {\n  if (actualValue.length !== expectedValue.length) {\n    return false;\n  }\n  for (let i = 0; i < actualValue.length; ++i) {\n    if (actualValue[i] !== expectedValue[i]) {\n      if (actualValue[i] === '+' && expectedValue[i] === '-' || actualValue[i] === '/' && expectedValue[i] === '_') {\n        continue;\n      }\n      return false;\n    }\n  }\n  return true;\n}\n\n// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request\nfunction tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {\n  // TODO\n}\n\n/**\n * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}\n * @param {URL} A\n * @param {URL} B\n */\nfunction sameOrigin(A, B) {\n  // 1. If A and B are the same opaque origin, then return true.\n  if (A.origin === B.origin && A.origin === 'null') {\n    return true;\n  }\n\n  // 2. If A and B are both tuple origins and their schemes,\n  //    hosts, and port are identical, then return true.\n  if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {\n    return true;\n  }\n\n  // 3. Return false.\n  return false;\n}\nfunction createDeferredPromise() {\n  let res;\n  let rej;\n  const promise = new Promise((resolve, reject) => {\n    res = resolve;\n    rej = reject;\n  });\n  return {\n    promise,\n    resolve: res,\n    reject: rej\n  };\n}\nfunction isAborted(fetchParams) {\n  return fetchParams.controller.state === 'aborted';\n}\nfunction isCancelled(fetchParams) {\n  return fetchParams.controller.state === 'aborted' || fetchParams.controller.state === 'terminated';\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-method-normalize\n * @param {string} method\n */\nfunction normalizeMethod(method) {\n  return normalizedMethodRecordsBase[method.toLowerCase()] ?? method;\n}\n\n// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string\nfunction serializeJavascriptValueToJSONString(value) {\n  // 1. Let result be ? Call(%JSON.stringify%, undefined, « value »).\n  const result = JSON.stringify(value);\n\n  // 2. If result is undefined, then throw a TypeError.\n  if (result === undefined) {\n    throw new TypeError('Value is not JSON serializable');\n  }\n\n  // 3. Assert: result is a string.\n  assert(typeof result === 'string');\n\n  // 4. Return result.\n  return result;\n}\n\n// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object\nconst esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));\n\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {string} name name of the instance\n * @param {symbol} kInternalIterator\n * @param {string | number} [keyIndex]\n * @param {string | number} [valueIndex]\n */\nfunction createIterator(name, kInternalIterator, keyIndex = 0, valueIndex = 1) {\n  class FastIterableIterator {\n    /** @type {any} */\n    #target;\n    /** @type {'key' | 'value' | 'key+value'} */\n    #kind;\n    /** @type {number} */\n    #index;\n\n    /**\n     * @see https://webidl.spec.whatwg.org/#dfn-default-iterator-object\n     * @param {unknown} target\n     * @param {'key' | 'value' | 'key+value'} kind\n     */\n    constructor(target, kind) {\n      this.#target = target;\n      this.#kind = kind;\n      this.#index = 0;\n    }\n    next() {\n      // 1. Let interface be the interface for which the iterator prototype object exists.\n      // 2. Let thisValue be the this value.\n      // 3. Let object be ? ToObject(thisValue).\n      // 4. If object is a platform object, then perform a security\n      //    check, passing:\n      // 5. If object is not a default iterator object for interface,\n      //    then throw a TypeError.\n      if (typeof this !== 'object' || this === null || !(#target in this)) {\n        throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);\n      }\n\n      // 6. Let index be object’s index.\n      // 7. Let kind be object’s kind.\n      // 8. Let values be object’s target's value pairs to iterate over.\n      const index = this.#index;\n      const values = this.#target[kInternalIterator];\n\n      // 9. Let len be the length of values.\n      const len = values.length;\n\n      // 10. If index is greater than or equal to len, then return\n      //     CreateIterResultObject(undefined, true).\n      if (index >= len) {\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n\n      // 11. Let pair be the entry in values at index index.\n      const {\n        [keyIndex]: key,\n        [valueIndex]: value\n      } = values[index];\n\n      // 12. Set object’s index to index + 1.\n      this.#index = index + 1;\n\n      // 13. Return the iterator result for pair and kind.\n\n      // https://webidl.spec.whatwg.org/#iterator-result\n\n      // 1. Let result be a value determined by the value of kind:\n      let result;\n      switch (this.#kind) {\n        case 'key':\n          // 1. Let idlKey be pair’s key.\n          // 2. Let key be the result of converting idlKey to an\n          //    ECMAScript value.\n          // 3. result is key.\n          result = key;\n          break;\n        case 'value':\n          // 1. Let idlValue be pair’s value.\n          // 2. Let value be the result of converting idlValue to\n          //    an ECMAScript value.\n          // 3. result is value.\n          result = value;\n          break;\n        case 'key+value':\n          // 1. Let idlKey be pair’s key.\n          // 2. Let idlValue be pair’s value.\n          // 3. Let key be the result of converting idlKey to an\n          //    ECMAScript value.\n          // 4. Let value be the result of converting idlValue to\n          //    an ECMAScript value.\n          // 5. Let array be ! ArrayCreate(2).\n          // 6. Call ! CreateDataProperty(array, \"0\", key).\n          // 7. Call ! CreateDataProperty(array, \"1\", value).\n          // 8. result is array.\n          result = [key, value];\n          break;\n      }\n\n      // 2. Return CreateIterResultObject(result, false).\n      return {\n        value: result,\n        done: false\n      };\n    }\n  }\n\n  // https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n  // @ts-ignore\n  delete FastIterableIterator.prototype.constructor;\n  Object.setPrototypeOf(FastIterableIterator.prototype, esIteratorPrototype);\n  Object.defineProperties(FastIterableIterator.prototype, {\n    [Symbol.toStringTag]: {\n      writable: false,\n      enumerable: false,\n      configurable: true,\n      value: `${name} Iterator`\n    },\n    next: {\n      writable: true,\n      enumerable: true,\n      configurable: true\n    }\n  });\n\n  /**\n   * @param {unknown} target\n   * @param {'key' | 'value' | 'key+value'} kind\n   * @returns {IterableIterator<any>}\n   */\n  return function (target, kind) {\n    return new FastIterableIterator(target, kind);\n  };\n}\n\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {string} name name of the instance\n * @param {any} object class\n * @param {symbol} kInternalIterator\n * @param {string | number} [keyIndex]\n * @param {string | number} [valueIndex]\n */\nfunction iteratorMixin(name, object, kInternalIterator, keyIndex = 0, valueIndex = 1) {\n  const makeIterator = createIterator(name, kInternalIterator, keyIndex, valueIndex);\n  const properties = {\n    keys: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function keys() {\n        webidl.brandCheck(this, object);\n        return makeIterator(this, 'key');\n      }\n    },\n    values: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function values() {\n        webidl.brandCheck(this, object);\n        return makeIterator(this, 'value');\n      }\n    },\n    entries: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function entries() {\n        webidl.brandCheck(this, object);\n        return makeIterator(this, 'key+value');\n      }\n    },\n    forEach: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function forEach(callbackfn, thisArg = globalThis) {\n        webidl.brandCheck(this, object);\n        webidl.argumentLengthCheck(arguments, 1, `${name}.forEach`);\n        if (typeof callbackfn !== 'function') {\n          throw new TypeError(`Failed to execute 'forEach' on '${name}': parameter 1 is not of type 'Function'.`);\n        }\n        for (const {\n          0: key,\n          1: value\n        } of makeIterator(this, 'key+value')) {\n          callbackfn.call(thisArg, value, key, this);\n        }\n      }\n    }\n  };\n  return Object.defineProperties(object.prototype, {\n    ...properties,\n    [Symbol.iterator]: {\n      writable: true,\n      enumerable: false,\n      configurable: true,\n      value: properties.entries.value\n    }\n  });\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#body-fully-read\n */\nasync function fullyReadBody(body, processBody, processBodyError) {\n  // 1. If taskDestination is null, then set taskDestination to\n  //    the result of starting a new parallel queue.\n\n  // 2. Let successSteps given a byte sequence bytes be to queue a\n  //    fetch task to run processBody given bytes, with taskDestination.\n  const successSteps = processBody;\n\n  // 3. Let errorSteps be to queue a fetch task to run processBodyError,\n  //    with taskDestination.\n  const errorSteps = processBodyError;\n\n  // 4. Let reader be the result of getting a reader for body’s stream.\n  //    If that threw an exception, then run errorSteps with that\n  //    exception and return.\n  let reader;\n  try {\n    reader = body.stream.getReader();\n  } catch (e) {\n    errorSteps(e);\n    return;\n  }\n\n  // 5. Read all bytes from reader, given successSteps and errorSteps.\n  try {\n    successSteps(await readAllBytes(reader));\n  } catch (e) {\n    errorSteps(e);\n  }\n}\nfunction isReadableStreamLike(stream) {\n  return stream instanceof ReadableStream || stream[Symbol.toStringTag] === 'ReadableStream' && typeof stream.tee === 'function';\n}\n\n/**\n * @param {ReadableStreamController<Uint8Array>} controller\n */\nfunction readableStreamClose(controller) {\n  try {\n    controller.close();\n    controller.byobRequest?.respond(0);\n  } catch (err) {\n    // TODO: add comment explaining why this error occurs.\n    if (!err.message.includes('Controller is already closed') && !err.message.includes('ReadableStream is already closed')) {\n      throw err;\n    }\n  }\n}\nconst invalidIsomorphicEncodeValueRegex = /[^\\x00-\\xFF]/; // eslint-disable-line\n\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-encode\n * @param {string} input\n */\nfunction isomorphicEncode(input) {\n  // 1. Assert: input contains no code points greater than U+00FF.\n  assert(!invalidIsomorphicEncodeValueRegex.test(input));\n\n  // 2. Return a byte sequence whose length is equal to input’s code\n  //    point length and whose bytes have the same values as the\n  //    values of input’s code points, in the same order\n  return input;\n}\n\n/**\n * @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes\n * @see https://streams.spec.whatwg.org/#read-loop\n * @param {ReadableStreamDefaultReader} reader\n */\nasync function readAllBytes(reader) {\n  const bytes = [];\n  let byteLength = 0;\n  while (true) {\n    const {\n      done,\n      value: chunk\n    } = await reader.read();\n    if (done) {\n      // 1. Call successSteps with bytes.\n      return Buffer.concat(bytes, byteLength);\n    }\n\n    // 1. If chunk is not a Uint8Array object, call failureSteps\n    //    with a TypeError and abort these steps.\n    if (!isUint8Array(chunk)) {\n      throw new TypeError('Received non-Uint8Array chunk');\n    }\n\n    // 2. Append the bytes represented by chunk to bytes.\n    bytes.push(chunk);\n    byteLength += chunk.length;\n\n    // 3. Read-loop given reader, bytes, successSteps, and failureSteps.\n  }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#is-local\n * @param {URL} url\n */\nfunction urlIsLocal(url) {\n  assert('protocol' in url); // ensure it's a url object\n\n  const protocol = url.protocol;\n  return protocol === 'about:' || protocol === 'blob:' || protocol === 'data:';\n}\n\n/**\n * @param {string|URL} url\n * @returns {boolean}\n */\nfunction urlHasHttpsScheme(url) {\n  return typeof url === 'string' && url[5] === ':' && url[0] === 'h' && url[1] === 't' && url[2] === 't' && url[3] === 'p' && url[4] === 's' || url.protocol === 'https:';\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-scheme\n * @param {URL} url\n */\nfunction urlIsHttpHttpsScheme(url) {\n  assert('protocol' in url); // ensure it's a url object\n\n  const protocol = url.protocol;\n  return protocol === 'http:' || protocol === 'https:';\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#simple-range-header-value\n * @param {string} value\n * @param {boolean} allowWhitespace\n */\nfunction simpleRangeHeaderValue(value, allowWhitespace) {\n  // 1. Let data be the isomorphic decoding of value.\n  // Note: isomorphic decoding takes a sequence of bytes (ie. a Uint8Array) and turns it into a string,\n  // nothing more. We obviously don't need to do that if value is a string already.\n  const data = value;\n\n  // 2. If data does not start with \"bytes\", then return failure.\n  if (!data.startsWith('bytes')) {\n    return 'failure';\n  }\n\n  // 3. Let position be a position variable for data, initially pointing at the 5th code point of data.\n  const position = {\n    position: 5\n  };\n\n  // 4. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space,\n  //    from data given position.\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(char => char === '\\t' || char === ' ', data, position);\n  }\n\n  // 5. If the code point at position within data is not U+003D (=), then return failure.\n  if (data.charCodeAt(position.position) !== 0x3D) {\n    return 'failure';\n  }\n\n  // 6. Advance position by 1.\n  position.position++;\n\n  // 7. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space, from\n  //    data given position.\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(char => char === '\\t' || char === ' ', data, position);\n  }\n\n  // 8. Let rangeStart be the result of collecting a sequence of code points that are ASCII digits,\n  //    from data given position.\n  const rangeStart = collectASequenceOfCodePoints(char => {\n    const code = char.charCodeAt(0);\n    return code >= 0x30 && code <= 0x39;\n  }, data, position);\n\n  // 9. Let rangeStartValue be rangeStart, interpreted as decimal number, if rangeStart is not the\n  //    empty string; otherwise null.\n  const rangeStartValue = rangeStart.length ? Number(rangeStart) : null;\n\n  // 10. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space,\n  //     from data given position.\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(char => char === '\\t' || char === ' ', data, position);\n  }\n\n  // 11. If the code point at position within data is not U+002D (-), then return failure.\n  if (data.charCodeAt(position.position) !== 0x2D) {\n    return 'failure';\n  }\n\n  // 12. Advance position by 1.\n  position.position++;\n\n  // 13. If allowWhitespace is true, collect a sequence of code points that are HTTP tab\n  //     or space, from data given position.\n  // Note from Khafra: its the same step as in #8 again lol\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(char => char === '\\t' || char === ' ', data, position);\n  }\n\n  // 14. Let rangeEnd be the result of collecting a sequence of code points that are\n  //     ASCII digits, from data given position.\n  // Note from Khafra: you wouldn't guess it, but this is also the same step as #8\n  const rangeEnd = collectASequenceOfCodePoints(char => {\n    const code = char.charCodeAt(0);\n    return code >= 0x30 && code <= 0x39;\n  }, data, position);\n\n  // 15. Let rangeEndValue be rangeEnd, interpreted as decimal number, if rangeEnd\n  //     is not the empty string; otherwise null.\n  // Note from Khafra: THE SAME STEP, AGAIN!!!\n  // Note: why interpret as a decimal if we only collect ascii digits?\n  const rangeEndValue = rangeEnd.length ? Number(rangeEnd) : null;\n\n  // 16. If position is not past the end of data, then return failure.\n  if (position.position < data.length) {\n    return 'failure';\n  }\n\n  // 17. If rangeEndValue and rangeStartValue are null, then return failure.\n  if (rangeEndValue === null && rangeStartValue === null) {\n    return 'failure';\n  }\n\n  // 18. If rangeStartValue and rangeEndValue are numbers, and rangeStartValue is\n  //     greater than rangeEndValue, then return failure.\n  // Note: ... when can they not be numbers?\n  if (rangeStartValue > rangeEndValue) {\n    return 'failure';\n  }\n\n  // 19. Return (rangeStartValue, rangeEndValue).\n  return {\n    rangeStartValue,\n    rangeEndValue\n  };\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#build-a-content-range\n * @param {number} rangeStart\n * @param {number} rangeEnd\n * @param {number} fullLength\n */\nfunction buildContentRange(rangeStart, rangeEnd, fullLength) {\n  // 1. Let contentRange be `bytes `.\n  let contentRange = 'bytes ';\n\n  // 2. Append rangeStart, serialized and isomorphic encoded, to contentRange.\n  contentRange += isomorphicEncode(`${rangeStart}`);\n\n  // 3. Append 0x2D (-) to contentRange.\n  contentRange += '-';\n\n  // 4. Append rangeEnd, serialized and isomorphic encoded to contentRange.\n  contentRange += isomorphicEncode(`${rangeEnd}`);\n\n  // 5. Append 0x2F (/) to contentRange.\n  contentRange += '/';\n\n  // 6. Append fullLength, serialized and isomorphic encoded to contentRange.\n  contentRange += isomorphicEncode(`${fullLength}`);\n\n  // 7. Return contentRange.\n  return contentRange;\n}\n\n// A Stream, which pipes the response to zlib.createInflate() or\n// zlib.createInflateRaw() depending on the first byte of the Buffer.\n// If the lower byte of the first byte is 0x08, then the stream is\n// interpreted as a zlib stream, otherwise it's interpreted as a\n// raw deflate stream.\nclass InflateStream extends Transform {\n  _transform(chunk, encoding, callback) {\n    if (!this._inflateStream) {\n      if (chunk.length === 0) {\n        callback();\n        return;\n      }\n      this._inflateStream = (chunk[0] & 0x0F) === 0x08 ? zlib.createInflate() : zlib.createInflateRaw();\n      this._inflateStream.on('data', this.push.bind(this));\n      this._inflateStream.on('end', () => this.push(null));\n      this._inflateStream.on('error', err => this.destroy(err));\n    }\n    this._inflateStream.write(chunk, encoding, callback);\n  }\n  _final(callback) {\n    if (this._inflateStream) {\n      this._inflateStream.end();\n      this._inflateStream = null;\n    }\n    callback();\n  }\n}\nfunction createInflate() {\n  return new InflateStream();\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-extract-mime-type\n * @param {import('./headers').HeadersList} headers\n */\nfunction extractMimeType(headers) {\n  // 1. Let charset be null.\n  let charset = null;\n\n  // 2. Let essence be null.\n  let essence = null;\n\n  // 3. Let mimeType be null.\n  let mimeType = null;\n\n  // 4. Let values be the result of getting, decoding, and splitting `Content-Type` from headers.\n  const values = getDecodeSplit('content-type', headers);\n\n  // 5. If values is null, then return failure.\n  if (values === null) {\n    return 'failure';\n  }\n\n  // 6. For each value of values:\n  for (const value of values) {\n    // 6.1. Let temporaryMimeType be the result of parsing value.\n    const temporaryMimeType = parseMIMEType(value);\n\n    // 6.2. If temporaryMimeType is failure or its essence is \"*/*\", then continue.\n    if (temporaryMimeType === 'failure' || temporaryMimeType.essence === '*/*') {\n      continue;\n    }\n\n    // 6.3. Set mimeType to temporaryMimeType.\n    mimeType = temporaryMimeType;\n\n    // 6.4. If mimeType’s essence is not essence, then:\n    if (mimeType.essence !== essence) {\n      // 6.4.1. Set charset to null.\n      charset = null;\n\n      // 6.4.2. If mimeType’s parameters[\"charset\"] exists, then set charset to\n      //        mimeType’s parameters[\"charset\"].\n      if (mimeType.parameters.has('charset')) {\n        charset = mimeType.parameters.get('charset');\n      }\n\n      // 6.4.3. Set essence to mimeType’s essence.\n      essence = mimeType.essence;\n    } else if (!mimeType.parameters.has('charset') && charset !== null) {\n      // 6.5. Otherwise, if mimeType’s parameters[\"charset\"] does not exist, and\n      //      charset is non-null, set mimeType’s parameters[\"charset\"] to charset.\n      mimeType.parameters.set('charset', charset);\n    }\n  }\n\n  // 7. If mimeType is null, then return failure.\n  if (mimeType == null) {\n    return 'failure';\n  }\n\n  // 8. Return mimeType.\n  return mimeType;\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-value-get-decode-and-split\n * @param {string|null} value\n */\nfunction gettingDecodingSplitting(value) {\n  // 1. Let input be the result of isomorphic decoding value.\n  const input = value;\n\n  // 2. Let position be a position variable for input, initially pointing at the start of input.\n  const position = {\n    position: 0\n  };\n\n  // 3. Let values be a list of strings, initially empty.\n  const values = [];\n\n  // 4. Let temporaryValue be the empty string.\n  let temporaryValue = '';\n\n  // 5. While position is not past the end of input:\n  while (position.position < input.length) {\n    // 5.1. Append the result of collecting a sequence of code points that are not U+0022 (\")\n    //      or U+002C (,) from input, given position, to temporaryValue.\n    temporaryValue += collectASequenceOfCodePoints(char => char !== '\"' && char !== ',', input, position);\n\n    // 5.2. If position is not past the end of input, then:\n    if (position.position < input.length) {\n      // 5.2.1. If the code point at position within input is U+0022 (\"), then:\n      if (input.charCodeAt(position.position) === 0x22) {\n        // 5.2.1.1. Append the result of collecting an HTTP quoted string from input, given position, to temporaryValue.\n        temporaryValue += collectAnHTTPQuotedString(input, position);\n\n        // 5.2.1.2. If position is not past the end of input, then continue.\n        if (position.position < input.length) {\n          continue;\n        }\n      } else {\n        // 5.2.2. Otherwise:\n\n        // 5.2.2.1. Assert: the code point at position within input is U+002C (,).\n        assert(input.charCodeAt(position.position) === 0x2C);\n\n        // 5.2.2.2. Advance position by 1.\n        position.position++;\n      }\n    }\n\n    // 5.3. Remove all HTTP tab or space from the start and end of temporaryValue.\n    temporaryValue = removeChars(temporaryValue, true, true, char => char === 0x9 || char === 0x20);\n\n    // 5.4. Append temporaryValue to values.\n    values.push(temporaryValue);\n\n    // 5.6. Set temporaryValue to the empty string.\n    temporaryValue = '';\n  }\n\n  // 6. Return values.\n  return values;\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-list-get-decode-split\n * @param {string} name lowercase header name\n * @param {import('./headers').HeadersList} list\n */\nfunction getDecodeSplit(name, list) {\n  // 1. Let value be the result of getting name from list.\n  const value = list.get(name, true);\n\n  // 2. If value is null, then return null.\n  if (value === null) {\n    return null;\n  }\n\n  // 3. Return the result of getting, decoding, and splitting value.\n  return gettingDecodingSplitting(value);\n}\nconst textDecoder = new TextDecoder();\n\n/**\n * @see https://encoding.spec.whatwg.org/#utf-8-decode\n * @param {Buffer} buffer\n */\nfunction utf8DecodeBytes(buffer) {\n  if (buffer.length === 0) {\n    return '';\n  }\n\n  // 1. Let buffer be the result of peeking three bytes from\n  //    ioQueue, converted to a byte sequence.\n\n  // 2. If buffer is 0xEF 0xBB 0xBF, then read three\n  //    bytes from ioQueue. (Do nothing with those bytes.)\n  if (buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {\n    buffer = buffer.subarray(3);\n  }\n\n  // 3. Process a queue with an instance of UTF-8’s\n  //    decoder, ioQueue, output, and \"replacement\".\n  const output = textDecoder.decode(buffer);\n\n  // 4. Return output.\n  return output;\n}\nclass EnvironmentSettingsObjectBase {\n  get baseUrl() {\n    return getGlobalOrigin();\n  }\n  get origin() {\n    return this.baseUrl?.origin;\n  }\n  policyContainer = makePolicyContainer();\n}\nclass EnvironmentSettingsObject {\n  settingsObject = new EnvironmentSettingsObjectBase();\n}\nconst environmentSettingsObject = new EnvironmentSettingsObject();\nmodule.exports = {\n  isAborted,\n  isCancelled,\n  isValidEncodedURL,\n  createDeferredPromise,\n  ReadableStreamFrom,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  clampAndCoarsenConnectionTimingInfo,\n  coarsenedSharedCurrentTime,\n  determineRequestsReferrer,\n  makePolicyContainer,\n  clonePolicyContainer,\n  appendFetchMetadata,\n  appendRequestOriginHeader,\n  TAOCheck,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  createOpaqueTimingInfo,\n  setRequestReferrerPolicyOnRedirect,\n  isValidHTTPToken,\n  requestBadPort,\n  requestCurrentURL,\n  responseURL,\n  responseLocationURL,\n  isBlobLike,\n  isURLPotentiallyTrustworthy,\n  isValidReasonPhrase,\n  sameOrigin,\n  normalizeMethod,\n  serializeJavascriptValueToJSONString,\n  iteratorMixin,\n  createIterator,\n  isValidHeaderName,\n  isValidHeaderValue,\n  isErrorLike,\n  fullyReadBody,\n  bytesMatch,\n  isReadableStreamLike,\n  readableStreamClose,\n  isomorphicEncode,\n  urlIsLocal,\n  urlHasHttpsScheme,\n  urlIsHttpHttpsScheme,\n  readAllBytes,\n  simpleRangeHeaderValue,\n  buildContentRange,\n  parseMetadata,\n  createInflate,\n  extractMimeType,\n  getDecodeSplit,\n  utf8DecodeBytes,\n  environmentSettingsObject\n};","map":{"version":3,"names":["Transform","require","zlib","redirectStatusSet","referrerPolicySet","referrerPolicyTokens","badPortsSet","getGlobalOrigin","collectASequenceOfCodePoints","collectAnHTTPQuotedString","removeChars","parseMIMEType","performance","isBlobLike","ReadableStreamFrom","isValidHTTPToken","normalizedMethodRecordsBase","assert","isUint8Array","webidl","supportedHashes","crypto","possibleRelevantHashes","getHashes","filter","hash","includes","responseURL","response","urlList","length","toString","responseLocationURL","requestFragment","has","status","location","headersList","get","isValidHeaderValue","isValidEncodedURL","normalizeBinaryStringToUtf8","URL","url","i","code","charCodeAt","value","Buffer","from","requestCurrentURL","request","requestBadPort","urlIsHttpHttpsScheme","port","isErrorLike","object","Error","constructor","name","isValidReasonPhrase","statusText","c","isValidHeaderName","potentialValue","setRequestReferrerPolicyOnRedirect","actualResponse","policyHeader","split","policy","token","trim","referrerPolicy","crossOriginResourcePolicyCheck","corsCheck","TAOCheck","appendFetchMetadata","httpRequest","header","mode","set","appendRequestOriginHeader","serializedOrigin","origin","undefined","responseTainting","append","method","urlHasHttpsScheme","sameOrigin","coarsenTime","timestamp","crossOriginIsolatedCapability","clampAndCoarsenConnectionTimingInfo","connectionTimingInfo","defaultStartTime","startTime","domainLookupStartTime","domainLookupEndTime","connectionStartTime","connectionEndTime","secureConnectionStartTime","ALPNNegotiatedProtocol","coarsenedSharedCurrentTime","now","createOpaqueTimingInfo","timingInfo","redirectStartTime","redirectEndTime","postRedirectStartTime","finalServiceWorkerStartTime","finalNetworkResponseStartTime","finalNetworkRequestStartTime","endTime","encodedBodySize","decodedBodySize","finalConnectionTimingInfo","makePolicyContainer","clonePolicyContainer","policyContainer","determineRequestsReferrer","referrerSource","referrer","globalOrigin","referrerURL","stripURLForReferrer","referrerOrigin","areSameOrigin","isNonPotentiallyTrustWorthy","isURLPotentiallyTrustworthy","currentURL","originOnly","protocol","username","password","pathname","search","href","isOriginPotentiallyTrustworthy","originAsURL","test","hostname","endsWith","bytesMatch","bytes","metadataList","parsedMetadata","parseMetadata","strongest","getStrongestMetadata","metadata","filterMetadataListByAlgorithm","item","algorithm","algo","expectedValue","actualValue","createHash","update","digest","slice","compareBase64Mixed","parseHashWithOptions","result","empty","parsedToken","exec","groups","toLowerCase","push","pos","tryUpgradeRequestToAPotentiallyTrustworthyURL","A","B","createDeferredPromise","res","rej","promise","Promise","resolve","reject","isAborted","fetchParams","controller","state","isCancelled","normalizeMethod","serializeJavascriptValueToJSONString","JSON","stringify","TypeError","esIteratorPrototype","Object","getPrototypeOf","Symbol","iterator","createIterator","kInternalIterator","keyIndex","valueIndex","FastIterableIterator","target","kind","index","next","values","len","done","key","prototype","setPrototypeOf","defineProperties","toStringTag","writable","enumerable","configurable","iteratorMixin","makeIterator","properties","keys","brandCheck","entries","forEach","callbackfn","thisArg","globalThis","argumentLengthCheck","arguments","call","fullyReadBody","body","processBody","processBodyError","successSteps","errorSteps","reader","stream","getReader","e","readAllBytes","isReadableStreamLike","ReadableStream","tee","readableStreamClose","close","byobRequest","respond","err","message","invalidIsomorphicEncodeValueRegex","isomorphicEncode","input","byteLength","chunk","read","concat","urlIsLocal","simpleRangeHeaderValue","allowWhitespace","data","startsWith","position","char","rangeStart","rangeStartValue","Number","rangeEnd","rangeEndValue","buildContentRange","fullLength","contentRange","InflateStream","_transform","encoding","callback","_inflateStream","createInflate","createInflateRaw","on","bind","destroy","write","_final","end","extractMimeType","headers","charset","essence","mimeType","getDecodeSplit","temporaryMimeType","parameters","gettingDecodingSplitting","temporaryValue","list","textDecoder","TextDecoder","utf8DecodeBytes","buffer","subarray","output","decode","EnvironmentSettingsObjectBase","baseUrl","EnvironmentSettingsObject","settingsObject","environmentSettingsObject","module","exports"],"sources":["/Users/nataliia/PussyProjects/react-app/node_modules/undici/lib/web/fetch/util.js"],"sourcesContent":["'use strict'\n\nconst { Transform } = require('node:stream')\nconst zlib = require('node:zlib')\nconst { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = require('./constants')\nconst { getGlobalOrigin } = require('./global')\nconst { collectASequenceOfCodePoints, collectAnHTTPQuotedString, removeChars, parseMIMEType } = require('./data-url')\nconst { performance } = require('node:perf_hooks')\nconst { isBlobLike, ReadableStreamFrom, isValidHTTPToken, normalizedMethodRecordsBase } = require('../../core/util')\nconst assert = require('node:assert')\nconst { isUint8Array } = require('node:util/types')\nconst { webidl } = require('./webidl')\n\nlet supportedHashes = []\n\n// https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable\n/** @type {import('crypto')} */\nlet crypto\ntry {\n  crypto = require('node:crypto')\n  const possibleRelevantHashes = ['sha256', 'sha384', 'sha512']\n  supportedHashes = crypto.getHashes().filter((hash) => possibleRelevantHashes.includes(hash))\n/* c8 ignore next 3 */\n} catch {\n\n}\n\nfunction responseURL (response) {\n  // https://fetch.spec.whatwg.org/#responses\n  // A response has an associated URL. It is a pointer to the last URL\n  // in response’s URL list and null if response’s URL list is empty.\n  const urlList = response.urlList\n  const length = urlList.length\n  return length === 0 ? null : urlList[length - 1].toString()\n}\n\n// https://fetch.spec.whatwg.org/#concept-response-location-url\nfunction responseLocationURL (response, requestFragment) {\n  // 1. If response’s status is not a redirect status, then return null.\n  if (!redirectStatusSet.has(response.status)) {\n    return null\n  }\n\n  // 2. Let location be the result of extracting header list values given\n  // `Location` and response’s header list.\n  let location = response.headersList.get('location', true)\n\n  // 3. If location is a header value, then set location to the result of\n  //    parsing location with response’s URL.\n  if (location !== null && isValidHeaderValue(location)) {\n    if (!isValidEncodedURL(location)) {\n      // Some websites respond location header in UTF-8 form without encoding them as ASCII\n      // and major browsers redirect them to correctly UTF-8 encoded addresses.\n      // Here, we handle that behavior in the same way.\n      location = normalizeBinaryStringToUtf8(location)\n    }\n    location = new URL(location, responseURL(response))\n  }\n\n  // 4. If location is a URL whose fragment is null, then set location’s\n  // fragment to requestFragment.\n  if (location && !location.hash) {\n    location.hash = requestFragment\n  }\n\n  // 5. Return location.\n  return location\n}\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc1738#section-2.2\n * @param {string} url\n * @returns {boolean}\n */\nfunction isValidEncodedURL (url) {\n  for (let i = 0; i < url.length; ++i) {\n    const code = url.charCodeAt(i)\n\n    if (\n      code > 0x7E || // Non-US-ASCII + DEL\n      code < 0x20 // Control characters NUL - US\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * If string contains non-ASCII characters, assumes it's UTF-8 encoded and decodes it.\n * Since UTF-8 is a superset of ASCII, this will work for ASCII strings as well.\n * @param {string} value\n * @returns {string}\n */\nfunction normalizeBinaryStringToUtf8 (value) {\n  return Buffer.from(value, 'binary').toString('utf8')\n}\n\n/** @returns {URL} */\nfunction requestCurrentURL (request) {\n  return request.urlList[request.urlList.length - 1]\n}\n\nfunction requestBadPort (request) {\n  // 1. Let url be request’s current URL.\n  const url = requestCurrentURL(request)\n\n  // 2. If url’s scheme is an HTTP(S) scheme and url’s port is a bad port,\n  // then return blocked.\n  if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {\n    return 'blocked'\n  }\n\n  // 3. Return allowed.\n  return 'allowed'\n}\n\nfunction isErrorLike (object) {\n  return object instanceof Error || (\n    object?.constructor?.name === 'Error' ||\n    object?.constructor?.name === 'DOMException'\n  )\n}\n\n// Check whether |statusText| is a ByteString and\n// matches the Reason-Phrase token production.\n// RFC 2616: https://tools.ietf.org/html/rfc2616\n// RFC 7230: https://tools.ietf.org/html/rfc7230\n// \"reason-phrase = *( HTAB / SP / VCHAR / obs-text )\"\n// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116\nfunction isValidReasonPhrase (statusText) {\n  for (let i = 0; i < statusText.length; ++i) {\n    const c = statusText.charCodeAt(i)\n    if (\n      !(\n        (\n          c === 0x09 || // HTAB\n          (c >= 0x20 && c <= 0x7e) || // SP / VCHAR\n          (c >= 0x80 && c <= 0xff)\n        ) // obs-text\n      )\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-name\n * @param {string} potentialValue\n */\nconst isValidHeaderName = isValidHTTPToken\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-value\n * @param {string} potentialValue\n */\nfunction isValidHeaderValue (potentialValue) {\n  // - Has no leading or trailing HTTP tab or space bytes.\n  // - Contains no 0x00 (NUL) or HTTP newline bytes.\n  return (\n    potentialValue[0] === '\\t' ||\n    potentialValue[0] === ' ' ||\n    potentialValue[potentialValue.length - 1] === '\\t' ||\n    potentialValue[potentialValue.length - 1] === ' ' ||\n    potentialValue.includes('\\n') ||\n    potentialValue.includes('\\r') ||\n    potentialValue.includes('\\0')\n  ) === false\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect\nfunction setRequestReferrerPolicyOnRedirect (request, actualResponse) {\n  //  Given a request request and a response actualResponse, this algorithm\n  //  updates request’s referrer policy according to the Referrer-Policy\n  //  header (if any) in actualResponse.\n\n  // 1. Let policy be the result of executing § 8.1 Parse a referrer policy\n  // from a Referrer-Policy header on actualResponse.\n\n  // 8.1 Parse a referrer policy from a Referrer-Policy header\n  // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy` and response’s header list.\n  const { headersList } = actualResponse\n  // 2. Let policy be the empty string.\n  // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty string, then set policy to token.\n  // 4. Return policy.\n  const policyHeader = (headersList.get('referrer-policy', true) ?? '').split(',')\n\n  // Note: As the referrer-policy can contain multiple policies\n  // separated by comma, we need to loop through all of them\n  // and pick the first valid one.\n  // Ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy#specify_a_fallback_policy\n  let policy = ''\n  if (policyHeader.length > 0) {\n    // The right-most policy takes precedence.\n    // The left-most policy is the fallback.\n    for (let i = policyHeader.length; i !== 0; i--) {\n      const token = policyHeader[i - 1].trim()\n      if (referrerPolicyTokens.has(token)) {\n        policy = token\n        break\n      }\n    }\n  }\n\n  // 2. If policy is not the empty string, then set request’s referrer policy to policy.\n  if (policy !== '') {\n    request.referrerPolicy = policy\n  }\n}\n\n// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check\nfunction crossOriginResourcePolicyCheck () {\n  // TODO\n  return 'allowed'\n}\n\n// https://fetch.spec.whatwg.org/#concept-cors-check\nfunction corsCheck () {\n  // TODO\n  return 'success'\n}\n\n// https://fetch.spec.whatwg.org/#concept-tao-check\nfunction TAOCheck () {\n  // TODO\n  return 'success'\n}\n\nfunction appendFetchMetadata (httpRequest) {\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header\n\n  //  1. Assert: r’s url is a potentially trustworthy URL.\n  //  TODO\n\n  //  2. Let header be a Structured Header whose value is a token.\n  let header = null\n\n  //  3. Set header’s value to r’s mode.\n  header = httpRequest.mode\n\n  //  4. Set a structured field value `Sec-Fetch-Mode`/header in r’s header list.\n  httpRequest.headersList.set('sec-fetch-mode', header, true)\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header\n  //  TODO\n}\n\n// https://fetch.spec.whatwg.org/#append-a-request-origin-header\nfunction appendRequestOriginHeader (request) {\n  // 1. Let serializedOrigin be the result of byte-serializing a request origin\n  //    with request.\n  // TODO: implement \"byte-serializing a request origin\"\n  let serializedOrigin = request.origin\n\n  // - \"'client' is changed to an origin during fetching.\"\n  //   This doesn't happen in undici (in most cases) because undici, by default,\n  //   has no concept of origin.\n  // - request.origin can also be set to request.client.origin (client being\n  //   an environment settings object), which is undefined without using\n  //   setGlobalOrigin.\n  if (serializedOrigin === 'client' || serializedOrigin === undefined) {\n    return\n  }\n\n  // 2. If request’s response tainting is \"cors\" or request’s mode is \"websocket\",\n  //    then append (`Origin`, serializedOrigin) to request’s header list.\n  // 3. Otherwise, if request’s method is neither `GET` nor `HEAD`, then:\n  if (request.responseTainting === 'cors' || request.mode === 'websocket') {\n    request.headersList.append('origin', serializedOrigin, true)\n  } else if (request.method !== 'GET' && request.method !== 'HEAD') {\n    // 1. Switch on request’s referrer policy:\n    switch (request.referrerPolicy) {\n      case 'no-referrer':\n        // Set serializedOrigin to `null`.\n        serializedOrigin = null\n        break\n      case 'no-referrer-when-downgrade':\n      case 'strict-origin':\n      case 'strict-origin-when-cross-origin':\n        // If request’s origin is a tuple origin, its scheme is \"https\", and\n        // request’s current URL’s scheme is not \"https\", then set\n        // serializedOrigin to `null`.\n        if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      case 'same-origin':\n        // If request’s origin is not same origin with request’s current URL’s\n        // origin, then set serializedOrigin to `null`.\n        if (!sameOrigin(request, requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      default:\n        // Do nothing.\n    }\n\n    // 2. Append (`Origin`, serializedOrigin) to request’s header list.\n    request.headersList.append('origin', serializedOrigin, true)\n  }\n}\n\n// https://w3c.github.io/hr-time/#dfn-coarsen-time\nfunction coarsenTime (timestamp, crossOriginIsolatedCapability) {\n  // TODO\n  return timestamp\n}\n\n// https://fetch.spec.whatwg.org/#clamp-and-coarsen-connection-timing-info\nfunction clampAndCoarsenConnectionTimingInfo (connectionTimingInfo, defaultStartTime, crossOriginIsolatedCapability) {\n  if (!connectionTimingInfo?.startTime || connectionTimingInfo.startTime < defaultStartTime) {\n    return {\n      domainLookupStartTime: defaultStartTime,\n      domainLookupEndTime: defaultStartTime,\n      connectionStartTime: defaultStartTime,\n      connectionEndTime: defaultStartTime,\n      secureConnectionStartTime: defaultStartTime,\n      ALPNNegotiatedProtocol: connectionTimingInfo?.ALPNNegotiatedProtocol\n    }\n  }\n\n  return {\n    domainLookupStartTime: coarsenTime(connectionTimingInfo.domainLookupStartTime, crossOriginIsolatedCapability),\n    domainLookupEndTime: coarsenTime(connectionTimingInfo.domainLookupEndTime, crossOriginIsolatedCapability),\n    connectionStartTime: coarsenTime(connectionTimingInfo.connectionStartTime, crossOriginIsolatedCapability),\n    connectionEndTime: coarsenTime(connectionTimingInfo.connectionEndTime, crossOriginIsolatedCapability),\n    secureConnectionStartTime: coarsenTime(connectionTimingInfo.secureConnectionStartTime, crossOriginIsolatedCapability),\n    ALPNNegotiatedProtocol: connectionTimingInfo.ALPNNegotiatedProtocol\n  }\n}\n\n// https://w3c.github.io/hr-time/#dfn-coarsened-shared-current-time\nfunction coarsenedSharedCurrentTime (crossOriginIsolatedCapability) {\n  return coarsenTime(performance.now(), crossOriginIsolatedCapability)\n}\n\n// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info\nfunction createOpaqueTimingInfo (timingInfo) {\n  return {\n    startTime: timingInfo.startTime ?? 0,\n    redirectStartTime: 0,\n    redirectEndTime: 0,\n    postRedirectStartTime: timingInfo.startTime ?? 0,\n    finalServiceWorkerStartTime: 0,\n    finalNetworkResponseStartTime: 0,\n    finalNetworkRequestStartTime: 0,\n    endTime: 0,\n    encodedBodySize: 0,\n    decodedBodySize: 0,\n    finalConnectionTimingInfo: null\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#policy-container\nfunction makePolicyContainer () {\n  // Note: the fetch spec doesn't make use of embedder policy or CSP list\n  return {\n    referrerPolicy: 'strict-origin-when-cross-origin'\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container\nfunction clonePolicyContainer (policyContainer) {\n  return {\n    referrerPolicy: policyContainer.referrerPolicy\n  }\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer\nfunction determineRequestsReferrer (request) {\n  // 1. Let policy be request's referrer policy.\n  const policy = request.referrerPolicy\n\n  // Note: policy cannot (shouldn't) be null or an empty string.\n  assert(policy)\n\n  // 2. Let environment be request’s client.\n\n  let referrerSource = null\n\n  // 3. Switch on request’s referrer:\n  if (request.referrer === 'client') {\n    // Note: node isn't a browser and doesn't implement document/iframes,\n    // so we bypass this step and replace it with our own.\n\n    const globalOrigin = getGlobalOrigin()\n\n    if (!globalOrigin || globalOrigin.origin === 'null') {\n      return 'no-referrer'\n    }\n\n    // note: we need to clone it as it's mutated\n    referrerSource = new URL(globalOrigin)\n  } else if (request.referrer instanceof URL) {\n    // Let referrerSource be request’s referrer.\n    referrerSource = request.referrer\n  }\n\n  // 4. Let request’s referrerURL be the result of stripping referrerSource for\n  //    use as a referrer.\n  let referrerURL = stripURLForReferrer(referrerSource)\n\n  // 5. Let referrerOrigin be the result of stripping referrerSource for use as\n  //    a referrer, with the origin-only flag set to true.\n  const referrerOrigin = stripURLForReferrer(referrerSource, true)\n\n  // 6. If the result of serializing referrerURL is a string whose length is\n  //    greater than 4096, set referrerURL to referrerOrigin.\n  if (referrerURL.toString().length > 4096) {\n    referrerURL = referrerOrigin\n  }\n\n  const areSameOrigin = sameOrigin(request, referrerURL)\n  const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) &&\n    !isURLPotentiallyTrustworthy(request.url)\n\n  // 8. Execute the switch statements corresponding to the value of policy:\n  switch (policy) {\n    case 'origin': return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true)\n    case 'unsafe-url': return referrerURL\n    case 'same-origin':\n      return areSameOrigin ? referrerOrigin : 'no-referrer'\n    case 'origin-when-cross-origin':\n      return areSameOrigin ? referrerURL : referrerOrigin\n    case 'strict-origin-when-cross-origin': {\n      const currentURL = requestCurrentURL(request)\n\n      // 1. If the origin of referrerURL and the origin of request’s current\n      //    URL are the same, then return referrerURL.\n      if (sameOrigin(referrerURL, currentURL)) {\n        return referrerURL\n      }\n\n      // 2. If referrerURL is a potentially trustworthy URL and request’s\n      //    current URL is not a potentially trustworthy URL, then return no\n      //    referrer.\n      if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {\n        return 'no-referrer'\n      }\n\n      // 3. Return referrerOrigin.\n      return referrerOrigin\n    }\n    case 'strict-origin': // eslint-disable-line\n      /**\n         * 1. If referrerURL is a potentially trustworthy URL and\n         * request’s current URL is not a potentially trustworthy URL,\n         * then return no referrer.\n         * 2. Return referrerOrigin\n        */\n    case 'no-referrer-when-downgrade': // eslint-disable-line\n      /**\n       * 1. If referrerURL is a potentially trustworthy URL and\n       * request’s current URL is not a potentially trustworthy URL,\n       * then return no referrer.\n       * 2. Return referrerOrigin\n      */\n\n    default: // eslint-disable-line\n      return isNonPotentiallyTrustWorthy ? 'no-referrer' : referrerOrigin\n  }\n}\n\n/**\n * @see https://w3c.github.io/webappsec-referrer-policy/#strip-url\n * @param {URL} url\n * @param {boolean|undefined} originOnly\n */\nfunction stripURLForReferrer (url, originOnly) {\n  // 1. Assert: url is a URL.\n  assert(url instanceof URL)\n\n  url = new URL(url)\n\n  // 2. If url’s scheme is a local scheme, then return no referrer.\n  if (url.protocol === 'file:' || url.protocol === 'about:' || url.protocol === 'blank:') {\n    return 'no-referrer'\n  }\n\n  // 3. Set url’s username to the empty string.\n  url.username = ''\n\n  // 4. Set url’s password to the empty string.\n  url.password = ''\n\n  // 5. Set url’s fragment to null.\n  url.hash = ''\n\n  // 6. If the origin-only flag is true, then:\n  if (originOnly) {\n    // 1. Set url’s path to « the empty string ».\n    url.pathname = ''\n\n    // 2. Set url’s query to null.\n    url.search = ''\n  }\n\n  // 7. Return url.\n  return url\n}\n\nfunction isURLPotentiallyTrustworthy (url) {\n  if (!(url instanceof URL)) {\n    return false\n  }\n\n  // If child of about, return true\n  if (url.href === 'about:blank' || url.href === 'about:srcdoc') {\n    return true\n  }\n\n  // If scheme is data, return true\n  if (url.protocol === 'data:') return true\n\n  // If file, return true\n  if (url.protocol === 'file:') return true\n\n  return isOriginPotentiallyTrustworthy(url.origin)\n\n  function isOriginPotentiallyTrustworthy (origin) {\n    // If origin is explicitly null, return false\n    if (origin == null || origin === 'null') return false\n\n    const originAsURL = new URL(origin)\n\n    // If secure, return true\n    if (originAsURL.protocol === 'https:' || originAsURL.protocol === 'wss:') {\n      return true\n    }\n\n    // If localhost or variants, return true\n    if (/^127(?:\\.[0-9]+){0,2}\\.[0-9]+$|^\\[(?:0*:)*?:?0*1\\]$/.test(originAsURL.hostname) ||\n     (originAsURL.hostname === 'localhost' || originAsURL.hostname.includes('localhost.')) ||\n     (originAsURL.hostname.endsWith('.localhost'))) {\n      return true\n    }\n\n    // If any other, return false\n    return false\n  }\n}\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist\n * @param {Uint8Array} bytes\n * @param {string} metadataList\n */\nfunction bytesMatch (bytes, metadataList) {\n  // If node is not built with OpenSSL support, we cannot check\n  // a request's integrity, so allow it by default (the spec will\n  // allow requests if an invalid hash is given, as precedence).\n  /* istanbul ignore if: only if node is built with --without-ssl */\n  if (crypto === undefined) {\n    return true\n  }\n\n  // 1. Let parsedMetadata be the result of parsing metadataList.\n  const parsedMetadata = parseMetadata(metadataList)\n\n  // 2. If parsedMetadata is no metadata, return true.\n  if (parsedMetadata === 'no metadata') {\n    return true\n  }\n\n  // 3. If response is not eligible for integrity validation, return false.\n  // TODO\n\n  // 4. If parsedMetadata is the empty set, return true.\n  if (parsedMetadata.length === 0) {\n    return true\n  }\n\n  // 5. Let metadata be the result of getting the strongest\n  //    metadata from parsedMetadata.\n  const strongest = getStrongestMetadata(parsedMetadata)\n  const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest)\n\n  // 6. For each item in metadata:\n  for (const item of metadata) {\n    // 1. Let algorithm be the alg component of item.\n    const algorithm = item.algo\n\n    // 2. Let expectedValue be the val component of item.\n    const expectedValue = item.hash\n\n    // See https://github.com/web-platform-tests/wpt/commit/e4c5cc7a5e48093220528dfdd1c4012dc3837a0e\n    // \"be liberal with padding\". This is annoying, and it's not even in the spec.\n\n    // 3. Let actualValue be the result of applying algorithm to bytes.\n    let actualValue = crypto.createHash(algorithm).update(bytes).digest('base64')\n\n    if (actualValue[actualValue.length - 1] === '=') {\n      if (actualValue[actualValue.length - 2] === '=') {\n        actualValue = actualValue.slice(0, -2)\n      } else {\n        actualValue = actualValue.slice(0, -1)\n      }\n    }\n\n    // 4. If actualValue is a case-sensitive match for expectedValue,\n    //    return true.\n    if (compareBase64Mixed(actualValue, expectedValue)) {\n      return true\n    }\n  }\n\n  // 7. Return false.\n  return false\n}\n\n// https://w3c.github.io/webappsec-subresource-integrity/#grammardef-hash-with-options\n// https://www.w3.org/TR/CSP2/#source-list-syntax\n// https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1\nconst parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\\s|$)( +[!-~]*)?)?/i\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n * @param {string} metadata\n */\nfunction parseMetadata (metadata) {\n  // 1. Let result be the empty set.\n  /** @type {{ algo: string, hash: string }[]} */\n  const result = []\n\n  // 2. Let empty be equal to true.\n  let empty = true\n\n  // 3. For each token returned by splitting metadata on spaces:\n  for (const token of metadata.split(' ')) {\n    // 1. Set empty to false.\n    empty = false\n\n    // 2. Parse token as a hash-with-options.\n    const parsedToken = parseHashWithOptions.exec(token)\n\n    // 3. If token does not parse, continue to the next token.\n    if (\n      parsedToken === null ||\n      parsedToken.groups === undefined ||\n      parsedToken.groups.algo === undefined\n    ) {\n      // Note: Chromium blocks the request at this point, but Firefox\n      // gives a warning that an invalid integrity was given. The\n      // correct behavior is to ignore these, and subsequently not\n      // check the integrity of the resource.\n      continue\n    }\n\n    // 4. Let algorithm be the hash-algo component of token.\n    const algorithm = parsedToken.groups.algo.toLowerCase()\n\n    // 5. If algorithm is a hash function recognized by the user\n    //    agent, add the parsed token to result.\n    if (supportedHashes.includes(algorithm)) {\n      result.push(parsedToken.groups)\n    }\n  }\n\n  // 4. Return no metadata if empty is true, otherwise return result.\n  if (empty === true) {\n    return 'no metadata'\n  }\n\n  return result\n}\n\n/**\n * @param {{ algo: 'sha256' | 'sha384' | 'sha512' }[]} metadataList\n */\nfunction getStrongestMetadata (metadataList) {\n  // Let algorithm be the algo component of the first item in metadataList.\n  // Can be sha256\n  let algorithm = metadataList[0].algo\n  // If the algorithm is sha512, then it is the strongest\n  // and we can return immediately\n  if (algorithm[3] === '5') {\n    return algorithm\n  }\n\n  for (let i = 1; i < metadataList.length; ++i) {\n    const metadata = metadataList[i]\n    // If the algorithm is sha512, then it is the strongest\n    // and we can break the loop immediately\n    if (metadata.algo[3] === '5') {\n      algorithm = 'sha512'\n      break\n    // If the algorithm is sha384, then a potential sha256 or sha384 is ignored\n    } else if (algorithm[3] === '3') {\n      continue\n    // algorithm is sha256, check if algorithm is sha384 and if so, set it as\n    // the strongest\n    } else if (metadata.algo[3] === '3') {\n      algorithm = 'sha384'\n    }\n  }\n  return algorithm\n}\n\nfunction filterMetadataListByAlgorithm (metadataList, algorithm) {\n  if (metadataList.length === 1) {\n    return metadataList\n  }\n\n  let pos = 0\n  for (let i = 0; i < metadataList.length; ++i) {\n    if (metadataList[i].algo === algorithm) {\n      metadataList[pos++] = metadataList[i]\n    }\n  }\n\n  metadataList.length = pos\n\n  return metadataList\n}\n\n/**\n * Compares two base64 strings, allowing for base64url\n * in the second string.\n *\n* @param {string} actualValue always base64\n * @param {string} expectedValue base64 or base64url\n * @returns {boolean}\n */\nfunction compareBase64Mixed (actualValue, expectedValue) {\n  if (actualValue.length !== expectedValue.length) {\n    return false\n  }\n  for (let i = 0; i < actualValue.length; ++i) {\n    if (actualValue[i] !== expectedValue[i]) {\n      if (\n        (actualValue[i] === '+' && expectedValue[i] === '-') ||\n        (actualValue[i] === '/' && expectedValue[i] === '_')\n      ) {\n        continue\n      }\n      return false\n    }\n  }\n\n  return true\n}\n\n// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request\nfunction tryUpgradeRequestToAPotentiallyTrustworthyURL (request) {\n  // TODO\n}\n\n/**\n * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}\n * @param {URL} A\n * @param {URL} B\n */\nfunction sameOrigin (A, B) {\n  // 1. If A and B are the same opaque origin, then return true.\n  if (A.origin === B.origin && A.origin === 'null') {\n    return true\n  }\n\n  // 2. If A and B are both tuple origins and their schemes,\n  //    hosts, and port are identical, then return true.\n  if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {\n    return true\n  }\n\n  // 3. Return false.\n  return false\n}\n\nfunction createDeferredPromise () {\n  let res\n  let rej\n  const promise = new Promise((resolve, reject) => {\n    res = resolve\n    rej = reject\n  })\n\n  return { promise, resolve: res, reject: rej }\n}\n\nfunction isAborted (fetchParams) {\n  return fetchParams.controller.state === 'aborted'\n}\n\nfunction isCancelled (fetchParams) {\n  return fetchParams.controller.state === 'aborted' ||\n    fetchParams.controller.state === 'terminated'\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-method-normalize\n * @param {string} method\n */\nfunction normalizeMethod (method) {\n  return normalizedMethodRecordsBase[method.toLowerCase()] ?? method\n}\n\n// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string\nfunction serializeJavascriptValueToJSONString (value) {\n  // 1. Let result be ? Call(%JSON.stringify%, undefined, « value »).\n  const result = JSON.stringify(value)\n\n  // 2. If result is undefined, then throw a TypeError.\n  if (result === undefined) {\n    throw new TypeError('Value is not JSON serializable')\n  }\n\n  // 3. Assert: result is a string.\n  assert(typeof result === 'string')\n\n  // 4. Return result.\n  return result\n}\n\n// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object\nconst esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()))\n\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {string} name name of the instance\n * @param {symbol} kInternalIterator\n * @param {string | number} [keyIndex]\n * @param {string | number} [valueIndex]\n */\nfunction createIterator (name, kInternalIterator, keyIndex = 0, valueIndex = 1) {\n  class FastIterableIterator {\n    /** @type {any} */\n    #target\n    /** @type {'key' | 'value' | 'key+value'} */\n    #kind\n    /** @type {number} */\n    #index\n\n    /**\n     * @see https://webidl.spec.whatwg.org/#dfn-default-iterator-object\n     * @param {unknown} target\n     * @param {'key' | 'value' | 'key+value'} kind\n     */\n    constructor (target, kind) {\n      this.#target = target\n      this.#kind = kind\n      this.#index = 0\n    }\n\n    next () {\n      // 1. Let interface be the interface for which the iterator prototype object exists.\n      // 2. Let thisValue be the this value.\n      // 3. Let object be ? ToObject(thisValue).\n      // 4. If object is a platform object, then perform a security\n      //    check, passing:\n      // 5. If object is not a default iterator object for interface,\n      //    then throw a TypeError.\n      if (typeof this !== 'object' || this === null || !(#target in this)) {\n        throw new TypeError(\n          `'next' called on an object that does not implement interface ${name} Iterator.`\n        )\n      }\n\n      // 6. Let index be object’s index.\n      // 7. Let kind be object’s kind.\n      // 8. Let values be object’s target's value pairs to iterate over.\n      const index = this.#index\n      const values = this.#target[kInternalIterator]\n\n      // 9. Let len be the length of values.\n      const len = values.length\n\n      // 10. If index is greater than or equal to len, then return\n      //     CreateIterResultObject(undefined, true).\n      if (index >= len) {\n        return {\n          value: undefined,\n          done: true\n        }\n      }\n\n      // 11. Let pair be the entry in values at index index.\n      const { [keyIndex]: key, [valueIndex]: value } = values[index]\n\n      // 12. Set object’s index to index + 1.\n      this.#index = index + 1\n\n      // 13. Return the iterator result for pair and kind.\n\n      // https://webidl.spec.whatwg.org/#iterator-result\n\n      // 1. Let result be a value determined by the value of kind:\n      let result\n      switch (this.#kind) {\n        case 'key':\n          // 1. Let idlKey be pair’s key.\n          // 2. Let key be the result of converting idlKey to an\n          //    ECMAScript value.\n          // 3. result is key.\n          result = key\n          break\n        case 'value':\n          // 1. Let idlValue be pair’s value.\n          // 2. Let value be the result of converting idlValue to\n          //    an ECMAScript value.\n          // 3. result is value.\n          result = value\n          break\n        case 'key+value':\n          // 1. Let idlKey be pair’s key.\n          // 2. Let idlValue be pair’s value.\n          // 3. Let key be the result of converting idlKey to an\n          //    ECMAScript value.\n          // 4. Let value be the result of converting idlValue to\n          //    an ECMAScript value.\n          // 5. Let array be ! ArrayCreate(2).\n          // 6. Call ! CreateDataProperty(array, \"0\", key).\n          // 7. Call ! CreateDataProperty(array, \"1\", value).\n          // 8. result is array.\n          result = [key, value]\n          break\n      }\n\n      // 2. Return CreateIterResultObject(result, false).\n      return {\n        value: result,\n        done: false\n      }\n    }\n  }\n\n  // https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n  // @ts-ignore\n  delete FastIterableIterator.prototype.constructor\n\n  Object.setPrototypeOf(FastIterableIterator.prototype, esIteratorPrototype)\n\n  Object.defineProperties(FastIterableIterator.prototype, {\n    [Symbol.toStringTag]: {\n      writable: false,\n      enumerable: false,\n      configurable: true,\n      value: `${name} Iterator`\n    },\n    next: { writable: true, enumerable: true, configurable: true }\n  })\n\n  /**\n   * @param {unknown} target\n   * @param {'key' | 'value' | 'key+value'} kind\n   * @returns {IterableIterator<any>}\n   */\n  return function (target, kind) {\n    return new FastIterableIterator(target, kind)\n  }\n}\n\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {string} name name of the instance\n * @param {any} object class\n * @param {symbol} kInternalIterator\n * @param {string | number} [keyIndex]\n * @param {string | number} [valueIndex]\n */\nfunction iteratorMixin (name, object, kInternalIterator, keyIndex = 0, valueIndex = 1) {\n  const makeIterator = createIterator(name, kInternalIterator, keyIndex, valueIndex)\n\n  const properties = {\n    keys: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function keys () {\n        webidl.brandCheck(this, object)\n        return makeIterator(this, 'key')\n      }\n    },\n    values: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function values () {\n        webidl.brandCheck(this, object)\n        return makeIterator(this, 'value')\n      }\n    },\n    entries: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function entries () {\n        webidl.brandCheck(this, object)\n        return makeIterator(this, 'key+value')\n      }\n    },\n    forEach: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function forEach (callbackfn, thisArg = globalThis) {\n        webidl.brandCheck(this, object)\n        webidl.argumentLengthCheck(arguments, 1, `${name}.forEach`)\n        if (typeof callbackfn !== 'function') {\n          throw new TypeError(\n            `Failed to execute 'forEach' on '${name}': parameter 1 is not of type 'Function'.`\n          )\n        }\n        for (const { 0: key, 1: value } of makeIterator(this, 'key+value')) {\n          callbackfn.call(thisArg, value, key, this)\n        }\n      }\n    }\n  }\n\n  return Object.defineProperties(object.prototype, {\n    ...properties,\n    [Symbol.iterator]: {\n      writable: true,\n      enumerable: false,\n      configurable: true,\n      value: properties.entries.value\n    }\n  })\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#body-fully-read\n */\nasync function fullyReadBody (body, processBody, processBodyError) {\n  // 1. If taskDestination is null, then set taskDestination to\n  //    the result of starting a new parallel queue.\n\n  // 2. Let successSteps given a byte sequence bytes be to queue a\n  //    fetch task to run processBody given bytes, with taskDestination.\n  const successSteps = processBody\n\n  // 3. Let errorSteps be to queue a fetch task to run processBodyError,\n  //    with taskDestination.\n  const errorSteps = processBodyError\n\n  // 4. Let reader be the result of getting a reader for body’s stream.\n  //    If that threw an exception, then run errorSteps with that\n  //    exception and return.\n  let reader\n\n  try {\n    reader = body.stream.getReader()\n  } catch (e) {\n    errorSteps(e)\n    return\n  }\n\n  // 5. Read all bytes from reader, given successSteps and errorSteps.\n  try {\n    successSteps(await readAllBytes(reader))\n  } catch (e) {\n    errorSteps(e)\n  }\n}\n\nfunction isReadableStreamLike (stream) {\n  return stream instanceof ReadableStream || (\n    stream[Symbol.toStringTag] === 'ReadableStream' &&\n    typeof stream.tee === 'function'\n  )\n}\n\n/**\n * @param {ReadableStreamController<Uint8Array>} controller\n */\nfunction readableStreamClose (controller) {\n  try {\n    controller.close()\n    controller.byobRequest?.respond(0)\n  } catch (err) {\n    // TODO: add comment explaining why this error occurs.\n    if (!err.message.includes('Controller is already closed') && !err.message.includes('ReadableStream is already closed')) {\n      throw err\n    }\n  }\n}\n\nconst invalidIsomorphicEncodeValueRegex = /[^\\x00-\\xFF]/ // eslint-disable-line\n\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-encode\n * @param {string} input\n */\nfunction isomorphicEncode (input) {\n  // 1. Assert: input contains no code points greater than U+00FF.\n  assert(!invalidIsomorphicEncodeValueRegex.test(input))\n\n  // 2. Return a byte sequence whose length is equal to input’s code\n  //    point length and whose bytes have the same values as the\n  //    values of input’s code points, in the same order\n  return input\n}\n\n/**\n * @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes\n * @see https://streams.spec.whatwg.org/#read-loop\n * @param {ReadableStreamDefaultReader} reader\n */\nasync function readAllBytes (reader) {\n  const bytes = []\n  let byteLength = 0\n\n  while (true) {\n    const { done, value: chunk } = await reader.read()\n\n    if (done) {\n      // 1. Call successSteps with bytes.\n      return Buffer.concat(bytes, byteLength)\n    }\n\n    // 1. If chunk is not a Uint8Array object, call failureSteps\n    //    with a TypeError and abort these steps.\n    if (!isUint8Array(chunk)) {\n      throw new TypeError('Received non-Uint8Array chunk')\n    }\n\n    // 2. Append the bytes represented by chunk to bytes.\n    bytes.push(chunk)\n    byteLength += chunk.length\n\n    // 3. Read-loop given reader, bytes, successSteps, and failureSteps.\n  }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#is-local\n * @param {URL} url\n */\nfunction urlIsLocal (url) {\n  assert('protocol' in url) // ensure it's a url object\n\n  const protocol = url.protocol\n\n  return protocol === 'about:' || protocol === 'blob:' || protocol === 'data:'\n}\n\n/**\n * @param {string|URL} url\n * @returns {boolean}\n */\nfunction urlHasHttpsScheme (url) {\n  return (\n    (\n      typeof url === 'string' &&\n      url[5] === ':' &&\n      url[0] === 'h' &&\n      url[1] === 't' &&\n      url[2] === 't' &&\n      url[3] === 'p' &&\n      url[4] === 's'\n    ) ||\n    url.protocol === 'https:'\n  )\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-scheme\n * @param {URL} url\n */\nfunction urlIsHttpHttpsScheme (url) {\n  assert('protocol' in url) // ensure it's a url object\n\n  const protocol = url.protocol\n\n  return protocol === 'http:' || protocol === 'https:'\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#simple-range-header-value\n * @param {string} value\n * @param {boolean} allowWhitespace\n */\nfunction simpleRangeHeaderValue (value, allowWhitespace) {\n  // 1. Let data be the isomorphic decoding of value.\n  // Note: isomorphic decoding takes a sequence of bytes (ie. a Uint8Array) and turns it into a string,\n  // nothing more. We obviously don't need to do that if value is a string already.\n  const data = value\n\n  // 2. If data does not start with \"bytes\", then return failure.\n  if (!data.startsWith('bytes')) {\n    return 'failure'\n  }\n\n  // 3. Let position be a position variable for data, initially pointing at the 5th code point of data.\n  const position = { position: 5 }\n\n  // 4. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space,\n  //    from data given position.\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(\n      (char) => char === '\\t' || char === ' ',\n      data,\n      position\n    )\n  }\n\n  // 5. If the code point at position within data is not U+003D (=), then return failure.\n  if (data.charCodeAt(position.position) !== 0x3D) {\n    return 'failure'\n  }\n\n  // 6. Advance position by 1.\n  position.position++\n\n  // 7. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space, from\n  //    data given position.\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(\n      (char) => char === '\\t' || char === ' ',\n      data,\n      position\n    )\n  }\n\n  // 8. Let rangeStart be the result of collecting a sequence of code points that are ASCII digits,\n  //    from data given position.\n  const rangeStart = collectASequenceOfCodePoints(\n    (char) => {\n      const code = char.charCodeAt(0)\n\n      return code >= 0x30 && code <= 0x39\n    },\n    data,\n    position\n  )\n\n  // 9. Let rangeStartValue be rangeStart, interpreted as decimal number, if rangeStart is not the\n  //    empty string; otherwise null.\n  const rangeStartValue = rangeStart.length ? Number(rangeStart) : null\n\n  // 10. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space,\n  //     from data given position.\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(\n      (char) => char === '\\t' || char === ' ',\n      data,\n      position\n    )\n  }\n\n  // 11. If the code point at position within data is not U+002D (-), then return failure.\n  if (data.charCodeAt(position.position) !== 0x2D) {\n    return 'failure'\n  }\n\n  // 12. Advance position by 1.\n  position.position++\n\n  // 13. If allowWhitespace is true, collect a sequence of code points that are HTTP tab\n  //     or space, from data given position.\n  // Note from Khafra: its the same step as in #8 again lol\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(\n      (char) => char === '\\t' || char === ' ',\n      data,\n      position\n    )\n  }\n\n  // 14. Let rangeEnd be the result of collecting a sequence of code points that are\n  //     ASCII digits, from data given position.\n  // Note from Khafra: you wouldn't guess it, but this is also the same step as #8\n  const rangeEnd = collectASequenceOfCodePoints(\n    (char) => {\n      const code = char.charCodeAt(0)\n\n      return code >= 0x30 && code <= 0x39\n    },\n    data,\n    position\n  )\n\n  // 15. Let rangeEndValue be rangeEnd, interpreted as decimal number, if rangeEnd\n  //     is not the empty string; otherwise null.\n  // Note from Khafra: THE SAME STEP, AGAIN!!!\n  // Note: why interpret as a decimal if we only collect ascii digits?\n  const rangeEndValue = rangeEnd.length ? Number(rangeEnd) : null\n\n  // 16. If position is not past the end of data, then return failure.\n  if (position.position < data.length) {\n    return 'failure'\n  }\n\n  // 17. If rangeEndValue and rangeStartValue are null, then return failure.\n  if (rangeEndValue === null && rangeStartValue === null) {\n    return 'failure'\n  }\n\n  // 18. If rangeStartValue and rangeEndValue are numbers, and rangeStartValue is\n  //     greater than rangeEndValue, then return failure.\n  // Note: ... when can they not be numbers?\n  if (rangeStartValue > rangeEndValue) {\n    return 'failure'\n  }\n\n  // 19. Return (rangeStartValue, rangeEndValue).\n  return { rangeStartValue, rangeEndValue }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#build-a-content-range\n * @param {number} rangeStart\n * @param {number} rangeEnd\n * @param {number} fullLength\n */\nfunction buildContentRange (rangeStart, rangeEnd, fullLength) {\n  // 1. Let contentRange be `bytes `.\n  let contentRange = 'bytes '\n\n  // 2. Append rangeStart, serialized and isomorphic encoded, to contentRange.\n  contentRange += isomorphicEncode(`${rangeStart}`)\n\n  // 3. Append 0x2D (-) to contentRange.\n  contentRange += '-'\n\n  // 4. Append rangeEnd, serialized and isomorphic encoded to contentRange.\n  contentRange += isomorphicEncode(`${rangeEnd}`)\n\n  // 5. Append 0x2F (/) to contentRange.\n  contentRange += '/'\n\n  // 6. Append fullLength, serialized and isomorphic encoded to contentRange.\n  contentRange += isomorphicEncode(`${fullLength}`)\n\n  // 7. Return contentRange.\n  return contentRange\n}\n\n// A Stream, which pipes the response to zlib.createInflate() or\n// zlib.createInflateRaw() depending on the first byte of the Buffer.\n// If the lower byte of the first byte is 0x08, then the stream is\n// interpreted as a zlib stream, otherwise it's interpreted as a\n// raw deflate stream.\nclass InflateStream extends Transform {\n  _transform (chunk, encoding, callback) {\n    if (!this._inflateStream) {\n      if (chunk.length === 0) {\n        callback()\n        return\n      }\n      this._inflateStream = (chunk[0] & 0x0F) === 0x08\n        ? zlib.createInflate()\n        : zlib.createInflateRaw()\n\n      this._inflateStream.on('data', this.push.bind(this))\n      this._inflateStream.on('end', () => this.push(null))\n      this._inflateStream.on('error', (err) => this.destroy(err))\n    }\n\n    this._inflateStream.write(chunk, encoding, callback)\n  }\n\n  _final (callback) {\n    if (this._inflateStream) {\n      this._inflateStream.end()\n      this._inflateStream = null\n    }\n    callback()\n  }\n}\n\nfunction createInflate () {\n  return new InflateStream()\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-extract-mime-type\n * @param {import('./headers').HeadersList} headers\n */\nfunction extractMimeType (headers) {\n  // 1. Let charset be null.\n  let charset = null\n\n  // 2. Let essence be null.\n  let essence = null\n\n  // 3. Let mimeType be null.\n  let mimeType = null\n\n  // 4. Let values be the result of getting, decoding, and splitting `Content-Type` from headers.\n  const values = getDecodeSplit('content-type', headers)\n\n  // 5. If values is null, then return failure.\n  if (values === null) {\n    return 'failure'\n  }\n\n  // 6. For each value of values:\n  for (const value of values) {\n    // 6.1. Let temporaryMimeType be the result of parsing value.\n    const temporaryMimeType = parseMIMEType(value)\n\n    // 6.2. If temporaryMimeType is failure or its essence is \"*/*\", then continue.\n    if (temporaryMimeType === 'failure' || temporaryMimeType.essence === '*/*') {\n      continue\n    }\n\n    // 6.3. Set mimeType to temporaryMimeType.\n    mimeType = temporaryMimeType\n\n    // 6.4. If mimeType’s essence is not essence, then:\n    if (mimeType.essence !== essence) {\n      // 6.4.1. Set charset to null.\n      charset = null\n\n      // 6.4.2. If mimeType’s parameters[\"charset\"] exists, then set charset to\n      //        mimeType’s parameters[\"charset\"].\n      if (mimeType.parameters.has('charset')) {\n        charset = mimeType.parameters.get('charset')\n      }\n\n      // 6.4.3. Set essence to mimeType’s essence.\n      essence = mimeType.essence\n    } else if (!mimeType.parameters.has('charset') && charset !== null) {\n      // 6.5. Otherwise, if mimeType’s parameters[\"charset\"] does not exist, and\n      //      charset is non-null, set mimeType’s parameters[\"charset\"] to charset.\n      mimeType.parameters.set('charset', charset)\n    }\n  }\n\n  // 7. If mimeType is null, then return failure.\n  if (mimeType == null) {\n    return 'failure'\n  }\n\n  // 8. Return mimeType.\n  return mimeType\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-value-get-decode-and-split\n * @param {string|null} value\n */\nfunction gettingDecodingSplitting (value) {\n  // 1. Let input be the result of isomorphic decoding value.\n  const input = value\n\n  // 2. Let position be a position variable for input, initially pointing at the start of input.\n  const position = { position: 0 }\n\n  // 3. Let values be a list of strings, initially empty.\n  const values = []\n\n  // 4. Let temporaryValue be the empty string.\n  let temporaryValue = ''\n\n  // 5. While position is not past the end of input:\n  while (position.position < input.length) {\n    // 5.1. Append the result of collecting a sequence of code points that are not U+0022 (\")\n    //      or U+002C (,) from input, given position, to temporaryValue.\n    temporaryValue += collectASequenceOfCodePoints(\n      (char) => char !== '\"' && char !== ',',\n      input,\n      position\n    )\n\n    // 5.2. If position is not past the end of input, then:\n    if (position.position < input.length) {\n      // 5.2.1. If the code point at position within input is U+0022 (\"), then:\n      if (input.charCodeAt(position.position) === 0x22) {\n        // 5.2.1.1. Append the result of collecting an HTTP quoted string from input, given position, to temporaryValue.\n        temporaryValue += collectAnHTTPQuotedString(\n          input,\n          position\n        )\n\n        // 5.2.1.2. If position is not past the end of input, then continue.\n        if (position.position < input.length) {\n          continue\n        }\n      } else {\n        // 5.2.2. Otherwise:\n\n        // 5.2.2.1. Assert: the code point at position within input is U+002C (,).\n        assert(input.charCodeAt(position.position) === 0x2C)\n\n        // 5.2.2.2. Advance position by 1.\n        position.position++\n      }\n    }\n\n    // 5.3. Remove all HTTP tab or space from the start and end of temporaryValue.\n    temporaryValue = removeChars(temporaryValue, true, true, (char) => char === 0x9 || char === 0x20)\n\n    // 5.4. Append temporaryValue to values.\n    values.push(temporaryValue)\n\n    // 5.6. Set temporaryValue to the empty string.\n    temporaryValue = ''\n  }\n\n  // 6. Return values.\n  return values\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-list-get-decode-split\n * @param {string} name lowercase header name\n * @param {import('./headers').HeadersList} list\n */\nfunction getDecodeSplit (name, list) {\n  // 1. Let value be the result of getting name from list.\n  const value = list.get(name, true)\n\n  // 2. If value is null, then return null.\n  if (value === null) {\n    return null\n  }\n\n  // 3. Return the result of getting, decoding, and splitting value.\n  return gettingDecodingSplitting(value)\n}\n\nconst textDecoder = new TextDecoder()\n\n/**\n * @see https://encoding.spec.whatwg.org/#utf-8-decode\n * @param {Buffer} buffer\n */\nfunction utf8DecodeBytes (buffer) {\n  if (buffer.length === 0) {\n    return ''\n  }\n\n  // 1. Let buffer be the result of peeking three bytes from\n  //    ioQueue, converted to a byte sequence.\n\n  // 2. If buffer is 0xEF 0xBB 0xBF, then read three\n  //    bytes from ioQueue. (Do nothing with those bytes.)\n  if (buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {\n    buffer = buffer.subarray(3)\n  }\n\n  // 3. Process a queue with an instance of UTF-8’s\n  //    decoder, ioQueue, output, and \"replacement\".\n  const output = textDecoder.decode(buffer)\n\n  // 4. Return output.\n  return output\n}\n\nclass EnvironmentSettingsObjectBase {\n  get baseUrl () {\n    return getGlobalOrigin()\n  }\n\n  get origin () {\n    return this.baseUrl?.origin\n  }\n\n  policyContainer = makePolicyContainer()\n}\n\nclass EnvironmentSettingsObject {\n  settingsObject = new EnvironmentSettingsObjectBase()\n}\n\nconst environmentSettingsObject = new EnvironmentSettingsObject()\n\nmodule.exports = {\n  isAborted,\n  isCancelled,\n  isValidEncodedURL,\n  createDeferredPromise,\n  ReadableStreamFrom,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  clampAndCoarsenConnectionTimingInfo,\n  coarsenedSharedCurrentTime,\n  determineRequestsReferrer,\n  makePolicyContainer,\n  clonePolicyContainer,\n  appendFetchMetadata,\n  appendRequestOriginHeader,\n  TAOCheck,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  createOpaqueTimingInfo,\n  setRequestReferrerPolicyOnRedirect,\n  isValidHTTPToken,\n  requestBadPort,\n  requestCurrentURL,\n  responseURL,\n  responseLocationURL,\n  isBlobLike,\n  isURLPotentiallyTrustworthy,\n  isValidReasonPhrase,\n  sameOrigin,\n  normalizeMethod,\n  serializeJavascriptValueToJSONString,\n  iteratorMixin,\n  createIterator,\n  isValidHeaderName,\n  isValidHeaderValue,\n  isErrorLike,\n  fullyReadBody,\n  bytesMatch,\n  isReadableStreamLike,\n  readableStreamClose,\n  isomorphicEncode,\n  urlIsLocal,\n  urlHasHttpsScheme,\n  urlIsHttpHttpsScheme,\n  readAllBytes,\n  simpleRangeHeaderValue,\n  buildContentRange,\n  parseMetadata,\n  createInflate,\n  extractMimeType,\n  getDecodeSplit,\n  utf8DecodeBytes,\n  environmentSettingsObject\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"'use strict';\n\nconst {\n  Writable\n} = require('node:stream');\nconst assert = require('node:assert');\nconst {\n  parserStates,\n  opcodes,\n  states,\n  emptyBuffer,\n  sentCloseFrameState\n} = require('./constants');\nconst {\n  kReadyState,\n  kSentClose,\n  kResponse,\n  kReceivedClose\n} = require('./symbols');\nconst {\n  channels\n} = require('../../core/diagnostics');\nconst {\n  isValidStatusCode,\n  isValidOpcode,\n  failWebsocketConnection,\n  websocketMessageReceived,\n  utf8Decode,\n  isControlFrame,\n  isTextBinaryFrame,\n  isContinuationFrame\n} = require('./util');\nconst {\n  WebsocketFrameSend\n} = require('./frame');\nconst {\n  closeWebSocketConnection\n} = require('./connection');\nconst {\n  PerMessageDeflate\n} = require('./permessage-deflate');\n\n// This code was influenced by ws released under the MIT license.\n// Copyright (c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n// Copyright (c) 2013 Arnout Kazemier and contributors\n// Copyright (c) 2016 Luigi Pinca and contributors\n\nclass ByteParser extends Writable {\n  #buffers = [];\n  #byteOffset = 0;\n  #loop = false;\n  #state = parserStates.INFO;\n  #info = {};\n  #fragments = [];\n\n  /** @type {Map<string, PerMessageDeflate>} */\n  #extensions;\n  constructor(ws, extensions) {\n    super();\n    this.ws = ws;\n    this.#extensions = extensions == null ? new Map() : extensions;\n    if (this.#extensions.has('permessage-deflate')) {\n      this.#extensions.set('permessage-deflate', new PerMessageDeflate(extensions));\n    }\n  }\n\n  /**\n   * @param {Buffer} chunk\n   * @param {() => void} callback\n   */\n  _write(chunk, _, callback) {\n    this.#buffers.push(chunk);\n    this.#byteOffset += chunk.length;\n    this.#loop = true;\n    this.run(callback);\n  }\n\n  /**\n   * Runs whenever a new chunk is received.\n   * Callback is called whenever there are no more chunks buffering,\n   * or not enough bytes are buffered to parse.\n   */\n  run(callback) {\n    while (this.#loop) {\n      if (this.#state === parserStates.INFO) {\n        // If there aren't enough bytes to parse the payload length, etc.\n        if (this.#byteOffset < 2) {\n          return callback();\n        }\n        const buffer = this.consume(2);\n        const fin = (buffer[0] & 0x80) !== 0;\n        const opcode = buffer[0] & 0x0F;\n        const masked = (buffer[1] & 0x80) === 0x80;\n        const fragmented = !fin && opcode !== opcodes.CONTINUATION;\n        const payloadLength = buffer[1] & 0x7F;\n        const rsv1 = buffer[0] & 0x40;\n        const rsv2 = buffer[0] & 0x20;\n        const rsv3 = buffer[0] & 0x10;\n        if (!isValidOpcode(opcode)) {\n          failWebsocketConnection(this.ws, 'Invalid opcode received');\n          return callback();\n        }\n        if (masked) {\n          failWebsocketConnection(this.ws, 'Frame cannot be masked');\n          return callback();\n        }\n\n        // MUST be 0 unless an extension is negotiated that defines meanings\n        // for non-zero values.  If a nonzero value is received and none of\n        // the negotiated extensions defines the meaning of such a nonzero\n        // value, the receiving endpoint MUST _Fail the WebSocket\n        // Connection_.\n        // This document allocates the RSV1 bit of the WebSocket header for\n        // PMCEs and calls the bit the \"Per-Message Compressed\" bit.  On a\n        // WebSocket connection where a PMCE is in use, this bit indicates\n        // whether a message is compressed or not.\n        if (rsv1 !== 0 && !this.#extensions.has('permessage-deflate')) {\n          failWebsocketConnection(this.ws, 'Expected RSV1 to be clear.');\n          return;\n        }\n        if (rsv2 !== 0 || rsv3 !== 0) {\n          failWebsocketConnection(this.ws, 'RSV1, RSV2, RSV3 must be clear');\n          return;\n        }\n        if (fragmented && !isTextBinaryFrame(opcode)) {\n          // Only text and binary frames can be fragmented\n          failWebsocketConnection(this.ws, 'Invalid frame type was fragmented.');\n          return;\n        }\n\n        // If we are already parsing a text/binary frame and do not receive either\n        // a continuation frame or close frame, fail the connection.\n        if (isTextBinaryFrame(opcode) && this.#fragments.length > 0) {\n          failWebsocketConnection(this.ws, 'Expected continuation frame');\n          return;\n        }\n        if (this.#info.fragmented && fragmented) {\n          // A fragmented frame can't be fragmented itself\n          failWebsocketConnection(this.ws, 'Fragmented frame exceeded 125 bytes.');\n          return;\n        }\n\n        // \"All control frames MUST have a payload length of 125 bytes or less\n        // and MUST NOT be fragmented.\"\n        if ((payloadLength > 125 || fragmented) && isControlFrame(opcode)) {\n          failWebsocketConnection(this.ws, 'Control frame either too large or fragmented');\n          return;\n        }\n        if (isContinuationFrame(opcode) && this.#fragments.length === 0 && !this.#info.compressed) {\n          failWebsocketConnection(this.ws, 'Unexpected continuation frame');\n          return;\n        }\n        if (payloadLength <= 125) {\n          this.#info.payloadLength = payloadLength;\n          this.#state = parserStates.READ_DATA;\n        } else if (payloadLength === 126) {\n          this.#state = parserStates.PAYLOADLENGTH_16;\n        } else if (payloadLength === 127) {\n          this.#state = parserStates.PAYLOADLENGTH_64;\n        }\n        if (isTextBinaryFrame(opcode)) {\n          this.#info.binaryType = opcode;\n          this.#info.compressed = rsv1 !== 0;\n        }\n        this.#info.opcode = opcode;\n        this.#info.masked = masked;\n        this.#info.fin = fin;\n        this.#info.fragmented = fragmented;\n      } else if (this.#state === parserStates.PAYLOADLENGTH_16) {\n        if (this.#byteOffset < 2) {\n          return callback();\n        }\n        const buffer = this.consume(2);\n        this.#info.payloadLength = buffer.readUInt16BE(0);\n        this.#state = parserStates.READ_DATA;\n      } else if (this.#state === parserStates.PAYLOADLENGTH_64) {\n        if (this.#byteOffset < 8) {\n          return callback();\n        }\n        const buffer = this.consume(8);\n        const upper = buffer.readUInt32BE(0);\n\n        // 2^31 is the maximum bytes an arraybuffer can contain\n        // on 32-bit systems. Although, on 64-bit systems, this is\n        // 2^53-1 bytes.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_array_length\n        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/common/globals.h;drc=1946212ac0100668f14eb9e2843bdd846e510a1e;bpv=1;bpt=1;l=1275\n        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/js-array-buffer.h;l=34;drc=1946212ac0100668f14eb9e2843bdd846e510a1e\n        if (upper > 2 ** 31 - 1) {\n          failWebsocketConnection(this.ws, 'Received payload length > 2^31 bytes.');\n          return;\n        }\n        const lower = buffer.readUInt32BE(4);\n        this.#info.payloadLength = (upper << 8) + lower;\n        this.#state = parserStates.READ_DATA;\n      } else if (this.#state === parserStates.READ_DATA) {\n        if (this.#byteOffset < this.#info.payloadLength) {\n          return callback();\n        }\n        const body = this.consume(this.#info.payloadLength);\n        if (isControlFrame(this.#info.opcode)) {\n          this.#loop = this.parseControlFrame(body);\n          this.#state = parserStates.INFO;\n        } else {\n          if (!this.#info.compressed) {\n            this.#fragments.push(body);\n\n            // If the frame is not fragmented, a message has been received.\n            // If the frame is fragmented, it will terminate with a fin bit set\n            // and an opcode of 0 (continuation), therefore we handle that when\n            // parsing continuation frames, not here.\n            if (!this.#info.fragmented && this.#info.fin) {\n              const fullMessage = Buffer.concat(this.#fragments);\n              websocketMessageReceived(this.ws, this.#info.binaryType, fullMessage);\n              this.#fragments.length = 0;\n            }\n            this.#state = parserStates.INFO;\n          } else {\n            this.#extensions.get('permessage-deflate').decompress(body, this.#info.fin, (error, data) => {\n              if (error) {\n                closeWebSocketConnection(this.ws, 1007, error.message, error.message.length);\n                return;\n              }\n              this.#fragments.push(data);\n              if (!this.#info.fin) {\n                this.#state = parserStates.INFO;\n                this.#loop = true;\n                this.run(callback);\n                return;\n              }\n              websocketMessageReceived(this.ws, this.#info.binaryType, Buffer.concat(this.#fragments));\n              this.#loop = true;\n              this.#state = parserStates.INFO;\n              this.#fragments.length = 0;\n              this.run(callback);\n            });\n            this.#loop = false;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Take n bytes from the buffered Buffers\n   * @param {number} n\n   * @returns {Buffer}\n   */\n  consume(n) {\n    if (n > this.#byteOffset) {\n      throw new Error('Called consume() before buffers satiated.');\n    } else if (n === 0) {\n      return emptyBuffer;\n    }\n    if (this.#buffers[0].length === n) {\n      this.#byteOffset -= this.#buffers[0].length;\n      return this.#buffers.shift();\n    }\n    const buffer = Buffer.allocUnsafe(n);\n    let offset = 0;\n    while (offset !== n) {\n      const next = this.#buffers[0];\n      const {\n        length\n      } = next;\n      if (length + offset === n) {\n        buffer.set(this.#buffers.shift(), offset);\n        break;\n      } else if (length + offset > n) {\n        buffer.set(next.subarray(0, n - offset), offset);\n        this.#buffers[0] = next.subarray(n - offset);\n        break;\n      } else {\n        buffer.set(this.#buffers.shift(), offset);\n        offset += next.length;\n      }\n    }\n    this.#byteOffset -= n;\n    return buffer;\n  }\n  parseCloseBody(data) {\n    assert(data.length !== 1);\n\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.5\n    /** @type {number|undefined} */\n    let code;\n    if (data.length >= 2) {\n      // _The WebSocket Connection Close Code_ is\n      // defined as the status code (Section 7.4) contained in the first Close\n      // control frame received by the application\n      code = data.readUInt16BE(0);\n    }\n    if (code !== undefined && !isValidStatusCode(code)) {\n      return {\n        code: 1002,\n        reason: 'Invalid status code',\n        error: true\n      };\n    }\n\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.6\n    /** @type {Buffer} */\n    let reason = data.subarray(2);\n\n    // Remove BOM\n    if (reason[0] === 0xEF && reason[1] === 0xBB && reason[2] === 0xBF) {\n      reason = reason.subarray(3);\n    }\n    try {\n      reason = utf8Decode(reason);\n    } catch {\n      return {\n        code: 1007,\n        reason: 'Invalid UTF-8',\n        error: true\n      };\n    }\n    return {\n      code,\n      reason,\n      error: false\n    };\n  }\n\n  /**\n   * Parses control frames.\n   * @param {Buffer} body\n   */\n  parseControlFrame(body) {\n    const {\n      opcode,\n      payloadLength\n    } = this.#info;\n    if (opcode === opcodes.CLOSE) {\n      if (payloadLength === 1) {\n        failWebsocketConnection(this.ws, 'Received close frame with a 1-byte body.');\n        return false;\n      }\n      this.#info.closeInfo = this.parseCloseBody(body);\n      if (this.#info.closeInfo.error) {\n        const {\n          code,\n          reason\n        } = this.#info.closeInfo;\n        closeWebSocketConnection(this.ws, code, reason, reason.length);\n        failWebsocketConnection(this.ws, reason);\n        return false;\n      }\n      if (this.ws[kSentClose] !== sentCloseFrameState.SENT) {\n        // If an endpoint receives a Close frame and did not previously send a\n        // Close frame, the endpoint MUST send a Close frame in response.  (When\n        // sending a Close frame in response, the endpoint typically echos the\n        // status code it received.)\n        let body = emptyBuffer;\n        if (this.#info.closeInfo.code) {\n          body = Buffer.allocUnsafe(2);\n          body.writeUInt16BE(this.#info.closeInfo.code, 0);\n        }\n        const closeFrame = new WebsocketFrameSend(body);\n        this.ws[kResponse].socket.write(closeFrame.createFrame(opcodes.CLOSE), err => {\n          if (!err) {\n            this.ws[kSentClose] = sentCloseFrameState.SENT;\n          }\n        });\n      }\n\n      // Upon either sending or receiving a Close control frame, it is said\n      // that _The WebSocket Closing Handshake is Started_ and that the\n      // WebSocket connection is in the CLOSING state.\n      this.ws[kReadyState] = states.CLOSING;\n      this.ws[kReceivedClose] = true;\n      return false;\n    } else if (opcode === opcodes.PING) {\n      // Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in\n      // response, unless it already received a Close frame.\n      // A Pong frame sent in response to a Ping frame must have identical\n      // \"Application data\"\n\n      if (!this.ws[kReceivedClose]) {\n        const frame = new WebsocketFrameSend(body);\n        this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));\n        if (channels.ping.hasSubscribers) {\n          channels.ping.publish({\n            payload: body\n          });\n        }\n      }\n    } else if (opcode === opcodes.PONG) {\n      // A Pong frame MAY be sent unsolicited.  This serves as a\n      // unidirectional heartbeat.  A response to an unsolicited Pong frame is\n      // not expected.\n\n      if (channels.pong.hasSubscribers) {\n        channels.pong.publish({\n          payload: body\n        });\n      }\n    }\n    return true;\n  }\n  get closingInfo() {\n    return this.#info.closeInfo;\n  }\n}\nmodule.exports = {\n  ByteParser\n};","map":{"version":3,"names":["Writable","require","assert","parserStates","opcodes","states","emptyBuffer","sentCloseFrameState","kReadyState","kSentClose","kResponse","kReceivedClose","channels","isValidStatusCode","isValidOpcode","failWebsocketConnection","websocketMessageReceived","utf8Decode","isControlFrame","isTextBinaryFrame","isContinuationFrame","WebsocketFrameSend","closeWebSocketConnection","PerMessageDeflate","ByteParser","buffers","byteOffset","loop","state","INFO","info","fragments","extensions","constructor","ws","Map","has","set","_write","chunk","_","callback","push","length","run","buffer","consume","fin","opcode","masked","fragmented","CONTINUATION","payloadLength","rsv1","rsv2","rsv3","compressed","READ_DATA","PAYLOADLENGTH_16","PAYLOADLENGTH_64","binaryType","readUInt16BE","upper","readUInt32BE","lower","body","parseControlFrame","fullMessage","Buffer","concat","get","decompress","error","data","message","n","Error","shift","allocUnsafe","offset","next","subarray","parseCloseBody","code","undefined","reason","CLOSE","closeInfo","SENT","writeUInt16BE","closeFrame","socket","write","createFrame","err","CLOSING","PING","frame","PONG","ping","hasSubscribers","publish","payload","pong","closingInfo","module","exports"],"sources":["/Users/nataliia/PussyProjects/react-app/node_modules/undici/lib/web/websocket/receiver.js"],"sourcesContent":["'use strict'\n\nconst { Writable } = require('node:stream')\nconst assert = require('node:assert')\nconst { parserStates, opcodes, states, emptyBuffer, sentCloseFrameState } = require('./constants')\nconst { kReadyState, kSentClose, kResponse, kReceivedClose } = require('./symbols')\nconst { channels } = require('../../core/diagnostics')\nconst {\n  isValidStatusCode,\n  isValidOpcode,\n  failWebsocketConnection,\n  websocketMessageReceived,\n  utf8Decode,\n  isControlFrame,\n  isTextBinaryFrame,\n  isContinuationFrame\n} = require('./util')\nconst { WebsocketFrameSend } = require('./frame')\nconst { closeWebSocketConnection } = require('./connection')\nconst { PerMessageDeflate } = require('./permessage-deflate')\n\n// This code was influenced by ws released under the MIT license.\n// Copyright (c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n// Copyright (c) 2013 Arnout Kazemier and contributors\n// Copyright (c) 2016 Luigi Pinca and contributors\n\nclass ByteParser extends Writable {\n  #buffers = []\n  #byteOffset = 0\n  #loop = false\n\n  #state = parserStates.INFO\n\n  #info = {}\n  #fragments = []\n\n  /** @type {Map<string, PerMessageDeflate>} */\n  #extensions\n\n  constructor (ws, extensions) {\n    super()\n\n    this.ws = ws\n    this.#extensions = extensions == null ? new Map() : extensions\n\n    if (this.#extensions.has('permessage-deflate')) {\n      this.#extensions.set('permessage-deflate', new PerMessageDeflate(extensions))\n    }\n  }\n\n  /**\n   * @param {Buffer} chunk\n   * @param {() => void} callback\n   */\n  _write (chunk, _, callback) {\n    this.#buffers.push(chunk)\n    this.#byteOffset += chunk.length\n    this.#loop = true\n\n    this.run(callback)\n  }\n\n  /**\n   * Runs whenever a new chunk is received.\n   * Callback is called whenever there are no more chunks buffering,\n   * or not enough bytes are buffered to parse.\n   */\n  run (callback) {\n    while (this.#loop) {\n      if (this.#state === parserStates.INFO) {\n        // If there aren't enough bytes to parse the payload length, etc.\n        if (this.#byteOffset < 2) {\n          return callback()\n        }\n\n        const buffer = this.consume(2)\n        const fin = (buffer[0] & 0x80) !== 0\n        const opcode = buffer[0] & 0x0F\n        const masked = (buffer[1] & 0x80) === 0x80\n\n        const fragmented = !fin && opcode !== opcodes.CONTINUATION\n        const payloadLength = buffer[1] & 0x7F\n\n        const rsv1 = buffer[0] & 0x40\n        const rsv2 = buffer[0] & 0x20\n        const rsv3 = buffer[0] & 0x10\n\n        if (!isValidOpcode(opcode)) {\n          failWebsocketConnection(this.ws, 'Invalid opcode received')\n          return callback()\n        }\n\n        if (masked) {\n          failWebsocketConnection(this.ws, 'Frame cannot be masked')\n          return callback()\n        }\n\n        // MUST be 0 unless an extension is negotiated that defines meanings\n        // for non-zero values.  If a nonzero value is received and none of\n        // the negotiated extensions defines the meaning of such a nonzero\n        // value, the receiving endpoint MUST _Fail the WebSocket\n        // Connection_.\n        // This document allocates the RSV1 bit of the WebSocket header for\n        // PMCEs and calls the bit the \"Per-Message Compressed\" bit.  On a\n        // WebSocket connection where a PMCE is in use, this bit indicates\n        // whether a message is compressed or not.\n        if (rsv1 !== 0 && !this.#extensions.has('permessage-deflate')) {\n          failWebsocketConnection(this.ws, 'Expected RSV1 to be clear.')\n          return\n        }\n\n        if (rsv2 !== 0 || rsv3 !== 0) {\n          failWebsocketConnection(this.ws, 'RSV1, RSV2, RSV3 must be clear')\n          return\n        }\n\n        if (fragmented && !isTextBinaryFrame(opcode)) {\n          // Only text and binary frames can be fragmented\n          failWebsocketConnection(this.ws, 'Invalid frame type was fragmented.')\n          return\n        }\n\n        // If we are already parsing a text/binary frame and do not receive either\n        // a continuation frame or close frame, fail the connection.\n        if (isTextBinaryFrame(opcode) && this.#fragments.length > 0) {\n          failWebsocketConnection(this.ws, 'Expected continuation frame')\n          return\n        }\n\n        if (this.#info.fragmented && fragmented) {\n          // A fragmented frame can't be fragmented itself\n          failWebsocketConnection(this.ws, 'Fragmented frame exceeded 125 bytes.')\n          return\n        }\n\n        // \"All control frames MUST have a payload length of 125 bytes or less\n        // and MUST NOT be fragmented.\"\n        if ((payloadLength > 125 || fragmented) && isControlFrame(opcode)) {\n          failWebsocketConnection(this.ws, 'Control frame either too large or fragmented')\n          return\n        }\n\n        if (isContinuationFrame(opcode) && this.#fragments.length === 0 && !this.#info.compressed) {\n          failWebsocketConnection(this.ws, 'Unexpected continuation frame')\n          return\n        }\n\n        if (payloadLength <= 125) {\n          this.#info.payloadLength = payloadLength\n          this.#state = parserStates.READ_DATA\n        } else if (payloadLength === 126) {\n          this.#state = parserStates.PAYLOADLENGTH_16\n        } else if (payloadLength === 127) {\n          this.#state = parserStates.PAYLOADLENGTH_64\n        }\n\n        if (isTextBinaryFrame(opcode)) {\n          this.#info.binaryType = opcode\n          this.#info.compressed = rsv1 !== 0\n        }\n\n        this.#info.opcode = opcode\n        this.#info.masked = masked\n        this.#info.fin = fin\n        this.#info.fragmented = fragmented\n      } else if (this.#state === parserStates.PAYLOADLENGTH_16) {\n        if (this.#byteOffset < 2) {\n          return callback()\n        }\n\n        const buffer = this.consume(2)\n\n        this.#info.payloadLength = buffer.readUInt16BE(0)\n        this.#state = parserStates.READ_DATA\n      } else if (this.#state === parserStates.PAYLOADLENGTH_64) {\n        if (this.#byteOffset < 8) {\n          return callback()\n        }\n\n        const buffer = this.consume(8)\n        const upper = buffer.readUInt32BE(0)\n\n        // 2^31 is the maximum bytes an arraybuffer can contain\n        // on 32-bit systems. Although, on 64-bit systems, this is\n        // 2^53-1 bytes.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_array_length\n        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/common/globals.h;drc=1946212ac0100668f14eb9e2843bdd846e510a1e;bpv=1;bpt=1;l=1275\n        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/js-array-buffer.h;l=34;drc=1946212ac0100668f14eb9e2843bdd846e510a1e\n        if (upper > 2 ** 31 - 1) {\n          failWebsocketConnection(this.ws, 'Received payload length > 2^31 bytes.')\n          return\n        }\n\n        const lower = buffer.readUInt32BE(4)\n\n        this.#info.payloadLength = (upper << 8) + lower\n        this.#state = parserStates.READ_DATA\n      } else if (this.#state === parserStates.READ_DATA) {\n        if (this.#byteOffset < this.#info.payloadLength) {\n          return callback()\n        }\n\n        const body = this.consume(this.#info.payloadLength)\n\n        if (isControlFrame(this.#info.opcode)) {\n          this.#loop = this.parseControlFrame(body)\n          this.#state = parserStates.INFO\n        } else {\n          if (!this.#info.compressed) {\n            this.#fragments.push(body)\n\n            // If the frame is not fragmented, a message has been received.\n            // If the frame is fragmented, it will terminate with a fin bit set\n            // and an opcode of 0 (continuation), therefore we handle that when\n            // parsing continuation frames, not here.\n            if (!this.#info.fragmented && this.#info.fin) {\n              const fullMessage = Buffer.concat(this.#fragments)\n              websocketMessageReceived(this.ws, this.#info.binaryType, fullMessage)\n              this.#fragments.length = 0\n            }\n\n            this.#state = parserStates.INFO\n          } else {\n            this.#extensions.get('permessage-deflate').decompress(body, this.#info.fin, (error, data) => {\n              if (error) {\n                closeWebSocketConnection(this.ws, 1007, error.message, error.message.length)\n                return\n              }\n\n              this.#fragments.push(data)\n\n              if (!this.#info.fin) {\n                this.#state = parserStates.INFO\n                this.#loop = true\n                this.run(callback)\n                return\n              }\n\n              websocketMessageReceived(this.ws, this.#info.binaryType, Buffer.concat(this.#fragments))\n\n              this.#loop = true\n              this.#state = parserStates.INFO\n              this.#fragments.length = 0\n              this.run(callback)\n            })\n\n            this.#loop = false\n            break\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Take n bytes from the buffered Buffers\n   * @param {number} n\n   * @returns {Buffer}\n   */\n  consume (n) {\n    if (n > this.#byteOffset) {\n      throw new Error('Called consume() before buffers satiated.')\n    } else if (n === 0) {\n      return emptyBuffer\n    }\n\n    if (this.#buffers[0].length === n) {\n      this.#byteOffset -= this.#buffers[0].length\n      return this.#buffers.shift()\n    }\n\n    const buffer = Buffer.allocUnsafe(n)\n    let offset = 0\n\n    while (offset !== n) {\n      const next = this.#buffers[0]\n      const { length } = next\n\n      if (length + offset === n) {\n        buffer.set(this.#buffers.shift(), offset)\n        break\n      } else if (length + offset > n) {\n        buffer.set(next.subarray(0, n - offset), offset)\n        this.#buffers[0] = next.subarray(n - offset)\n        break\n      } else {\n        buffer.set(this.#buffers.shift(), offset)\n        offset += next.length\n      }\n    }\n\n    this.#byteOffset -= n\n\n    return buffer\n  }\n\n  parseCloseBody (data) {\n    assert(data.length !== 1)\n\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.5\n    /** @type {number|undefined} */\n    let code\n\n    if (data.length >= 2) {\n      // _The WebSocket Connection Close Code_ is\n      // defined as the status code (Section 7.4) contained in the first Close\n      // control frame received by the application\n      code = data.readUInt16BE(0)\n    }\n\n    if (code !== undefined && !isValidStatusCode(code)) {\n      return { code: 1002, reason: 'Invalid status code', error: true }\n    }\n\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.6\n    /** @type {Buffer} */\n    let reason = data.subarray(2)\n\n    // Remove BOM\n    if (reason[0] === 0xEF && reason[1] === 0xBB && reason[2] === 0xBF) {\n      reason = reason.subarray(3)\n    }\n\n    try {\n      reason = utf8Decode(reason)\n    } catch {\n      return { code: 1007, reason: 'Invalid UTF-8', error: true }\n    }\n\n    return { code, reason, error: false }\n  }\n\n  /**\n   * Parses control frames.\n   * @param {Buffer} body\n   */\n  parseControlFrame (body) {\n    const { opcode, payloadLength } = this.#info\n\n    if (opcode === opcodes.CLOSE) {\n      if (payloadLength === 1) {\n        failWebsocketConnection(this.ws, 'Received close frame with a 1-byte body.')\n        return false\n      }\n\n      this.#info.closeInfo = this.parseCloseBody(body)\n\n      if (this.#info.closeInfo.error) {\n        const { code, reason } = this.#info.closeInfo\n\n        closeWebSocketConnection(this.ws, code, reason, reason.length)\n        failWebsocketConnection(this.ws, reason)\n        return false\n      }\n\n      if (this.ws[kSentClose] !== sentCloseFrameState.SENT) {\n        // If an endpoint receives a Close frame and did not previously send a\n        // Close frame, the endpoint MUST send a Close frame in response.  (When\n        // sending a Close frame in response, the endpoint typically echos the\n        // status code it received.)\n        let body = emptyBuffer\n        if (this.#info.closeInfo.code) {\n          body = Buffer.allocUnsafe(2)\n          body.writeUInt16BE(this.#info.closeInfo.code, 0)\n        }\n        const closeFrame = new WebsocketFrameSend(body)\n\n        this.ws[kResponse].socket.write(\n          closeFrame.createFrame(opcodes.CLOSE),\n          (err) => {\n            if (!err) {\n              this.ws[kSentClose] = sentCloseFrameState.SENT\n            }\n          }\n        )\n      }\n\n      // Upon either sending or receiving a Close control frame, it is said\n      // that _The WebSocket Closing Handshake is Started_ and that the\n      // WebSocket connection is in the CLOSING state.\n      this.ws[kReadyState] = states.CLOSING\n      this.ws[kReceivedClose] = true\n\n      return false\n    } else if (opcode === opcodes.PING) {\n      // Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in\n      // response, unless it already received a Close frame.\n      // A Pong frame sent in response to a Ping frame must have identical\n      // \"Application data\"\n\n      if (!this.ws[kReceivedClose]) {\n        const frame = new WebsocketFrameSend(body)\n\n        this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG))\n\n        if (channels.ping.hasSubscribers) {\n          channels.ping.publish({\n            payload: body\n          })\n        }\n      }\n    } else if (opcode === opcodes.PONG) {\n      // A Pong frame MAY be sent unsolicited.  This serves as a\n      // unidirectional heartbeat.  A response to an unsolicited Pong frame is\n      // not expected.\n\n      if (channels.pong.hasSubscribers) {\n        channels.pong.publish({\n          payload: body\n        })\n      }\n    }\n\n    return true\n  }\n\n  get closingInfo () {\n    return this.#info.closeInfo\n  }\n}\n\nmodule.exports = {\n  ByteParser\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
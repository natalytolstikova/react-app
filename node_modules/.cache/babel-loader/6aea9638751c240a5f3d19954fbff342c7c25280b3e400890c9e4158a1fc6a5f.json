{"ast":null,"code":"const assert = require('node:assert');\nconst {\n  ResponseStatusCodeError\n} = require('../core/errors');\nconst {\n  chunksDecode\n} = require('./readable');\nconst CHUNK_LIMIT = 128 * 1024;\nasync function getResolveErrorBodyCallback({\n  callback,\n  body,\n  contentType,\n  statusCode,\n  statusMessage,\n  headers\n}) {\n  assert(body);\n  let chunks = [];\n  let length = 0;\n  try {\n    for await (const chunk of body) {\n      chunks.push(chunk);\n      length += chunk.length;\n      if (length > CHUNK_LIMIT) {\n        chunks = [];\n        length = 0;\n        break;\n      }\n    }\n  } catch {\n    chunks = [];\n    length = 0;\n    // Do nothing....\n  }\n  const message = `Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`;\n  if (statusCode === 204 || !contentType || !length) {\n    queueMicrotask(() => callback(new ResponseStatusCodeError(message, statusCode, headers)));\n    return;\n  }\n  const stackTraceLimit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 0;\n  let payload;\n  try {\n    if (isContentTypeApplicationJson(contentType)) {\n      payload = JSON.parse(chunksDecode(chunks, length));\n    } else if (isContentTypeText(contentType)) {\n      payload = chunksDecode(chunks, length);\n    }\n  } catch {\n    // process in a callback to avoid throwing in the microtask queue\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit;\n  }\n  queueMicrotask(() => callback(new ResponseStatusCodeError(message, statusCode, headers, payload)));\n}\nconst isContentTypeApplicationJson = contentType => {\n  return contentType.length > 15 && contentType[11] === '/' && contentType[0] === 'a' && contentType[1] === 'p' && contentType[2] === 'p' && contentType[3] === 'l' && contentType[4] === 'i' && contentType[5] === 'c' && contentType[6] === 'a' && contentType[7] === 't' && contentType[8] === 'i' && contentType[9] === 'o' && contentType[10] === 'n' && contentType[12] === 'j' && contentType[13] === 's' && contentType[14] === 'o' && contentType[15] === 'n';\n};\nconst isContentTypeText = contentType => {\n  return contentType.length > 4 && contentType[4] === '/' && contentType[0] === 't' && contentType[1] === 'e' && contentType[2] === 'x' && contentType[3] === 't';\n};\nmodule.exports = {\n  getResolveErrorBodyCallback,\n  isContentTypeApplicationJson,\n  isContentTypeText\n};","map":{"version":3,"names":["assert","require","ResponseStatusCodeError","chunksDecode","CHUNK_LIMIT","getResolveErrorBodyCallback","callback","body","contentType","statusCode","statusMessage","headers","chunks","length","chunk","push","message","queueMicrotask","stackTraceLimit","Error","payload","isContentTypeApplicationJson","JSON","parse","isContentTypeText","module","exports"],"sources":["/Users/nataliia/PussyProjects/react-app/node_modules/undici/lib/api/util.js"],"sourcesContent":["const assert = require('node:assert')\nconst {\n  ResponseStatusCodeError\n} = require('../core/errors')\n\nconst { chunksDecode } = require('./readable')\nconst CHUNK_LIMIT = 128 * 1024\n\nasync function getResolveErrorBodyCallback ({ callback, body, contentType, statusCode, statusMessage, headers }) {\n  assert(body)\n\n  let chunks = []\n  let length = 0\n\n  try {\n    for await (const chunk of body) {\n      chunks.push(chunk)\n      length += chunk.length\n      if (length > CHUNK_LIMIT) {\n        chunks = []\n        length = 0\n        break\n      }\n    }\n  } catch {\n    chunks = []\n    length = 0\n    // Do nothing....\n  }\n\n  const message = `Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`\n\n  if (statusCode === 204 || !contentType || !length) {\n    queueMicrotask(() => callback(new ResponseStatusCodeError(message, statusCode, headers)))\n    return\n  }\n\n  const stackTraceLimit = Error.stackTraceLimit\n  Error.stackTraceLimit = 0\n  let payload\n\n  try {\n    if (isContentTypeApplicationJson(contentType)) {\n      payload = JSON.parse(chunksDecode(chunks, length))\n    } else if (isContentTypeText(contentType)) {\n      payload = chunksDecode(chunks, length)\n    }\n  } catch {\n    // process in a callback to avoid throwing in the microtask queue\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit\n  }\n  queueMicrotask(() => callback(new ResponseStatusCodeError(message, statusCode, headers, payload)))\n}\n\nconst isContentTypeApplicationJson = (contentType) => {\n  return (\n    contentType.length > 15 &&\n    contentType[11] === '/' &&\n    contentType[0] === 'a' &&\n    contentType[1] === 'p' &&\n    contentType[2] === 'p' &&\n    contentType[3] === 'l' &&\n    contentType[4] === 'i' &&\n    contentType[5] === 'c' &&\n    contentType[6] === 'a' &&\n    contentType[7] === 't' &&\n    contentType[8] === 'i' &&\n    contentType[9] === 'o' &&\n    contentType[10] === 'n' &&\n    contentType[12] === 'j' &&\n    contentType[13] === 's' &&\n    contentType[14] === 'o' &&\n    contentType[15] === 'n'\n  )\n}\n\nconst isContentTypeText = (contentType) => {\n  return (\n    contentType.length > 4 &&\n    contentType[4] === '/' &&\n    contentType[0] === 't' &&\n    contentType[1] === 'e' &&\n    contentType[2] === 'x' &&\n    contentType[3] === 't'\n  )\n}\n\nmodule.exports = {\n  getResolveErrorBodyCallback,\n  isContentTypeApplicationJson,\n  isContentTypeText\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
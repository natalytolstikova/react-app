{"ast":null,"code":"'use strict';\n\nconst util = require('../../core/util');\nconst {\n  ReadableStreamFrom,\n  isBlobLike,\n  isReadableStreamLike,\n  readableStreamClose,\n  createDeferredPromise,\n  fullyReadBody,\n  extractMimeType,\n  utf8DecodeBytes\n} = require('./util');\nconst {\n  FormData\n} = require('./formdata');\nconst {\n  kState\n} = require('./symbols');\nconst {\n  webidl\n} = require('./webidl');\nconst {\n  Blob\n} = require('node:buffer');\nconst assert = require('node:assert');\nconst {\n  isErrored,\n  isDisturbed\n} = require('node:stream');\nconst {\n  isArrayBuffer\n} = require('node:util/types');\nconst {\n  serializeAMimeType\n} = require('./data-url');\nconst {\n  multipartFormDataParser\n} = require('./formdata-parser');\nconst textEncoder = new TextEncoder();\nfunction noop() {}\nconst hasFinalizationRegistry = globalThis.FinalizationRegistry && process.version.indexOf('v18') !== 0;\nlet streamRegistry;\nif (hasFinalizationRegistry) {\n  streamRegistry = new FinalizationRegistry(weakRef => {\n    const stream = weakRef.deref();\n    if (stream && !stream.locked && !isDisturbed(stream) && !isErrored(stream)) {\n      stream.cancel('Response object has been garbage collected').catch(noop);\n    }\n  });\n}\n\n// https://fetch.spec.whatwg.org/#concept-bodyinit-extract\nfunction extractBody(object, keepalive = false) {\n  // 1. Let stream be null.\n  let stream = null;\n\n  // 2. If object is a ReadableStream object, then set stream to object.\n  if (object instanceof ReadableStream) {\n    stream = object;\n  } else if (isBlobLike(object)) {\n    // 3. Otherwise, if object is a Blob object, set stream to the\n    //    result of running object’s get stream.\n    stream = object.stream();\n  } else {\n    // 4. Otherwise, set stream to a new ReadableStream object, and set\n    //    up stream with byte reading support.\n    stream = new ReadableStream({\n      async pull(controller) {\n        const buffer = typeof source === 'string' ? textEncoder.encode(source) : source;\n        if (buffer.byteLength) {\n          controller.enqueue(buffer);\n        }\n        queueMicrotask(() => readableStreamClose(controller));\n      },\n      start() {},\n      type: 'bytes'\n    });\n  }\n\n  // 5. Assert: stream is a ReadableStream object.\n  assert(isReadableStreamLike(stream));\n\n  // 6. Let action be null.\n  let action = null;\n\n  // 7. Let source be null.\n  let source = null;\n\n  // 8. Let length be null.\n  let length = null;\n\n  // 9. Let type be null.\n  let type = null;\n\n  // 10. Switch on object:\n  if (typeof object === 'string') {\n    // Set source to the UTF-8 encoding of object.\n    // Note: setting source to a Uint8Array here breaks some mocking assumptions.\n    source = object;\n\n    // Set type to `text/plain;charset=UTF-8`.\n    type = 'text/plain;charset=UTF-8';\n  } else if (object instanceof URLSearchParams) {\n    // URLSearchParams\n\n    // spec says to run application/x-www-form-urlencoded on body.list\n    // this is implemented in Node.js as apart of an URLSearchParams instance toString method\n    // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490\n    // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100\n\n    // Set source to the result of running the application/x-www-form-urlencoded serializer with object’s list.\n    source = object.toString();\n\n    // Set type to `application/x-www-form-urlencoded;charset=UTF-8`.\n    type = 'application/x-www-form-urlencoded;charset=UTF-8';\n  } else if (isArrayBuffer(object)) {\n    // BufferSource/ArrayBuffer\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.slice());\n  } else if (ArrayBuffer.isView(object)) {\n    // BufferSource/ArrayBufferView\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));\n  } else if (util.isFormDataLike(object)) {\n    const boundary = `----formdata-undici-0${`${Math.floor(Math.random() * 1e11)}`.padStart(11, '0')}`;\n    const prefix = `--${boundary}\\r\\nContent-Disposition: form-data`;\n\n    /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n    const escape = str => str.replace(/\\n/g, '%0A').replace(/\\r/g, '%0D').replace(/\"/g, '%22');\n    const normalizeLinefeeds = value => value.replace(/\\r?\\n|\\r/g, '\\r\\n');\n\n    // Set action to this step: run the multipart/form-data\n    // encoding algorithm, with object’s entry list and UTF-8.\n    // - This ensures that the body is immutable and can't be changed afterwords\n    // - That the content-length is calculated in advance.\n    // - And that all parts are pre-encoded and ready to be sent.\n\n    const blobParts = [];\n    const rn = new Uint8Array([13, 10]); // '\\r\\n'\n    length = 0;\n    let hasUnknownSizeValue = false;\n    for (const [name, value] of object) {\n      if (typeof value === 'string') {\n        const chunk = textEncoder.encode(prefix + `; name=\"${escape(normalizeLinefeeds(name))}\"` + `\\r\\n\\r\\n${normalizeLinefeeds(value)}\\r\\n`);\n        blobParts.push(chunk);\n        length += chunk.byteLength;\n      } else {\n        const chunk = textEncoder.encode(`${prefix}; name=\"${escape(normalizeLinefeeds(name))}\"` + (value.name ? `; filename=\"${escape(value.name)}\"` : '') + '\\r\\n' + `Content-Type: ${value.type || 'application/octet-stream'}\\r\\n\\r\\n`);\n        blobParts.push(chunk, value, rn);\n        if (typeof value.size === 'number') {\n          length += chunk.byteLength + value.size + rn.byteLength;\n        } else {\n          hasUnknownSizeValue = true;\n        }\n      }\n    }\n    const chunk = textEncoder.encode(`--${boundary}--`);\n    blobParts.push(chunk);\n    length += chunk.byteLength;\n    if (hasUnknownSizeValue) {\n      length = null;\n    }\n\n    // Set source to object.\n    source = object;\n    action = async function* () {\n      for (const part of blobParts) {\n        if (part.stream) {\n          yield* part.stream();\n        } else {\n          yield part;\n        }\n      }\n    };\n\n    // Set type to `multipart/form-data; boundary=`,\n    // followed by the multipart/form-data boundary string generated\n    // by the multipart/form-data encoding algorithm.\n    type = `multipart/form-data; boundary=${boundary}`;\n  } else if (isBlobLike(object)) {\n    // Blob\n\n    // Set source to object.\n    source = object;\n\n    // Set length to object’s size.\n    length = object.size;\n\n    // If object’s type attribute is not the empty byte sequence, set\n    // type to its value.\n    if (object.type) {\n      type = object.type;\n    }\n  } else if (typeof object[Symbol.asyncIterator] === 'function') {\n    // If keepalive is true, then throw a TypeError.\n    if (keepalive) {\n      throw new TypeError('keepalive');\n    }\n\n    // If object is disturbed or locked, then throw a TypeError.\n    if (util.isDisturbed(object) || object.locked) {\n      throw new TypeError('Response body object should not be disturbed or locked');\n    }\n    stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);\n  }\n\n  // 11. If source is a byte sequence, then set action to a\n  // step that returns source and length to source’s length.\n  if (typeof source === 'string' || util.isBuffer(source)) {\n    length = Buffer.byteLength(source);\n  }\n\n  // 12. If action is non-null, then run these steps in in parallel:\n  if (action != null) {\n    // Run action.\n    let iterator;\n    stream = new ReadableStream({\n      async start() {\n        iterator = action(object)[Symbol.asyncIterator]();\n      },\n      async pull(controller) {\n        const {\n          value,\n          done\n        } = await iterator.next();\n        if (done) {\n          // When running action is done, close stream.\n          queueMicrotask(() => {\n            controller.close();\n            controller.byobRequest?.respond(0);\n          });\n        } else {\n          // Whenever one or more bytes are available and stream is not errored,\n          // enqueue a Uint8Array wrapping an ArrayBuffer containing the available\n          // bytes into stream.\n          if (!isErrored(stream)) {\n            const buffer = new Uint8Array(value);\n            if (buffer.byteLength) {\n              controller.enqueue(buffer);\n            }\n          }\n        }\n        return controller.desiredSize > 0;\n      },\n      async cancel(reason) {\n        await iterator.return();\n      },\n      type: 'bytes'\n    });\n  }\n\n  // 13. Let body be a body whose stream is stream, source is source,\n  // and length is length.\n  const body = {\n    stream,\n    source,\n    length\n  };\n\n  // 14. Return (body, type).\n  return [body, type];\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit-safely-extract\nfunction safelyExtractBody(object, keepalive = false) {\n  // To safely extract a body and a `Content-Type` value from\n  // a byte sequence or BodyInit object object, run these steps:\n\n  // 1. If object is a ReadableStream object, then:\n  if (object instanceof ReadableStream) {\n    // Assert: object is neither disturbed nor locked.\n    // istanbul ignore next\n    assert(!util.isDisturbed(object), 'The body has already been consumed.');\n    // istanbul ignore next\n    assert(!object.locked, 'The stream is locked.');\n  }\n\n  // 2. Return the results of extracting object.\n  return extractBody(object, keepalive);\n}\nfunction cloneBody(instance, body) {\n  // To clone a body body, run these steps:\n\n  // https://fetch.spec.whatwg.org/#concept-body-clone\n\n  // 1. Let « out1, out2 » be the result of teeing body’s stream.\n  const [out1, out2] = body.stream.tee();\n  if (hasFinalizationRegistry) {\n    streamRegistry.register(instance, new WeakRef(out1));\n  }\n\n  // 2. Set body’s stream to out1.\n  body.stream = out1;\n\n  // 3. Return a body whose stream is out2 and other members are copied from body.\n  return {\n    stream: out2,\n    length: body.length,\n    source: body.source\n  };\n}\nfunction throwIfAborted(state) {\n  if (state.aborted) {\n    throw new DOMException('The operation was aborted.', 'AbortError');\n  }\n}\nfunction bodyMixinMethods(instance) {\n  const methods = {\n    blob() {\n      // The blob() method steps are to return the result of\n      // running consume body with this and the following step\n      // given a byte sequence bytes: return a Blob whose\n      // contents are bytes and whose type attribute is this’s\n      // MIME type.\n      return consumeBody(this, bytes => {\n        let mimeType = bodyMimeType(this);\n        if (mimeType === null) {\n          mimeType = '';\n        } else if (mimeType) {\n          mimeType = serializeAMimeType(mimeType);\n        }\n\n        // Return a Blob whose contents are bytes and type attribute\n        // is mimeType.\n        return new Blob([bytes], {\n          type: mimeType\n        });\n      }, instance);\n    },\n    arrayBuffer() {\n      // The arrayBuffer() method steps are to return the result\n      // of running consume body with this and the following step\n      // given a byte sequence bytes: return a new ArrayBuffer\n      // whose contents are bytes.\n      return consumeBody(this, bytes => {\n        return new Uint8Array(bytes).buffer;\n      }, instance);\n    },\n    text() {\n      // The text() method steps are to return the result of running\n      // consume body with this and UTF-8 decode.\n      return consumeBody(this, utf8DecodeBytes, instance);\n    },\n    json() {\n      // The json() method steps are to return the result of running\n      // consume body with this and parse JSON from bytes.\n      return consumeBody(this, parseJSONFromBytes, instance);\n    },\n    formData() {\n      // The formData() method steps are to return the result of running\n      // consume body with this and the following step given a byte sequence bytes:\n      return consumeBody(this, value => {\n        // 1. Let mimeType be the result of get the MIME type with this.\n        const mimeType = bodyMimeType(this);\n\n        // 2. If mimeType is non-null, then switch on mimeType’s essence and run\n        //    the corresponding steps:\n        if (mimeType !== null) {\n          switch (mimeType.essence) {\n            case 'multipart/form-data':\n              {\n                // 1. ... [long step]\n                const parsed = multipartFormDataParser(value, mimeType);\n\n                // 2. If that fails for some reason, then throw a TypeError.\n                if (parsed === 'failure') {\n                  throw new TypeError('Failed to parse body as FormData.');\n                }\n\n                // 3. Return a new FormData object, appending each entry,\n                //    resulting from the parsing operation, to its entry list.\n                const fd = new FormData();\n                fd[kState] = parsed;\n                return fd;\n              }\n            case 'application/x-www-form-urlencoded':\n              {\n                // 1. Let entries be the result of parsing bytes.\n                const entries = new URLSearchParams(value.toString());\n\n                // 2. If entries is failure, then throw a TypeError.\n\n                // 3. Return a new FormData object whose entry list is entries.\n                const fd = new FormData();\n                for (const [name, value] of entries) {\n                  fd.append(name, value);\n                }\n                return fd;\n              }\n          }\n        }\n\n        // 3. Throw a TypeError.\n        throw new TypeError('Content-Type was not one of \"multipart/form-data\" or \"application/x-www-form-urlencoded\".');\n      }, instance);\n    },\n    bytes() {\n      // The bytes() method steps are to return the result of running consume body\n      // with this and the following step given a byte sequence bytes: return the\n      // result of creating a Uint8Array from bytes in this’s relevant realm.\n      return consumeBody(this, bytes => {\n        return new Uint8Array(bytes);\n      }, instance);\n    }\n  };\n  return methods;\n}\nfunction mixinBody(prototype) {\n  Object.assign(prototype.prototype, bodyMixinMethods(prototype));\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-consume-body\n * @param {Response|Request} object\n * @param {(value: unknown) => unknown} convertBytesToJSValue\n * @param {Response|Request} instance\n */\nasync function consumeBody(object, convertBytesToJSValue, instance) {\n  webidl.brandCheck(object, instance);\n\n  // 1. If object is unusable, then return a promise rejected\n  //    with a TypeError.\n  if (bodyUnusable(object)) {\n    throw new TypeError('Body is unusable: Body has already been read');\n  }\n  throwIfAborted(object[kState]);\n\n  // 2. Let promise be a new promise.\n  const promise = createDeferredPromise();\n\n  // 3. Let errorSteps given error be to reject promise with error.\n  const errorSteps = error => promise.reject(error);\n\n  // 4. Let successSteps given a byte sequence data be to resolve\n  //    promise with the result of running convertBytesToJSValue\n  //    with data. If that threw an exception, then run errorSteps\n  //    with that exception.\n  const successSteps = data => {\n    try {\n      promise.resolve(convertBytesToJSValue(data));\n    } catch (e) {\n      errorSteps(e);\n    }\n  };\n\n  // 5. If object’s body is null, then run successSteps with an\n  //    empty byte sequence.\n  if (object[kState].body == null) {\n    successSteps(Buffer.allocUnsafe(0));\n    return promise.promise;\n  }\n\n  // 6. Otherwise, fully read object’s body given successSteps,\n  //    errorSteps, and object’s relevant global object.\n  await fullyReadBody(object[kState].body, successSteps, errorSteps);\n\n  // 7. Return promise.\n  return promise.promise;\n}\n\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction bodyUnusable(object) {\n  const body = object[kState].body;\n\n  // An object including the Body interface mixin is\n  // said to be unusable if its body is non-null and\n  // its body’s stream is disturbed or locked.\n  return body != null && (body.stream.locked || util.isDisturbed(body.stream));\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value\n * @param {Uint8Array} bytes\n */\nfunction parseJSONFromBytes(bytes) {\n  return JSON.parse(utf8DecodeBytes(bytes));\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-mime-type\n * @param {import('./response').Response|import('./request').Request} requestOrResponse\n */\nfunction bodyMimeType(requestOrResponse) {\n  // 1. Let headers be null.\n  // 2. If requestOrResponse is a Request object, then set headers to requestOrResponse’s request’s header list.\n  // 3. Otherwise, set headers to requestOrResponse’s response’s header list.\n  /** @type {import('./headers').HeadersList} */\n  const headers = requestOrResponse[kState].headersList;\n\n  // 4. Let mimeType be the result of extracting a MIME type from headers.\n  const mimeType = extractMimeType(headers);\n\n  // 5. If mimeType is failure, then return null.\n  if (mimeType === 'failure') {\n    return null;\n  }\n\n  // 6. Return mimeType.\n  return mimeType;\n}\nmodule.exports = {\n  extractBody,\n  safelyExtractBody,\n  cloneBody,\n  mixinBody,\n  streamRegistry,\n  hasFinalizationRegistry,\n  bodyUnusable\n};","map":{"version":3,"names":["util","require","ReadableStreamFrom","isBlobLike","isReadableStreamLike","readableStreamClose","createDeferredPromise","fullyReadBody","extractMimeType","utf8DecodeBytes","FormData","kState","webidl","Blob","assert","isErrored","isDisturbed","isArrayBuffer","serializeAMimeType","multipartFormDataParser","textEncoder","TextEncoder","noop","hasFinalizationRegistry","globalThis","FinalizationRegistry","process","version","indexOf","streamRegistry","weakRef","stream","deref","locked","cancel","catch","extractBody","object","keepalive","ReadableStream","pull","controller","buffer","source","encode","byteLength","enqueue","queueMicrotask","start","type","action","length","URLSearchParams","toString","Uint8Array","slice","ArrayBuffer","isView","byteOffset","isFormDataLike","boundary","Math","floor","random","padStart","prefix","escape","str","replace","normalizeLinefeeds","value","blobParts","rn","hasUnknownSizeValue","name","chunk","push","size","part","Symbol","asyncIterator","TypeError","isBuffer","Buffer","iterator","done","next","close","byobRequest","respond","desiredSize","reason","return","body","safelyExtractBody","cloneBody","instance","out1","out2","tee","register","WeakRef","throwIfAborted","state","aborted","DOMException","bodyMixinMethods","methods","blob","consumeBody","bytes","mimeType","bodyMimeType","arrayBuffer","text","json","parseJSONFromBytes","formData","essence","parsed","fd","entries","append","mixinBody","prototype","Object","assign","convertBytesToJSValue","brandCheck","bodyUnusable","promise","errorSteps","error","reject","successSteps","data","resolve","e","allocUnsafe","JSON","parse","requestOrResponse","headers","headersList","module","exports"],"sources":["/Users/nataliia/PussyProjects/react-app/node_modules/undici/lib/web/fetch/body.js"],"sourcesContent":["'use strict'\n\nconst util = require('../../core/util')\nconst {\n  ReadableStreamFrom,\n  isBlobLike,\n  isReadableStreamLike,\n  readableStreamClose,\n  createDeferredPromise,\n  fullyReadBody,\n  extractMimeType,\n  utf8DecodeBytes\n} = require('./util')\nconst { FormData } = require('./formdata')\nconst { kState } = require('./symbols')\nconst { webidl } = require('./webidl')\nconst { Blob } = require('node:buffer')\nconst assert = require('node:assert')\nconst { isErrored, isDisturbed } = require('node:stream')\nconst { isArrayBuffer } = require('node:util/types')\nconst { serializeAMimeType } = require('./data-url')\nconst { multipartFormDataParser } = require('./formdata-parser')\n\nconst textEncoder = new TextEncoder()\nfunction noop () {}\n\nconst hasFinalizationRegistry = globalThis.FinalizationRegistry && process.version.indexOf('v18') !== 0\nlet streamRegistry\n\nif (hasFinalizationRegistry) {\n  streamRegistry = new FinalizationRegistry((weakRef) => {\n    const stream = weakRef.deref()\n    if (stream && !stream.locked && !isDisturbed(stream) && !isErrored(stream)) {\n      stream.cancel('Response object has been garbage collected').catch(noop)\n    }\n  })\n}\n\n// https://fetch.spec.whatwg.org/#concept-bodyinit-extract\nfunction extractBody (object, keepalive = false) {\n  // 1. Let stream be null.\n  let stream = null\n\n  // 2. If object is a ReadableStream object, then set stream to object.\n  if (object instanceof ReadableStream) {\n    stream = object\n  } else if (isBlobLike(object)) {\n    // 3. Otherwise, if object is a Blob object, set stream to the\n    //    result of running object’s get stream.\n    stream = object.stream()\n  } else {\n    // 4. Otherwise, set stream to a new ReadableStream object, and set\n    //    up stream with byte reading support.\n    stream = new ReadableStream({\n      async pull (controller) {\n        const buffer = typeof source === 'string' ? textEncoder.encode(source) : source\n\n        if (buffer.byteLength) {\n          controller.enqueue(buffer)\n        }\n\n        queueMicrotask(() => readableStreamClose(controller))\n      },\n      start () {},\n      type: 'bytes'\n    })\n  }\n\n  // 5. Assert: stream is a ReadableStream object.\n  assert(isReadableStreamLike(stream))\n\n  // 6. Let action be null.\n  let action = null\n\n  // 7. Let source be null.\n  let source = null\n\n  // 8. Let length be null.\n  let length = null\n\n  // 9. Let type be null.\n  let type = null\n\n  // 10. Switch on object:\n  if (typeof object === 'string') {\n    // Set source to the UTF-8 encoding of object.\n    // Note: setting source to a Uint8Array here breaks some mocking assumptions.\n    source = object\n\n    // Set type to `text/plain;charset=UTF-8`.\n    type = 'text/plain;charset=UTF-8'\n  } else if (object instanceof URLSearchParams) {\n    // URLSearchParams\n\n    // spec says to run application/x-www-form-urlencoded on body.list\n    // this is implemented in Node.js as apart of an URLSearchParams instance toString method\n    // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490\n    // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100\n\n    // Set source to the result of running the application/x-www-form-urlencoded serializer with object’s list.\n    source = object.toString()\n\n    // Set type to `application/x-www-form-urlencoded;charset=UTF-8`.\n    type = 'application/x-www-form-urlencoded;charset=UTF-8'\n  } else if (isArrayBuffer(object)) {\n    // BufferSource/ArrayBuffer\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.slice())\n  } else if (ArrayBuffer.isView(object)) {\n    // BufferSource/ArrayBufferView\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength))\n  } else if (util.isFormDataLike(object)) {\n    const boundary = `----formdata-undici-0${`${Math.floor(Math.random() * 1e11)}`.padStart(11, '0')}`\n    const prefix = `--${boundary}\\r\\nContent-Disposition: form-data`\n\n    /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n    const escape = (str) =>\n      str.replace(/\\n/g, '%0A').replace(/\\r/g, '%0D').replace(/\"/g, '%22')\n    const normalizeLinefeeds = (value) => value.replace(/\\r?\\n|\\r/g, '\\r\\n')\n\n    // Set action to this step: run the multipart/form-data\n    // encoding algorithm, with object’s entry list and UTF-8.\n    // - This ensures that the body is immutable and can't be changed afterwords\n    // - That the content-length is calculated in advance.\n    // - And that all parts are pre-encoded and ready to be sent.\n\n    const blobParts = []\n    const rn = new Uint8Array([13, 10]) // '\\r\\n'\n    length = 0\n    let hasUnknownSizeValue = false\n\n    for (const [name, value] of object) {\n      if (typeof value === 'string') {\n        const chunk = textEncoder.encode(prefix +\n          `; name=\"${escape(normalizeLinefeeds(name))}\"` +\n          `\\r\\n\\r\\n${normalizeLinefeeds(value)}\\r\\n`)\n        blobParts.push(chunk)\n        length += chunk.byteLength\n      } else {\n        const chunk = textEncoder.encode(`${prefix}; name=\"${escape(normalizeLinefeeds(name))}\"` +\n          (value.name ? `; filename=\"${escape(value.name)}\"` : '') + '\\r\\n' +\n          `Content-Type: ${\n            value.type || 'application/octet-stream'\n          }\\r\\n\\r\\n`)\n        blobParts.push(chunk, value, rn)\n        if (typeof value.size === 'number') {\n          length += chunk.byteLength + value.size + rn.byteLength\n        } else {\n          hasUnknownSizeValue = true\n        }\n      }\n    }\n\n    const chunk = textEncoder.encode(`--${boundary}--`)\n    blobParts.push(chunk)\n    length += chunk.byteLength\n    if (hasUnknownSizeValue) {\n      length = null\n    }\n\n    // Set source to object.\n    source = object\n\n    action = async function * () {\n      for (const part of blobParts) {\n        if (part.stream) {\n          yield * part.stream()\n        } else {\n          yield part\n        }\n      }\n    }\n\n    // Set type to `multipart/form-data; boundary=`,\n    // followed by the multipart/form-data boundary string generated\n    // by the multipart/form-data encoding algorithm.\n    type = `multipart/form-data; boundary=${boundary}`\n  } else if (isBlobLike(object)) {\n    // Blob\n\n    // Set source to object.\n    source = object\n\n    // Set length to object’s size.\n    length = object.size\n\n    // If object’s type attribute is not the empty byte sequence, set\n    // type to its value.\n    if (object.type) {\n      type = object.type\n    }\n  } else if (typeof object[Symbol.asyncIterator] === 'function') {\n    // If keepalive is true, then throw a TypeError.\n    if (keepalive) {\n      throw new TypeError('keepalive')\n    }\n\n    // If object is disturbed or locked, then throw a TypeError.\n    if (util.isDisturbed(object) || object.locked) {\n      throw new TypeError(\n        'Response body object should not be disturbed or locked'\n      )\n    }\n\n    stream =\n      object instanceof ReadableStream ? object : ReadableStreamFrom(object)\n  }\n\n  // 11. If source is a byte sequence, then set action to a\n  // step that returns source and length to source’s length.\n  if (typeof source === 'string' || util.isBuffer(source)) {\n    length = Buffer.byteLength(source)\n  }\n\n  // 12. If action is non-null, then run these steps in in parallel:\n  if (action != null) {\n    // Run action.\n    let iterator\n    stream = new ReadableStream({\n      async start () {\n        iterator = action(object)[Symbol.asyncIterator]()\n      },\n      async pull (controller) {\n        const { value, done } = await iterator.next()\n        if (done) {\n          // When running action is done, close stream.\n          queueMicrotask(() => {\n            controller.close()\n            controller.byobRequest?.respond(0)\n          })\n        } else {\n          // Whenever one or more bytes are available and stream is not errored,\n          // enqueue a Uint8Array wrapping an ArrayBuffer containing the available\n          // bytes into stream.\n          if (!isErrored(stream)) {\n            const buffer = new Uint8Array(value)\n            if (buffer.byteLength) {\n              controller.enqueue(buffer)\n            }\n          }\n        }\n        return controller.desiredSize > 0\n      },\n      async cancel (reason) {\n        await iterator.return()\n      },\n      type: 'bytes'\n    })\n  }\n\n  // 13. Let body be a body whose stream is stream, source is source,\n  // and length is length.\n  const body = { stream, source, length }\n\n  // 14. Return (body, type).\n  return [body, type]\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit-safely-extract\nfunction safelyExtractBody (object, keepalive = false) {\n  // To safely extract a body and a `Content-Type` value from\n  // a byte sequence or BodyInit object object, run these steps:\n\n  // 1. If object is a ReadableStream object, then:\n  if (object instanceof ReadableStream) {\n    // Assert: object is neither disturbed nor locked.\n    // istanbul ignore next\n    assert(!util.isDisturbed(object), 'The body has already been consumed.')\n    // istanbul ignore next\n    assert(!object.locked, 'The stream is locked.')\n  }\n\n  // 2. Return the results of extracting object.\n  return extractBody(object, keepalive)\n}\n\nfunction cloneBody (instance, body) {\n  // To clone a body body, run these steps:\n\n  // https://fetch.spec.whatwg.org/#concept-body-clone\n\n  // 1. Let « out1, out2 » be the result of teeing body’s stream.\n  const [out1, out2] = body.stream.tee()\n\n  if (hasFinalizationRegistry) {\n    streamRegistry.register(instance, new WeakRef(out1))\n  }\n\n  // 2. Set body’s stream to out1.\n  body.stream = out1\n\n  // 3. Return a body whose stream is out2 and other members are copied from body.\n  return {\n    stream: out2,\n    length: body.length,\n    source: body.source\n  }\n}\n\nfunction throwIfAborted (state) {\n  if (state.aborted) {\n    throw new DOMException('The operation was aborted.', 'AbortError')\n  }\n}\n\nfunction bodyMixinMethods (instance) {\n  const methods = {\n    blob () {\n      // The blob() method steps are to return the result of\n      // running consume body with this and the following step\n      // given a byte sequence bytes: return a Blob whose\n      // contents are bytes and whose type attribute is this’s\n      // MIME type.\n      return consumeBody(this, (bytes) => {\n        let mimeType = bodyMimeType(this)\n\n        if (mimeType === null) {\n          mimeType = ''\n        } else if (mimeType) {\n          mimeType = serializeAMimeType(mimeType)\n        }\n\n        // Return a Blob whose contents are bytes and type attribute\n        // is mimeType.\n        return new Blob([bytes], { type: mimeType })\n      }, instance)\n    },\n\n    arrayBuffer () {\n      // The arrayBuffer() method steps are to return the result\n      // of running consume body with this and the following step\n      // given a byte sequence bytes: return a new ArrayBuffer\n      // whose contents are bytes.\n      return consumeBody(this, (bytes) => {\n        return new Uint8Array(bytes).buffer\n      }, instance)\n    },\n\n    text () {\n      // The text() method steps are to return the result of running\n      // consume body with this and UTF-8 decode.\n      return consumeBody(this, utf8DecodeBytes, instance)\n    },\n\n    json () {\n      // The json() method steps are to return the result of running\n      // consume body with this and parse JSON from bytes.\n      return consumeBody(this, parseJSONFromBytes, instance)\n    },\n\n    formData () {\n      // The formData() method steps are to return the result of running\n      // consume body with this and the following step given a byte sequence bytes:\n      return consumeBody(this, (value) => {\n        // 1. Let mimeType be the result of get the MIME type with this.\n        const mimeType = bodyMimeType(this)\n\n        // 2. If mimeType is non-null, then switch on mimeType’s essence and run\n        //    the corresponding steps:\n        if (mimeType !== null) {\n          switch (mimeType.essence) {\n            case 'multipart/form-data': {\n              // 1. ... [long step]\n              const parsed = multipartFormDataParser(value, mimeType)\n\n              // 2. If that fails for some reason, then throw a TypeError.\n              if (parsed === 'failure') {\n                throw new TypeError('Failed to parse body as FormData.')\n              }\n\n              // 3. Return a new FormData object, appending each entry,\n              //    resulting from the parsing operation, to its entry list.\n              const fd = new FormData()\n              fd[kState] = parsed\n\n              return fd\n            }\n            case 'application/x-www-form-urlencoded': {\n              // 1. Let entries be the result of parsing bytes.\n              const entries = new URLSearchParams(value.toString())\n\n              // 2. If entries is failure, then throw a TypeError.\n\n              // 3. Return a new FormData object whose entry list is entries.\n              const fd = new FormData()\n\n              for (const [name, value] of entries) {\n                fd.append(name, value)\n              }\n\n              return fd\n            }\n          }\n        }\n\n        // 3. Throw a TypeError.\n        throw new TypeError(\n          'Content-Type was not one of \"multipart/form-data\" or \"application/x-www-form-urlencoded\".'\n        )\n      }, instance)\n    },\n\n    bytes () {\n      // The bytes() method steps are to return the result of running consume body\n      // with this and the following step given a byte sequence bytes: return the\n      // result of creating a Uint8Array from bytes in this’s relevant realm.\n      return consumeBody(this, (bytes) => {\n        return new Uint8Array(bytes)\n      }, instance)\n    }\n  }\n\n  return methods\n}\n\nfunction mixinBody (prototype) {\n  Object.assign(prototype.prototype, bodyMixinMethods(prototype))\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-consume-body\n * @param {Response|Request} object\n * @param {(value: unknown) => unknown} convertBytesToJSValue\n * @param {Response|Request} instance\n */\nasync function consumeBody (object, convertBytesToJSValue, instance) {\n  webidl.brandCheck(object, instance)\n\n  // 1. If object is unusable, then return a promise rejected\n  //    with a TypeError.\n  if (bodyUnusable(object)) {\n    throw new TypeError('Body is unusable: Body has already been read')\n  }\n\n  throwIfAborted(object[kState])\n\n  // 2. Let promise be a new promise.\n  const promise = createDeferredPromise()\n\n  // 3. Let errorSteps given error be to reject promise with error.\n  const errorSteps = (error) => promise.reject(error)\n\n  // 4. Let successSteps given a byte sequence data be to resolve\n  //    promise with the result of running convertBytesToJSValue\n  //    with data. If that threw an exception, then run errorSteps\n  //    with that exception.\n  const successSteps = (data) => {\n    try {\n      promise.resolve(convertBytesToJSValue(data))\n    } catch (e) {\n      errorSteps(e)\n    }\n  }\n\n  // 5. If object’s body is null, then run successSteps with an\n  //    empty byte sequence.\n  if (object[kState].body == null) {\n    successSteps(Buffer.allocUnsafe(0))\n    return promise.promise\n  }\n\n  // 6. Otherwise, fully read object’s body given successSteps,\n  //    errorSteps, and object’s relevant global object.\n  await fullyReadBody(object[kState].body, successSteps, errorSteps)\n\n  // 7. Return promise.\n  return promise.promise\n}\n\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction bodyUnusable (object) {\n  const body = object[kState].body\n\n  // An object including the Body interface mixin is\n  // said to be unusable if its body is non-null and\n  // its body’s stream is disturbed or locked.\n  return body != null && (body.stream.locked || util.isDisturbed(body.stream))\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value\n * @param {Uint8Array} bytes\n */\nfunction parseJSONFromBytes (bytes) {\n  return JSON.parse(utf8DecodeBytes(bytes))\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-mime-type\n * @param {import('./response').Response|import('./request').Request} requestOrResponse\n */\nfunction bodyMimeType (requestOrResponse) {\n  // 1. Let headers be null.\n  // 2. If requestOrResponse is a Request object, then set headers to requestOrResponse’s request’s header list.\n  // 3. Otherwise, set headers to requestOrResponse’s response’s header list.\n  /** @type {import('./headers').HeadersList} */\n  const headers = requestOrResponse[kState].headersList\n\n  // 4. Let mimeType be the result of extracting a MIME type from headers.\n  const mimeType = extractMimeType(headers)\n\n  // 5. If mimeType is failure, then return null.\n  if (mimeType === 'failure') {\n    return null\n  }\n\n  // 6. Return mimeType.\n  return mimeType\n}\n\nmodule.exports = {\n  extractBody,\n  safelyExtractBody,\n  cloneBody,\n  mixinBody,\n  streamRegistry,\n  hasFinalizationRegistry,\n  bodyUnusable\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
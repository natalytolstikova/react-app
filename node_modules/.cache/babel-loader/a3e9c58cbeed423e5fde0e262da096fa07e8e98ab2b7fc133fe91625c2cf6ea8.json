{"ast":null,"code":"'use strict';\n\nconst {\n  WebsocketFrameSend\n} = require('./frame');\nconst {\n  opcodes,\n  sendHints\n} = require('./constants');\nconst FixedQueue = require('../../dispatcher/fixed-queue');\n\n/** @type {typeof Uint8Array} */\nconst FastBuffer = Buffer[Symbol.species];\n\n/**\n * @typedef {object} SendQueueNode\n * @property {Promise<void> | null} promise\n * @property {((...args: any[]) => any)} callback\n * @property {Buffer | null} frame\n */\n\nclass SendQueue {\n  /**\n   * @type {FixedQueue}\n   */\n  #queue = new FixedQueue();\n\n  /**\n   * @type {boolean}\n   */\n  #running = false;\n\n  /** @type {import('node:net').Socket} */\n  #socket;\n  constructor(socket) {\n    this.#socket = socket;\n  }\n  add(item, cb, hint) {\n    if (hint !== sendHints.blob) {\n      const frame = createFrame(item, hint);\n      if (!this.#running) {\n        // fast-path\n        this.#socket.write(frame, cb);\n      } else {\n        /** @type {SendQueueNode} */\n        const node = {\n          promise: null,\n          callback: cb,\n          frame\n        };\n        this.#queue.push(node);\n      }\n      return;\n    }\n\n    /** @type {SendQueueNode} */\n    const node = {\n      promise: item.arrayBuffer().then(ab => {\n        node.promise = null;\n        node.frame = createFrame(ab, hint);\n      }),\n      callback: cb,\n      frame: null\n    };\n    this.#queue.push(node);\n    if (!this.#running) {\n      this.#run();\n    }\n  }\n  async #run() {\n    this.#running = true;\n    const queue = this.#queue;\n    while (!queue.isEmpty()) {\n      const node = queue.shift();\n      // wait pending promise\n      if (node.promise !== null) {\n        await node.promise;\n      }\n      // write\n      this.#socket.write(node.frame, node.callback);\n      // cleanup\n      node.callback = node.frame = null;\n    }\n    this.#running = false;\n  }\n}\nfunction createFrame(data, hint) {\n  return new WebsocketFrameSend(toBuffer(data, hint)).createFrame(hint === sendHints.string ? opcodes.TEXT : opcodes.BINARY);\n}\nfunction toBuffer(data, hint) {\n  switch (hint) {\n    case sendHints.string:\n      return Buffer.from(data);\n    case sendHints.arrayBuffer:\n    case sendHints.blob:\n      return new FastBuffer(data);\n    case sendHints.typedArray:\n      return new FastBuffer(data.buffer, data.byteOffset, data.byteLength);\n  }\n}\nmodule.exports = {\n  SendQueue\n};","map":{"version":3,"names":["WebsocketFrameSend","require","opcodes","sendHints","FixedQueue","FastBuffer","Buffer","Symbol","species","SendQueue","queue","running","socket","constructor","add","item","cb","hint","blob","frame","createFrame","write","node","promise","callback","push","arrayBuffer","then","ab","run","#run","isEmpty","shift","data","toBuffer","string","TEXT","BINARY","from","typedArray","buffer","byteOffset","byteLength","module","exports"],"sources":["/Users/nataliia/PussyProjects/react-app/node_modules/undici/lib/web/websocket/sender.js"],"sourcesContent":["'use strict'\n\nconst { WebsocketFrameSend } = require('./frame')\nconst { opcodes, sendHints } = require('./constants')\nconst FixedQueue = require('../../dispatcher/fixed-queue')\n\n/** @type {typeof Uint8Array} */\nconst FastBuffer = Buffer[Symbol.species]\n\n/**\n * @typedef {object} SendQueueNode\n * @property {Promise<void> | null} promise\n * @property {((...args: any[]) => any)} callback\n * @property {Buffer | null} frame\n */\n\nclass SendQueue {\n  /**\n   * @type {FixedQueue}\n   */\n  #queue = new FixedQueue()\n\n  /**\n   * @type {boolean}\n   */\n  #running = false\n\n  /** @type {import('node:net').Socket} */\n  #socket\n\n  constructor (socket) {\n    this.#socket = socket\n  }\n\n  add (item, cb, hint) {\n    if (hint !== sendHints.blob) {\n      const frame = createFrame(item, hint)\n      if (!this.#running) {\n        // fast-path\n        this.#socket.write(frame, cb)\n      } else {\n        /** @type {SendQueueNode} */\n        const node = {\n          promise: null,\n          callback: cb,\n          frame\n        }\n        this.#queue.push(node)\n      }\n      return\n    }\n\n    /** @type {SendQueueNode} */\n    const node = {\n      promise: item.arrayBuffer().then((ab) => {\n        node.promise = null\n        node.frame = createFrame(ab, hint)\n      }),\n      callback: cb,\n      frame: null\n    }\n\n    this.#queue.push(node)\n\n    if (!this.#running) {\n      this.#run()\n    }\n  }\n\n  async #run () {\n    this.#running = true\n    const queue = this.#queue\n    while (!queue.isEmpty()) {\n      const node = queue.shift()\n      // wait pending promise\n      if (node.promise !== null) {\n        await node.promise\n      }\n      // write\n      this.#socket.write(node.frame, node.callback)\n      // cleanup\n      node.callback = node.frame = null\n    }\n    this.#running = false\n  }\n}\n\nfunction createFrame (data, hint) {\n  return new WebsocketFrameSend(toBuffer(data, hint)).createFrame(hint === sendHints.string ? opcodes.TEXT : opcodes.BINARY)\n}\n\nfunction toBuffer (data, hint) {\n  switch (hint) {\n    case sendHints.string:\n      return Buffer.from(data)\n    case sendHints.arrayBuffer:\n    case sendHints.blob:\n      return new FastBuffer(data)\n    case sendHints.typedArray:\n      return new FastBuffer(data.buffer, data.byteOffset, data.byteLength)\n  }\n}\n\nmodule.exports = { SendQueue }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
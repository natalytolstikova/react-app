{"ast":null,"code":"'use strict';\n\nconst {\n  webidl\n} = require('../fetch/webidl');\nconst {\n  URLSerializer\n} = require('../fetch/data-url');\nconst {\n  environmentSettingsObject\n} = require('../fetch/util');\nconst {\n  staticPropertyDescriptors,\n  states,\n  sentCloseFrameState,\n  sendHints\n} = require('./constants');\nconst {\n  kWebSocketURL,\n  kReadyState,\n  kController,\n  kBinaryType,\n  kResponse,\n  kSentClose,\n  kByteParser\n} = require('./symbols');\nconst {\n  isConnecting,\n  isEstablished,\n  isClosing,\n  isValidSubprotocol,\n  fireEvent\n} = require('./util');\nconst {\n  establishWebSocketConnection,\n  closeWebSocketConnection\n} = require('./connection');\nconst {\n  ByteParser\n} = require('./receiver');\nconst {\n  kEnumerableProperty,\n  isBlobLike\n} = require('../../core/util');\nconst {\n  getGlobalDispatcher\n} = require('../../global');\nconst {\n  types\n} = require('node:util');\nconst {\n  ErrorEvent,\n  CloseEvent\n} = require('./events');\nconst {\n  SendQueue\n} = require('./sender');\n\n// https://websockets.spec.whatwg.org/#interface-definition\nclass WebSocket extends EventTarget {\n  #events = {\n    open: null,\n    error: null,\n    close: null,\n    message: null\n  };\n  #bufferedAmount = 0;\n  #protocol = '';\n  #extensions = '';\n\n  /** @type {SendQueue} */\n  #sendQueue;\n\n  /**\n   * @param {string} url\n   * @param {string|string[]} protocols\n   */\n  constructor(url, protocols = []) {\n    super();\n    const prefix = 'WebSocket constructor';\n    webidl.argumentLengthCheck(arguments, 1, prefix);\n    const options = webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'](protocols, prefix, 'options');\n    url = webidl.converters.USVString(url, prefix, 'url');\n    protocols = options.protocols;\n\n    // 1. Let baseURL be this's relevant settings object's API base URL.\n    const baseURL = environmentSettingsObject.settingsObject.baseUrl;\n\n    // 1. Let urlRecord be the result of applying the URL parser to url with baseURL.\n    let urlRecord;\n    try {\n      urlRecord = new URL(url, baseURL);\n    } catch (e) {\n      // 3. If urlRecord is failure, then throw a \"SyntaxError\" DOMException.\n      throw new DOMException(e, 'SyntaxError');\n    }\n\n    // 4. If urlRecord’s scheme is \"http\", then set urlRecord’s scheme to \"ws\".\n    if (urlRecord.protocol === 'http:') {\n      urlRecord.protocol = 'ws:';\n    } else if (urlRecord.protocol === 'https:') {\n      // 5. Otherwise, if urlRecord’s scheme is \"https\", set urlRecord’s scheme to \"wss\".\n      urlRecord.protocol = 'wss:';\n    }\n\n    // 6. If urlRecord’s scheme is not \"ws\" or \"wss\", then throw a \"SyntaxError\" DOMException.\n    if (urlRecord.protocol !== 'ws:' && urlRecord.protocol !== 'wss:') {\n      throw new DOMException(`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`, 'SyntaxError');\n    }\n\n    // 7. If urlRecord’s fragment is non-null, then throw a \"SyntaxError\"\n    //    DOMException.\n    if (urlRecord.hash || urlRecord.href.endsWith('#')) {\n      throw new DOMException('Got fragment', 'SyntaxError');\n    }\n\n    // 8. If protocols is a string, set protocols to a sequence consisting\n    //    of just that string.\n    if (typeof protocols === 'string') {\n      protocols = [protocols];\n    }\n\n    // 9. If any of the values in protocols occur more than once or otherwise\n    //    fail to match the requirements for elements that comprise the value\n    //    of `Sec-WebSocket-Protocol` fields as defined by The WebSocket\n    //    protocol, then throw a \"SyntaxError\" DOMException.\n    if (protocols.length !== new Set(protocols.map(p => p.toLowerCase())).size) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError');\n    }\n    if (protocols.length > 0 && !protocols.every(p => isValidSubprotocol(p))) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError');\n    }\n\n    // 10. Set this's url to urlRecord.\n    this[kWebSocketURL] = new URL(urlRecord.href);\n\n    // 11. Let client be this's relevant settings object.\n    const client = environmentSettingsObject.settingsObject;\n\n    // 12. Run this step in parallel:\n\n    //    1. Establish a WebSocket connection given urlRecord, protocols,\n    //       and client.\n    this[kController] = establishWebSocketConnection(urlRecord, protocols, client, this, (response, extensions) => this.#onConnectionEstablished(response, extensions), options);\n\n    // Each WebSocket object has an associated ready state, which is a\n    // number representing the state of the connection. Initially it must\n    // be CONNECTING (0).\n    this[kReadyState] = WebSocket.CONNECTING;\n    this[kSentClose] = sentCloseFrameState.NOT_SENT;\n\n    // The extensions attribute must initially return the empty string.\n\n    // The protocol attribute must initially return the empty string.\n\n    // Each WebSocket object has an associated binary type, which is a\n    // BinaryType. Initially it must be \"blob\".\n    this[kBinaryType] = 'blob';\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-close\n   * @param {number|undefined} code\n   * @param {string|undefined} reason\n   */\n  close(code = undefined, reason = undefined) {\n    webidl.brandCheck(this, WebSocket);\n    const prefix = 'WebSocket.close';\n    if (code !== undefined) {\n      code = webidl.converters['unsigned short'](code, prefix, 'code', {\n        clamp: true\n      });\n    }\n    if (reason !== undefined) {\n      reason = webidl.converters.USVString(reason, prefix, 'reason');\n    }\n\n    // 1. If code is present, but is neither an integer equal to 1000 nor an\n    //    integer in the range 3000 to 4999, inclusive, throw an\n    //    \"InvalidAccessError\" DOMException.\n    if (code !== undefined) {\n      if (code !== 1000 && (code < 3000 || code > 4999)) {\n        throw new DOMException('invalid code', 'InvalidAccessError');\n      }\n    }\n    let reasonByteLength = 0;\n\n    // 2. If reason is present, then run these substeps:\n    if (reason !== undefined) {\n      // 1. Let reasonBytes be the result of encoding reason.\n      // 2. If reasonBytes is longer than 123 bytes, then throw a\n      //    \"SyntaxError\" DOMException.\n      reasonByteLength = Buffer.byteLength(reason);\n      if (reasonByteLength > 123) {\n        throw new DOMException(`Reason must be less than 123 bytes; received ${reasonByteLength}`, 'SyntaxError');\n      }\n    }\n\n    // 3. Run the first matching steps from the following list:\n    closeWebSocketConnection(this, code, reason, reasonByteLength);\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-send\n   * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data\n   */\n  send(data) {\n    webidl.brandCheck(this, WebSocket);\n    const prefix = 'WebSocket.send';\n    webidl.argumentLengthCheck(arguments, 1, prefix);\n    data = webidl.converters.WebSocketSendData(data, prefix, 'data');\n\n    // 1. If this's ready state is CONNECTING, then throw an\n    //    \"InvalidStateError\" DOMException.\n    if (isConnecting(this)) {\n      throw new DOMException('Sent before connected.', 'InvalidStateError');\n    }\n\n    // 2. Run the appropriate set of steps from the following list:\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-6.1\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-5.2\n\n    if (!isEstablished(this) || isClosing(this)) {\n      return;\n    }\n\n    // If data is a string\n    if (typeof data === 'string') {\n      // If the WebSocket connection is established and the WebSocket\n      // closing handshake has not yet started, then the user agent\n      // must send a WebSocket Message comprised of the data argument\n      // using a text frame opcode; if the data cannot be sent, e.g.\n      // because it would need to be buffered but the buffer is full,\n      // the user agent must flag the WebSocket as full and then close\n      // the WebSocket connection. Any invocation of this method with a\n      // string argument that does not throw an exception must increase\n      // the bufferedAmount attribute by the number of bytes needed to\n      // express the argument as UTF-8.\n\n      const length = Buffer.byteLength(data);\n      this.#bufferedAmount += length;\n      this.#sendQueue.add(data, () => {\n        this.#bufferedAmount -= length;\n      }, sendHints.string);\n    } else if (types.isArrayBuffer(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need\n      // to be buffered but the buffer is full, the user agent must flag\n      // the WebSocket as full and then close the WebSocket connection.\n      // The data to be sent is the data stored in the buffer described\n      // by the ArrayBuffer object. Any invocation of this method with an\n      // ArrayBuffer argument that does not throw an exception must\n      // increase the bufferedAmount attribute by the length of the\n      // ArrayBuffer in bytes.\n\n      this.#bufferedAmount += data.byteLength;\n      this.#sendQueue.add(data, () => {\n        this.#bufferedAmount -= data.byteLength;\n      }, sendHints.arrayBuffer);\n    } else if (ArrayBuffer.isView(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The\n      // data to be sent is the data stored in the section of the buffer\n      // described by the ArrayBuffer object that data references. Any\n      // invocation of this method with this kind of argument that does\n      // not throw an exception must increase the bufferedAmount attribute\n      // by the length of data’s buffer in bytes.\n\n      this.#bufferedAmount += data.byteLength;\n      this.#sendQueue.add(data, () => {\n        this.#bufferedAmount -= data.byteLength;\n      }, sendHints.typedArray);\n    } else if (isBlobLike(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The data\n      // to be sent is the raw data represented by the Blob object. Any\n      // invocation of this method with a Blob argument that does not throw\n      // an exception must increase the bufferedAmount attribute by the size\n      // of the Blob object’s raw data, in bytes.\n\n      this.#bufferedAmount += data.size;\n      this.#sendQueue.add(data, () => {\n        this.#bufferedAmount -= data.size;\n      }, sendHints.blob);\n    }\n  }\n  get readyState() {\n    webidl.brandCheck(this, WebSocket);\n\n    // The readyState getter steps are to return this's ready state.\n    return this[kReadyState];\n  }\n  get bufferedAmount() {\n    webidl.brandCheck(this, WebSocket);\n    return this.#bufferedAmount;\n  }\n  get url() {\n    webidl.brandCheck(this, WebSocket);\n\n    // The url getter steps are to return this's url, serialized.\n    return URLSerializer(this[kWebSocketURL]);\n  }\n  get extensions() {\n    webidl.brandCheck(this, WebSocket);\n    return this.#extensions;\n  }\n  get protocol() {\n    webidl.brandCheck(this, WebSocket);\n    return this.#protocol;\n  }\n  get onopen() {\n    webidl.brandCheck(this, WebSocket);\n    return this.#events.open;\n  }\n  set onopen(fn) {\n    webidl.brandCheck(this, WebSocket);\n    if (this.#events.open) {\n      this.removeEventListener('open', this.#events.open);\n    }\n    if (typeof fn === 'function') {\n      this.#events.open = fn;\n      this.addEventListener('open', fn);\n    } else {\n      this.#events.open = null;\n    }\n  }\n  get onerror() {\n    webidl.brandCheck(this, WebSocket);\n    return this.#events.error;\n  }\n  set onerror(fn) {\n    webidl.brandCheck(this, WebSocket);\n    if (this.#events.error) {\n      this.removeEventListener('error', this.#events.error);\n    }\n    if (typeof fn === 'function') {\n      this.#events.error = fn;\n      this.addEventListener('error', fn);\n    } else {\n      this.#events.error = null;\n    }\n  }\n  get onclose() {\n    webidl.brandCheck(this, WebSocket);\n    return this.#events.close;\n  }\n  set onclose(fn) {\n    webidl.brandCheck(this, WebSocket);\n    if (this.#events.close) {\n      this.removeEventListener('close', this.#events.close);\n    }\n    if (typeof fn === 'function') {\n      this.#events.close = fn;\n      this.addEventListener('close', fn);\n    } else {\n      this.#events.close = null;\n    }\n  }\n  get onmessage() {\n    webidl.brandCheck(this, WebSocket);\n    return this.#events.message;\n  }\n  set onmessage(fn) {\n    webidl.brandCheck(this, WebSocket);\n    if (this.#events.message) {\n      this.removeEventListener('message', this.#events.message);\n    }\n    if (typeof fn === 'function') {\n      this.#events.message = fn;\n      this.addEventListener('message', fn);\n    } else {\n      this.#events.message = null;\n    }\n  }\n  get binaryType() {\n    webidl.brandCheck(this, WebSocket);\n    return this[kBinaryType];\n  }\n  set binaryType(type) {\n    webidl.brandCheck(this, WebSocket);\n    if (type !== 'blob' && type !== 'arraybuffer') {\n      this[kBinaryType] = 'blob';\n    } else {\n      this[kBinaryType] = type;\n    }\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n   */\n  #onConnectionEstablished(response, parsedExtensions) {\n    // processResponse is called when the \"response’s header list has been received and initialized.\"\n    // once this happens, the connection is open\n    this[kResponse] = response;\n    const parser = new ByteParser(this, parsedExtensions);\n    parser.on('drain', onParserDrain);\n    parser.on('error', onParserError.bind(this));\n    response.socket.ws = this;\n    this[kByteParser] = parser;\n    this.#sendQueue = new SendQueue(response.socket);\n\n    // 1. Change the ready state to OPEN (1).\n    this[kReadyState] = states.OPEN;\n\n    // 2. Change the extensions attribute’s value to the extensions in use, if\n    //    it is not the null value.\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\n    const extensions = response.headersList.get('sec-websocket-extensions');\n    if (extensions !== null) {\n      this.#extensions = extensions;\n    }\n\n    // 3. Change the protocol attribute’s value to the subprotocol in use, if\n    //    it is not the null value.\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-1.9\n    const protocol = response.headersList.get('sec-websocket-protocol');\n    if (protocol !== null) {\n      this.#protocol = protocol;\n    }\n\n    // 4. Fire an event named open at the WebSocket object.\n    fireEvent('open', this);\n  }\n}\n\n// https://websockets.spec.whatwg.org/#dom-websocket-connecting\nWebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;\n// https://websockets.spec.whatwg.org/#dom-websocket-open\nWebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;\n// https://websockets.spec.whatwg.org/#dom-websocket-closing\nWebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;\n// https://websockets.spec.whatwg.org/#dom-websocket-closed\nWebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;\nObject.defineProperties(WebSocket.prototype, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors,\n  url: kEnumerableProperty,\n  readyState: kEnumerableProperty,\n  bufferedAmount: kEnumerableProperty,\n  onopen: kEnumerableProperty,\n  onerror: kEnumerableProperty,\n  onclose: kEnumerableProperty,\n  close: kEnumerableProperty,\n  onmessage: kEnumerableProperty,\n  binaryType: kEnumerableProperty,\n  send: kEnumerableProperty,\n  extensions: kEnumerableProperty,\n  protocol: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'WebSocket',\n    writable: false,\n    enumerable: false,\n    configurable: true\n  }\n});\nObject.defineProperties(WebSocket, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors\n});\nwebidl.converters['sequence<DOMString>'] = webidl.sequenceConverter(webidl.converters.DOMString);\nwebidl.converters['DOMString or sequence<DOMString>'] = function (V, prefix, argument) {\n  if (webidl.util.Type(V) === 'Object' && Symbol.iterator in V) {\n    return webidl.converters['sequence<DOMString>'](V);\n  }\n  return webidl.converters.DOMString(V, prefix, argument);\n};\n\n// This implements the proposal made in https://github.com/whatwg/websockets/issues/42\nwebidl.converters.WebSocketInit = webidl.dictionaryConverter([{\n  key: 'protocols',\n  converter: webidl.converters['DOMString or sequence<DOMString>'],\n  defaultValue: () => new Array(0)\n}, {\n  key: 'dispatcher',\n  converter: webidl.converters.any,\n  defaultValue: () => getGlobalDispatcher()\n}, {\n  key: 'headers',\n  converter: webidl.nullableConverter(webidl.converters.HeadersInit)\n}]);\nwebidl.converters['DOMString or sequence<DOMString> or WebSocketInit'] = function (V) {\n  if (webidl.util.Type(V) === 'Object' && !(Symbol.iterator in V)) {\n    return webidl.converters.WebSocketInit(V);\n  }\n  return {\n    protocols: webidl.converters['DOMString or sequence<DOMString>'](V)\n  };\n};\nwebidl.converters.WebSocketSendData = function (V) {\n  if (webidl.util.Type(V) === 'Object') {\n    if (isBlobLike(V)) {\n      return webidl.converters.Blob(V, {\n        strict: false\n      });\n    }\n    if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) {\n      return webidl.converters.BufferSource(V);\n    }\n  }\n  return webidl.converters.USVString(V);\n};\nfunction onParserDrain() {\n  this.ws[kResponse].socket.resume();\n}\nfunction onParserError(err) {\n  let message;\n  let code;\n  if (err instanceof CloseEvent) {\n    message = err.reason;\n    code = err.code;\n  } else {\n    message = err.message;\n  }\n  fireEvent('error', this, () => new ErrorEvent('error', {\n    error: err,\n    message\n  }));\n  closeWebSocketConnection(this, code);\n}\nmodule.exports = {\n  WebSocket\n};","map":{"version":3,"names":["webidl","require","URLSerializer","environmentSettingsObject","staticPropertyDescriptors","states","sentCloseFrameState","sendHints","kWebSocketURL","kReadyState","kController","kBinaryType","kResponse","kSentClose","kByteParser","isConnecting","isEstablished","isClosing","isValidSubprotocol","fireEvent","establishWebSocketConnection","closeWebSocketConnection","ByteParser","kEnumerableProperty","isBlobLike","getGlobalDispatcher","types","ErrorEvent","CloseEvent","SendQueue","WebSocket","EventTarget","events","open","error","close","message","bufferedAmount","protocol","extensions","sendQueue","constructor","url","protocols","prefix","argumentLengthCheck","arguments","options","converters","USVString","baseURL","settingsObject","baseUrl","urlRecord","URL","e","DOMException","hash","href","endsWith","length","Set","map","p","toLowerCase","size","every","client","response","onConnectionEstablished","CONNECTING","NOT_SENT","code","undefined","reason","brandCheck","clamp","reasonByteLength","Buffer","byteLength","send","data","WebSocketSendData","add","string","isArrayBuffer","arrayBuffer","ArrayBuffer","isView","typedArray","blob","readyState","onopen","fn","removeEventListener","addEventListener","onerror","onclose","onmessage","binaryType","type","#onConnectionEstablished","parsedExtensions","parser","on","onParserDrain","onParserError","bind","socket","ws","OPEN","headersList","get","prototype","CLOSING","CLOSED","Object","defineProperties","Symbol","toStringTag","value","writable","enumerable","configurable","sequenceConverter","DOMString","V","argument","util","Type","iterator","WebSocketInit","dictionaryConverter","key","converter","defaultValue","Array","any","nullableConverter","HeadersInit","Blob","strict","BufferSource","resume","err","module","exports"],"sources":["/Users/nataliia/PussyProjects/react-app/node_modules/undici/lib/web/websocket/websocket.js"],"sourcesContent":["'use strict'\n\nconst { webidl } = require('../fetch/webidl')\nconst { URLSerializer } = require('../fetch/data-url')\nconst { environmentSettingsObject } = require('../fetch/util')\nconst { staticPropertyDescriptors, states, sentCloseFrameState, sendHints } = require('./constants')\nconst {\n  kWebSocketURL,\n  kReadyState,\n  kController,\n  kBinaryType,\n  kResponse,\n  kSentClose,\n  kByteParser\n} = require('./symbols')\nconst {\n  isConnecting,\n  isEstablished,\n  isClosing,\n  isValidSubprotocol,\n  fireEvent\n} = require('./util')\nconst { establishWebSocketConnection, closeWebSocketConnection } = require('./connection')\nconst { ByteParser } = require('./receiver')\nconst { kEnumerableProperty, isBlobLike } = require('../../core/util')\nconst { getGlobalDispatcher } = require('../../global')\nconst { types } = require('node:util')\nconst { ErrorEvent, CloseEvent } = require('./events')\nconst { SendQueue } = require('./sender')\n\n// https://websockets.spec.whatwg.org/#interface-definition\nclass WebSocket extends EventTarget {\n  #events = {\n    open: null,\n    error: null,\n    close: null,\n    message: null\n  }\n\n  #bufferedAmount = 0\n  #protocol = ''\n  #extensions = ''\n\n  /** @type {SendQueue} */\n  #sendQueue\n\n  /**\n   * @param {string} url\n   * @param {string|string[]} protocols\n   */\n  constructor (url, protocols = []) {\n    super()\n\n    const prefix = 'WebSocket constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    const options = webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'](protocols, prefix, 'options')\n\n    url = webidl.converters.USVString(url, prefix, 'url')\n    protocols = options.protocols\n\n    // 1. Let baseURL be this's relevant settings object's API base URL.\n    const baseURL = environmentSettingsObject.settingsObject.baseUrl\n\n    // 1. Let urlRecord be the result of applying the URL parser to url with baseURL.\n    let urlRecord\n\n    try {\n      urlRecord = new URL(url, baseURL)\n    } catch (e) {\n      // 3. If urlRecord is failure, then throw a \"SyntaxError\" DOMException.\n      throw new DOMException(e, 'SyntaxError')\n    }\n\n    // 4. If urlRecord’s scheme is \"http\", then set urlRecord’s scheme to \"ws\".\n    if (urlRecord.protocol === 'http:') {\n      urlRecord.protocol = 'ws:'\n    } else if (urlRecord.protocol === 'https:') {\n      // 5. Otherwise, if urlRecord’s scheme is \"https\", set urlRecord’s scheme to \"wss\".\n      urlRecord.protocol = 'wss:'\n    }\n\n    // 6. If urlRecord’s scheme is not \"ws\" or \"wss\", then throw a \"SyntaxError\" DOMException.\n    if (urlRecord.protocol !== 'ws:' && urlRecord.protocol !== 'wss:') {\n      throw new DOMException(\n        `Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,\n        'SyntaxError'\n      )\n    }\n\n    // 7. If urlRecord’s fragment is non-null, then throw a \"SyntaxError\"\n    //    DOMException.\n    if (urlRecord.hash || urlRecord.href.endsWith('#')) {\n      throw new DOMException('Got fragment', 'SyntaxError')\n    }\n\n    // 8. If protocols is a string, set protocols to a sequence consisting\n    //    of just that string.\n    if (typeof protocols === 'string') {\n      protocols = [protocols]\n    }\n\n    // 9. If any of the values in protocols occur more than once or otherwise\n    //    fail to match the requirements for elements that comprise the value\n    //    of `Sec-WebSocket-Protocol` fields as defined by The WebSocket\n    //    protocol, then throw a \"SyntaxError\" DOMException.\n    if (protocols.length !== new Set(protocols.map(p => p.toLowerCase())).size) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')\n    }\n\n    if (protocols.length > 0 && !protocols.every(p => isValidSubprotocol(p))) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')\n    }\n\n    // 10. Set this's url to urlRecord.\n    this[kWebSocketURL] = new URL(urlRecord.href)\n\n    // 11. Let client be this's relevant settings object.\n    const client = environmentSettingsObject.settingsObject\n\n    // 12. Run this step in parallel:\n\n    //    1. Establish a WebSocket connection given urlRecord, protocols,\n    //       and client.\n    this[kController] = establishWebSocketConnection(\n      urlRecord,\n      protocols,\n      client,\n      this,\n      (response, extensions) => this.#onConnectionEstablished(response, extensions),\n      options\n    )\n\n    // Each WebSocket object has an associated ready state, which is a\n    // number representing the state of the connection. Initially it must\n    // be CONNECTING (0).\n    this[kReadyState] = WebSocket.CONNECTING\n\n    this[kSentClose] = sentCloseFrameState.NOT_SENT\n\n    // The extensions attribute must initially return the empty string.\n\n    // The protocol attribute must initially return the empty string.\n\n    // Each WebSocket object has an associated binary type, which is a\n    // BinaryType. Initially it must be \"blob\".\n    this[kBinaryType] = 'blob'\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-close\n   * @param {number|undefined} code\n   * @param {string|undefined} reason\n   */\n  close (code = undefined, reason = undefined) {\n    webidl.brandCheck(this, WebSocket)\n\n    const prefix = 'WebSocket.close'\n\n    if (code !== undefined) {\n      code = webidl.converters['unsigned short'](code, prefix, 'code', { clamp: true })\n    }\n\n    if (reason !== undefined) {\n      reason = webidl.converters.USVString(reason, prefix, 'reason')\n    }\n\n    // 1. If code is present, but is neither an integer equal to 1000 nor an\n    //    integer in the range 3000 to 4999, inclusive, throw an\n    //    \"InvalidAccessError\" DOMException.\n    if (code !== undefined) {\n      if (code !== 1000 && (code < 3000 || code > 4999)) {\n        throw new DOMException('invalid code', 'InvalidAccessError')\n      }\n    }\n\n    let reasonByteLength = 0\n\n    // 2. If reason is present, then run these substeps:\n    if (reason !== undefined) {\n      // 1. Let reasonBytes be the result of encoding reason.\n      // 2. If reasonBytes is longer than 123 bytes, then throw a\n      //    \"SyntaxError\" DOMException.\n      reasonByteLength = Buffer.byteLength(reason)\n\n      if (reasonByteLength > 123) {\n        throw new DOMException(\n          `Reason must be less than 123 bytes; received ${reasonByteLength}`,\n          'SyntaxError'\n        )\n      }\n    }\n\n    // 3. Run the first matching steps from the following list:\n    closeWebSocketConnection(this, code, reason, reasonByteLength)\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-send\n   * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data\n   */\n  send (data) {\n    webidl.brandCheck(this, WebSocket)\n\n    const prefix = 'WebSocket.send'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    data = webidl.converters.WebSocketSendData(data, prefix, 'data')\n\n    // 1. If this's ready state is CONNECTING, then throw an\n    //    \"InvalidStateError\" DOMException.\n    if (isConnecting(this)) {\n      throw new DOMException('Sent before connected.', 'InvalidStateError')\n    }\n\n    // 2. Run the appropriate set of steps from the following list:\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-6.1\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-5.2\n\n    if (!isEstablished(this) || isClosing(this)) {\n      return\n    }\n\n    // If data is a string\n    if (typeof data === 'string') {\n      // If the WebSocket connection is established and the WebSocket\n      // closing handshake has not yet started, then the user agent\n      // must send a WebSocket Message comprised of the data argument\n      // using a text frame opcode; if the data cannot be sent, e.g.\n      // because it would need to be buffered but the buffer is full,\n      // the user agent must flag the WebSocket as full and then close\n      // the WebSocket connection. Any invocation of this method with a\n      // string argument that does not throw an exception must increase\n      // the bufferedAmount attribute by the number of bytes needed to\n      // express the argument as UTF-8.\n\n      const length = Buffer.byteLength(data)\n\n      this.#bufferedAmount += length\n      this.#sendQueue.add(data, () => {\n        this.#bufferedAmount -= length\n      }, sendHints.string)\n    } else if (types.isArrayBuffer(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need\n      // to be buffered but the buffer is full, the user agent must flag\n      // the WebSocket as full and then close the WebSocket connection.\n      // The data to be sent is the data stored in the buffer described\n      // by the ArrayBuffer object. Any invocation of this method with an\n      // ArrayBuffer argument that does not throw an exception must\n      // increase the bufferedAmount attribute by the length of the\n      // ArrayBuffer in bytes.\n\n      this.#bufferedAmount += data.byteLength\n      this.#sendQueue.add(data, () => {\n        this.#bufferedAmount -= data.byteLength\n      }, sendHints.arrayBuffer)\n    } else if (ArrayBuffer.isView(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The\n      // data to be sent is the data stored in the section of the buffer\n      // described by the ArrayBuffer object that data references. Any\n      // invocation of this method with this kind of argument that does\n      // not throw an exception must increase the bufferedAmount attribute\n      // by the length of data’s buffer in bytes.\n\n      this.#bufferedAmount += data.byteLength\n      this.#sendQueue.add(data, () => {\n        this.#bufferedAmount -= data.byteLength\n      }, sendHints.typedArray)\n    } else if (isBlobLike(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The data\n      // to be sent is the raw data represented by the Blob object. Any\n      // invocation of this method with a Blob argument that does not throw\n      // an exception must increase the bufferedAmount attribute by the size\n      // of the Blob object’s raw data, in bytes.\n\n      this.#bufferedAmount += data.size\n      this.#sendQueue.add(data, () => {\n        this.#bufferedAmount -= data.size\n      }, sendHints.blob)\n    }\n  }\n\n  get readyState () {\n    webidl.brandCheck(this, WebSocket)\n\n    // The readyState getter steps are to return this's ready state.\n    return this[kReadyState]\n  }\n\n  get bufferedAmount () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#bufferedAmount\n  }\n\n  get url () {\n    webidl.brandCheck(this, WebSocket)\n\n    // The url getter steps are to return this's url, serialized.\n    return URLSerializer(this[kWebSocketURL])\n  }\n\n  get extensions () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#extensions\n  }\n\n  get protocol () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#protocol\n  }\n\n  get onopen () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.open\n  }\n\n  set onopen (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.open) {\n      this.removeEventListener('open', this.#events.open)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.open = fn\n      this.addEventListener('open', fn)\n    } else {\n      this.#events.open = null\n    }\n  }\n\n  get onerror () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.error\n  }\n\n  set onerror (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.error) {\n      this.removeEventListener('error', this.#events.error)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.error = fn\n      this.addEventListener('error', fn)\n    } else {\n      this.#events.error = null\n    }\n  }\n\n  get onclose () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.close\n  }\n\n  set onclose (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.close) {\n      this.removeEventListener('close', this.#events.close)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.close = fn\n      this.addEventListener('close', fn)\n    } else {\n      this.#events.close = null\n    }\n  }\n\n  get onmessage () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.message\n  }\n\n  set onmessage (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.message) {\n      this.removeEventListener('message', this.#events.message)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.message = fn\n      this.addEventListener('message', fn)\n    } else {\n      this.#events.message = null\n    }\n  }\n\n  get binaryType () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this[kBinaryType]\n  }\n\n  set binaryType (type) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (type !== 'blob' && type !== 'arraybuffer') {\n      this[kBinaryType] = 'blob'\n    } else {\n      this[kBinaryType] = type\n    }\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n   */\n  #onConnectionEstablished (response, parsedExtensions) {\n    // processResponse is called when the \"response’s header list has been received and initialized.\"\n    // once this happens, the connection is open\n    this[kResponse] = response\n\n    const parser = new ByteParser(this, parsedExtensions)\n    parser.on('drain', onParserDrain)\n    parser.on('error', onParserError.bind(this))\n\n    response.socket.ws = this\n    this[kByteParser] = parser\n\n    this.#sendQueue = new SendQueue(response.socket)\n\n    // 1. Change the ready state to OPEN (1).\n    this[kReadyState] = states.OPEN\n\n    // 2. Change the extensions attribute’s value to the extensions in use, if\n    //    it is not the null value.\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\n    const extensions = response.headersList.get('sec-websocket-extensions')\n\n    if (extensions !== null) {\n      this.#extensions = extensions\n    }\n\n    // 3. Change the protocol attribute’s value to the subprotocol in use, if\n    //    it is not the null value.\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-1.9\n    const protocol = response.headersList.get('sec-websocket-protocol')\n\n    if (protocol !== null) {\n      this.#protocol = protocol\n    }\n\n    // 4. Fire an event named open at the WebSocket object.\n    fireEvent('open', this)\n  }\n}\n\n// https://websockets.spec.whatwg.org/#dom-websocket-connecting\nWebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING\n// https://websockets.spec.whatwg.org/#dom-websocket-open\nWebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN\n// https://websockets.spec.whatwg.org/#dom-websocket-closing\nWebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING\n// https://websockets.spec.whatwg.org/#dom-websocket-closed\nWebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED\n\nObject.defineProperties(WebSocket.prototype, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors,\n  url: kEnumerableProperty,\n  readyState: kEnumerableProperty,\n  bufferedAmount: kEnumerableProperty,\n  onopen: kEnumerableProperty,\n  onerror: kEnumerableProperty,\n  onclose: kEnumerableProperty,\n  close: kEnumerableProperty,\n  onmessage: kEnumerableProperty,\n  binaryType: kEnumerableProperty,\n  send: kEnumerableProperty,\n  extensions: kEnumerableProperty,\n  protocol: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'WebSocket',\n    writable: false,\n    enumerable: false,\n    configurable: true\n  }\n})\n\nObject.defineProperties(WebSocket, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors\n})\n\nwebidl.converters['sequence<DOMString>'] = webidl.sequenceConverter(\n  webidl.converters.DOMString\n)\n\nwebidl.converters['DOMString or sequence<DOMString>'] = function (V, prefix, argument) {\n  if (webidl.util.Type(V) === 'Object' && Symbol.iterator in V) {\n    return webidl.converters['sequence<DOMString>'](V)\n  }\n\n  return webidl.converters.DOMString(V, prefix, argument)\n}\n\n// This implements the proposal made in https://github.com/whatwg/websockets/issues/42\nwebidl.converters.WebSocketInit = webidl.dictionaryConverter([\n  {\n    key: 'protocols',\n    converter: webidl.converters['DOMString or sequence<DOMString>'],\n    defaultValue: () => new Array(0)\n  },\n  {\n    key: 'dispatcher',\n    converter: webidl.converters.any,\n    defaultValue: () => getGlobalDispatcher()\n  },\n  {\n    key: 'headers',\n    converter: webidl.nullableConverter(webidl.converters.HeadersInit)\n  }\n])\n\nwebidl.converters['DOMString or sequence<DOMString> or WebSocketInit'] = function (V) {\n  if (webidl.util.Type(V) === 'Object' && !(Symbol.iterator in V)) {\n    return webidl.converters.WebSocketInit(V)\n  }\n\n  return { protocols: webidl.converters['DOMString or sequence<DOMString>'](V) }\n}\n\nwebidl.converters.WebSocketSendData = function (V) {\n  if (webidl.util.Type(V) === 'Object') {\n    if (isBlobLike(V)) {\n      return webidl.converters.Blob(V, { strict: false })\n    }\n\n    if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) {\n      return webidl.converters.BufferSource(V)\n    }\n  }\n\n  return webidl.converters.USVString(V)\n}\n\nfunction onParserDrain () {\n  this.ws[kResponse].socket.resume()\n}\n\nfunction onParserError (err) {\n  let message\n  let code\n\n  if (err instanceof CloseEvent) {\n    message = err.reason\n    code = err.code\n  } else {\n    message = err.message\n  }\n\n  fireEvent('error', this, () => new ErrorEvent('error', { error: err, message }))\n\n  closeWebSocketConnection(this, code)\n}\n\nmodule.exports = {\n  WebSocket\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
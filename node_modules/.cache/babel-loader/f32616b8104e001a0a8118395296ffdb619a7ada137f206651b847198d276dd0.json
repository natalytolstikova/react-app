{"ast":null,"code":"'use strict';\n\nconst {\n  isUSVString,\n  bufferToLowerCasedHeaderName\n} = require('../../core/util');\nconst {\n  utf8DecodeBytes\n} = require('./util');\nconst {\n  HTTP_TOKEN_CODEPOINTS,\n  isomorphicDecode\n} = require('./data-url');\nconst {\n  isFileLike\n} = require('./file');\nconst {\n  makeEntry\n} = require('./formdata');\nconst assert = require('node:assert');\nconst {\n  File: NodeFile\n} = require('node:buffer');\nconst File = globalThis.File ?? NodeFile;\nconst formDataNameBuffer = Buffer.from('form-data; name=\"');\nconst filenameBuffer = Buffer.from('; filename');\nconst dd = Buffer.from('--');\nconst ddcrlf = Buffer.from('--\\r\\n');\n\n/**\n * @param {string} chars\n */\nfunction isAsciiString(chars) {\n  for (let i = 0; i < chars.length; ++i) {\n    if ((chars.charCodeAt(i) & ~0x7F) !== 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#multipart-form-data-boundary\n * @param {string} boundary\n */\nfunction validateBoundary(boundary) {\n  const length = boundary.length;\n\n  // - its length is greater or equal to 27 and lesser or equal to 70, and\n  if (length < 27 || length > 70) {\n    return false;\n  }\n\n  // - it is composed by bytes in the ranges 0x30 to 0x39, 0x41 to 0x5A, or\n  //   0x61 to 0x7A, inclusive (ASCII alphanumeric), or which are 0x27 ('),\n  //   0x2D (-) or 0x5F (_).\n  for (let i = 0; i < length; ++i) {\n    const cp = boundary.charCodeAt(i);\n    if (!(cp >= 0x30 && cp <= 0x39 || cp >= 0x41 && cp <= 0x5a || cp >= 0x61 && cp <= 0x7a || cp === 0x27 || cp === 0x2d || cp === 0x5f)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#multipart-form-data-parser\n * @param {Buffer} input\n * @param {ReturnType<import('./data-url')['parseMIMEType']>} mimeType\n */\nfunction multipartFormDataParser(input, mimeType) {\n  // 1. Assert: mimeType’s essence is \"multipart/form-data\".\n  assert(mimeType !== 'failure' && mimeType.essence === 'multipart/form-data');\n  const boundaryString = mimeType.parameters.get('boundary');\n\n  // 2. If mimeType’s parameters[\"boundary\"] does not exist, return failure.\n  //    Otherwise, let boundary be the result of UTF-8 decoding mimeType’s\n  //    parameters[\"boundary\"].\n  if (boundaryString === undefined) {\n    return 'failure';\n  }\n  const boundary = Buffer.from(`--${boundaryString}`, 'utf8');\n\n  // 3. Let entry list be an empty entry list.\n  const entryList = [];\n\n  // 4. Let position be a pointer to a byte in input, initially pointing at\n  //    the first byte.\n  const position = {\n    position: 0\n  };\n\n  // Note: undici addition, allow \\r\\n before the body.\n  if (input[0] === 0x0d && input[1] === 0x0a) {\n    position.position += 2;\n  }\n\n  // 5. While true:\n  while (true) {\n    // 5.1. If position points to a sequence of bytes starting with 0x2D 0x2D\n    //      (`--`) followed by boundary, advance position by 2 + the length of\n    //      boundary. Otherwise, return failure.\n    // Note: boundary is padded with 2 dashes already, no need to add 2.\n    if (input.subarray(position.position, position.position + boundary.length).equals(boundary)) {\n      position.position += boundary.length;\n    } else {\n      return 'failure';\n    }\n\n    // 5.2. If position points to the sequence of bytes 0x2D 0x2D 0x0D 0x0A\n    //      (`--` followed by CR LF) followed by the end of input, return entry list.\n    // Note: a body does NOT need to end with CRLF. It can end with --.\n    if (position.position === input.length - 2 && bufferStartsWith(input, dd, position) || position.position === input.length - 4 && bufferStartsWith(input, ddcrlf, position)) {\n      return entryList;\n    }\n\n    // 5.3. If position does not point to a sequence of bytes starting with 0x0D\n    //      0x0A (CR LF), return failure.\n    if (input[position.position] !== 0x0d || input[position.position + 1] !== 0x0a) {\n      return 'failure';\n    }\n\n    // 5.4. Advance position by 2. (This skips past the newline.)\n    position.position += 2;\n\n    // 5.5. Let name, filename and contentType be the result of parsing\n    //      multipart/form-data headers on input and position, if the result\n    //      is not failure. Otherwise, return failure.\n    const result = parseMultipartFormDataHeaders(input, position);\n    if (result === 'failure') {\n      return 'failure';\n    }\n    let {\n      name,\n      filename,\n      contentType,\n      encoding\n    } = result;\n\n    // 5.6. Advance position by 2. (This skips past the empty line that marks\n    //      the end of the headers.)\n    position.position += 2;\n\n    // 5.7. Let body be the empty byte sequence.\n    let body;\n\n    // 5.8. Body loop: While position is not past the end of input:\n    // TODO: the steps here are completely wrong\n    {\n      const boundaryIndex = input.indexOf(boundary.subarray(2), position.position);\n      if (boundaryIndex === -1) {\n        return 'failure';\n      }\n      body = input.subarray(position.position, boundaryIndex - 4);\n      position.position += body.length;\n\n      // Note: position must be advanced by the body's length before being\n      // decoded, otherwise the parsing will fail.\n      if (encoding === 'base64') {\n        body = Buffer.from(body.toString(), 'base64');\n      }\n    }\n\n    // 5.9. If position does not point to a sequence of bytes starting with\n    //      0x0D 0x0A (CR LF), return failure. Otherwise, advance position by 2.\n    if (input[position.position] !== 0x0d || input[position.position + 1] !== 0x0a) {\n      return 'failure';\n    } else {\n      position.position += 2;\n    }\n\n    // 5.10. If filename is not null:\n    let value;\n    if (filename !== null) {\n      // 5.10.1. If contentType is null, set contentType to \"text/plain\".\n      contentType ??= 'text/plain';\n\n      // 5.10.2. If contentType is not an ASCII string, set contentType to the empty string.\n\n      // Note: `buffer.isAscii` can be used at zero-cost, but converting a string to a buffer is a high overhead.\n      // Content-Type is a relatively small string, so it is faster to use `String#charCodeAt`.\n      if (!isAsciiString(contentType)) {\n        contentType = '';\n      }\n\n      // 5.10.3. Let value be a new File object with name filename, type contentType, and body body.\n      value = new File([body], filename, {\n        type: contentType\n      });\n    } else {\n      // 5.11. Otherwise:\n\n      // 5.11.1. Let value be the UTF-8 decoding without BOM of body.\n      value = utf8DecodeBytes(Buffer.from(body));\n    }\n\n    // 5.12. Assert: name is a scalar value string and value is either a scalar value string or a File object.\n    assert(isUSVString(name));\n    assert(typeof value === 'string' && isUSVString(value) || isFileLike(value));\n\n    // 5.13. Create an entry with name and value, and append it to entry list.\n    entryList.push(makeEntry(name, value, filename));\n  }\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#parse-multipart-form-data-headers\n * @param {Buffer} input\n * @param {{ position: number }} position\n */\nfunction parseMultipartFormDataHeaders(input, position) {\n  // 1. Let name, filename and contentType be null.\n  let name = null;\n  let filename = null;\n  let contentType = null;\n  let encoding = null;\n\n  // 2. While true:\n  while (true) {\n    // 2.1. If position points to a sequence of bytes starting with 0x0D 0x0A (CR LF):\n    if (input[position.position] === 0x0d && input[position.position + 1] === 0x0a) {\n      // 2.1.1. If name is null, return failure.\n      if (name === null) {\n        return 'failure';\n      }\n\n      // 2.1.2. Return name, filename and contentType.\n      return {\n        name,\n        filename,\n        contentType,\n        encoding\n      };\n    }\n\n    // 2.2. Let header name be the result of collecting a sequence of bytes that are\n    //      not 0x0A (LF), 0x0D (CR) or 0x3A (:), given position.\n    let headerName = collectASequenceOfBytes(char => char !== 0x0a && char !== 0x0d && char !== 0x3a, input, position);\n\n    // 2.3. Remove any HTTP tab or space bytes from the start or end of header name.\n    headerName = removeChars(headerName, true, true, char => char === 0x9 || char === 0x20);\n\n    // 2.4. If header name does not match the field-name token production, return failure.\n    if (!HTTP_TOKEN_CODEPOINTS.test(headerName.toString())) {\n      return 'failure';\n    }\n\n    // 2.5. If the byte at position is not 0x3A (:), return failure.\n    if (input[position.position] !== 0x3a) {\n      return 'failure';\n    }\n\n    // 2.6. Advance position by 1.\n    position.position++;\n\n    // 2.7. Collect a sequence of bytes that are HTTP tab or space bytes given position.\n    //      (Do nothing with those bytes.)\n    collectASequenceOfBytes(char => char === 0x20 || char === 0x09, input, position);\n\n    // 2.8. Byte-lowercase header name and switch on the result:\n    switch (bufferToLowerCasedHeaderName(headerName)) {\n      case 'content-disposition':\n        {\n          // 1. Set name and filename to null.\n          name = filename = null;\n\n          // 2. If position does not point to a sequence of bytes starting with\n          //    `form-data; name=\"`, return failure.\n          if (!bufferStartsWith(input, formDataNameBuffer, position)) {\n            return 'failure';\n          }\n\n          // 3. Advance position so it points at the byte after the next 0x22 (\")\n          //    byte (the one in the sequence of bytes matched above).\n          position.position += 17;\n\n          // 4. Set name to the result of parsing a multipart/form-data name given\n          //    input and position, if the result is not failure. Otherwise, return\n          //    failure.\n          name = parseMultipartFormDataName(input, position);\n          if (name === null) {\n            return 'failure';\n          }\n\n          // 5. If position points to a sequence of bytes starting with `; filename=\"`:\n          if (bufferStartsWith(input, filenameBuffer, position)) {\n            // Note: undici also handles filename*\n            let check = position.position + filenameBuffer.length;\n            if (input[check] === 0x2a) {\n              position.position += 1;\n              check += 1;\n            }\n            if (input[check] !== 0x3d || input[check + 1] !== 0x22) {\n              // =\"\n              return 'failure';\n            }\n\n            // 1. Advance position so it points at the byte after the next 0x22 (\") byte\n            //    (the one in the sequence of bytes matched above).\n            position.position += 12;\n\n            // 2. Set filename to the result of parsing a multipart/form-data name given\n            //    input and position, if the result is not failure. Otherwise, return failure.\n            filename = parseMultipartFormDataName(input, position);\n            if (filename === null) {\n              return 'failure';\n            }\n          }\n          break;\n        }\n      case 'content-type':\n        {\n          // 1. Let header value be the result of collecting a sequence of bytes that are\n          //    not 0x0A (LF) or 0x0D (CR), given position.\n          let headerValue = collectASequenceOfBytes(char => char !== 0x0a && char !== 0x0d, input, position);\n\n          // 2. Remove any HTTP tab or space bytes from the end of header value.\n          headerValue = removeChars(headerValue, false, true, char => char === 0x9 || char === 0x20);\n\n          // 3. Set contentType to the isomorphic decoding of header value.\n          contentType = isomorphicDecode(headerValue);\n          break;\n        }\n      case 'content-transfer-encoding':\n        {\n          let headerValue = collectASequenceOfBytes(char => char !== 0x0a && char !== 0x0d, input, position);\n          headerValue = removeChars(headerValue, false, true, char => char === 0x9 || char === 0x20);\n          encoding = isomorphicDecode(headerValue);\n          break;\n        }\n      default:\n        {\n          // Collect a sequence of bytes that are not 0x0A (LF) or 0x0D (CR), given position.\n          // (Do nothing with those bytes.)\n          collectASequenceOfBytes(char => char !== 0x0a && char !== 0x0d, input, position);\n        }\n    }\n\n    // 2.9. If position does not point to a sequence of bytes starting with 0x0D 0x0A\n    //      (CR LF), return failure. Otherwise, advance position by 2 (past the newline).\n    if (input[position.position] !== 0x0d && input[position.position + 1] !== 0x0a) {\n      return 'failure';\n    } else {\n      position.position += 2;\n    }\n  }\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#parse-a-multipart-form-data-name\n * @param {Buffer} input\n * @param {{ position: number }} position\n */\nfunction parseMultipartFormDataName(input, position) {\n  // 1. Assert: The byte at (position - 1) is 0x22 (\").\n  assert(input[position.position - 1] === 0x22);\n\n  // 2. Let name be the result of collecting a sequence of bytes that are not 0x0A (LF), 0x0D (CR) or 0x22 (\"), given position.\n  /** @type {string | Buffer} */\n  let name = collectASequenceOfBytes(char => char !== 0x0a && char !== 0x0d && char !== 0x22, input, position);\n\n  // 3. If the byte at position is not 0x22 (\"), return failure. Otherwise, advance position by 1.\n  if (input[position.position] !== 0x22) {\n    return null; // name could be 'failure'\n  } else {\n    position.position++;\n  }\n\n  // 4. Replace any occurrence of the following subsequences in name with the given byte:\n  // - `%0A`: 0x0A (LF)\n  // - `%0D`: 0x0D (CR)\n  // - `%22`: 0x22 (\")\n  name = new TextDecoder().decode(name).replace(/%0A/ig, '\\n').replace(/%0D/ig, '\\r').replace(/%22/g, '\"');\n\n  // 5. Return the UTF-8 decoding without BOM of name.\n  return name;\n}\n\n/**\n * @param {(char: number) => boolean} condition\n * @param {Buffer} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfBytes(condition, input, position) {\n  let start = position.position;\n  while (start < input.length && condition(input[start])) {\n    ++start;\n  }\n  return input.subarray(position.position, position.position = start);\n}\n\n/**\n * @param {Buffer} buf\n * @param {boolean} leading\n * @param {boolean} trailing\n * @param {(charCode: number) => boolean} predicate\n * @returns {Buffer}\n */\nfunction removeChars(buf, leading, trailing, predicate) {\n  let lead = 0;\n  let trail = buf.length - 1;\n  if (leading) {\n    while (lead < buf.length && predicate(buf[lead])) lead++;\n  }\n  if (trailing) {\n    while (trail > 0 && predicate(buf[trail])) trail--;\n  }\n  return lead === 0 && trail === buf.length - 1 ? buf : buf.subarray(lead, trail + 1);\n}\n\n/**\n * Checks if {@param buffer} starts with {@param start}\n * @param {Buffer} buffer\n * @param {Buffer} start\n * @param {{ position: number }} position\n */\nfunction bufferStartsWith(buffer, start, position) {\n  if (buffer.length < start.length) {\n    return false;\n  }\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== buffer[position.position + i]) {\n      return false;\n    }\n  }\n  return true;\n}\nmodule.exports = {\n  multipartFormDataParser,\n  validateBoundary\n};","map":{"version":3,"names":["isUSVString","bufferToLowerCasedHeaderName","require","utf8DecodeBytes","HTTP_TOKEN_CODEPOINTS","isomorphicDecode","isFileLike","makeEntry","assert","File","NodeFile","globalThis","formDataNameBuffer","Buffer","from","filenameBuffer","dd","ddcrlf","isAsciiString","chars","i","length","charCodeAt","validateBoundary","boundary","cp","multipartFormDataParser","input","mimeType","essence","boundaryString","parameters","get","undefined","entryList","position","subarray","equals","bufferStartsWith","result","parseMultipartFormDataHeaders","name","filename","contentType","encoding","body","boundaryIndex","indexOf","toString","value","type","push","headerName","collectASequenceOfBytes","char","removeChars","test","parseMultipartFormDataName","check","headerValue","TextDecoder","decode","replace","condition","start","buf","leading","trailing","predicate","lead","trail","buffer","module","exports"],"sources":["/Users/nataliia/PussyProjects/react-app/node_modules/undici/lib/web/fetch/formdata-parser.js"],"sourcesContent":["'use strict'\n\nconst { isUSVString, bufferToLowerCasedHeaderName } = require('../../core/util')\nconst { utf8DecodeBytes } = require('./util')\nconst { HTTP_TOKEN_CODEPOINTS, isomorphicDecode } = require('./data-url')\nconst { isFileLike } = require('./file')\nconst { makeEntry } = require('./formdata')\nconst assert = require('node:assert')\nconst { File: NodeFile } = require('node:buffer')\n\nconst File = globalThis.File ?? NodeFile\n\nconst formDataNameBuffer = Buffer.from('form-data; name=\"')\nconst filenameBuffer = Buffer.from('; filename')\nconst dd = Buffer.from('--')\nconst ddcrlf = Buffer.from('--\\r\\n')\n\n/**\n * @param {string} chars\n */\nfunction isAsciiString (chars) {\n  for (let i = 0; i < chars.length; ++i) {\n    if ((chars.charCodeAt(i) & ~0x7F) !== 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#multipart-form-data-boundary\n * @param {string} boundary\n */\nfunction validateBoundary (boundary) {\n  const length = boundary.length\n\n  // - its length is greater or equal to 27 and lesser or equal to 70, and\n  if (length < 27 || length > 70) {\n    return false\n  }\n\n  // - it is composed by bytes in the ranges 0x30 to 0x39, 0x41 to 0x5A, or\n  //   0x61 to 0x7A, inclusive (ASCII alphanumeric), or which are 0x27 ('),\n  //   0x2D (-) or 0x5F (_).\n  for (let i = 0; i < length; ++i) {\n    const cp = boundary.charCodeAt(i)\n\n    if (!(\n      (cp >= 0x30 && cp <= 0x39) ||\n      (cp >= 0x41 && cp <= 0x5a) ||\n      (cp >= 0x61 && cp <= 0x7a) ||\n      cp === 0x27 ||\n      cp === 0x2d ||\n      cp === 0x5f\n    )) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#multipart-form-data-parser\n * @param {Buffer} input\n * @param {ReturnType<import('./data-url')['parseMIMEType']>} mimeType\n */\nfunction multipartFormDataParser (input, mimeType) {\n  // 1. Assert: mimeType’s essence is \"multipart/form-data\".\n  assert(mimeType !== 'failure' && mimeType.essence === 'multipart/form-data')\n\n  const boundaryString = mimeType.parameters.get('boundary')\n\n  // 2. If mimeType’s parameters[\"boundary\"] does not exist, return failure.\n  //    Otherwise, let boundary be the result of UTF-8 decoding mimeType’s\n  //    parameters[\"boundary\"].\n  if (boundaryString === undefined) {\n    return 'failure'\n  }\n\n  const boundary = Buffer.from(`--${boundaryString}`, 'utf8')\n\n  // 3. Let entry list be an empty entry list.\n  const entryList = []\n\n  // 4. Let position be a pointer to a byte in input, initially pointing at\n  //    the first byte.\n  const position = { position: 0 }\n\n  // Note: undici addition, allow \\r\\n before the body.\n  if (input[0] === 0x0d && input[1] === 0x0a) {\n    position.position += 2\n  }\n\n  // 5. While true:\n  while (true) {\n    // 5.1. If position points to a sequence of bytes starting with 0x2D 0x2D\n    //      (`--`) followed by boundary, advance position by 2 + the length of\n    //      boundary. Otherwise, return failure.\n    // Note: boundary is padded with 2 dashes already, no need to add 2.\n    if (input.subarray(position.position, position.position + boundary.length).equals(boundary)) {\n      position.position += boundary.length\n    } else {\n      return 'failure'\n    }\n\n    // 5.2. If position points to the sequence of bytes 0x2D 0x2D 0x0D 0x0A\n    //      (`--` followed by CR LF) followed by the end of input, return entry list.\n    // Note: a body does NOT need to end with CRLF. It can end with --.\n    if (\n      (position.position === input.length - 2 && bufferStartsWith(input, dd, position)) ||\n      (position.position === input.length - 4 && bufferStartsWith(input, ddcrlf, position))\n    ) {\n      return entryList\n    }\n\n    // 5.3. If position does not point to a sequence of bytes starting with 0x0D\n    //      0x0A (CR LF), return failure.\n    if (input[position.position] !== 0x0d || input[position.position + 1] !== 0x0a) {\n      return 'failure'\n    }\n\n    // 5.4. Advance position by 2. (This skips past the newline.)\n    position.position += 2\n\n    // 5.5. Let name, filename and contentType be the result of parsing\n    //      multipart/form-data headers on input and position, if the result\n    //      is not failure. Otherwise, return failure.\n    const result = parseMultipartFormDataHeaders(input, position)\n\n    if (result === 'failure') {\n      return 'failure'\n    }\n\n    let { name, filename, contentType, encoding } = result\n\n    // 5.6. Advance position by 2. (This skips past the empty line that marks\n    //      the end of the headers.)\n    position.position += 2\n\n    // 5.7. Let body be the empty byte sequence.\n    let body\n\n    // 5.8. Body loop: While position is not past the end of input:\n    // TODO: the steps here are completely wrong\n    {\n      const boundaryIndex = input.indexOf(boundary.subarray(2), position.position)\n\n      if (boundaryIndex === -1) {\n        return 'failure'\n      }\n\n      body = input.subarray(position.position, boundaryIndex - 4)\n\n      position.position += body.length\n\n      // Note: position must be advanced by the body's length before being\n      // decoded, otherwise the parsing will fail.\n      if (encoding === 'base64') {\n        body = Buffer.from(body.toString(), 'base64')\n      }\n    }\n\n    // 5.9. If position does not point to a sequence of bytes starting with\n    //      0x0D 0x0A (CR LF), return failure. Otherwise, advance position by 2.\n    if (input[position.position] !== 0x0d || input[position.position + 1] !== 0x0a) {\n      return 'failure'\n    } else {\n      position.position += 2\n    }\n\n    // 5.10. If filename is not null:\n    let value\n\n    if (filename !== null) {\n      // 5.10.1. If contentType is null, set contentType to \"text/plain\".\n      contentType ??= 'text/plain'\n\n      // 5.10.2. If contentType is not an ASCII string, set contentType to the empty string.\n\n      // Note: `buffer.isAscii` can be used at zero-cost, but converting a string to a buffer is a high overhead.\n      // Content-Type is a relatively small string, so it is faster to use `String#charCodeAt`.\n      if (!isAsciiString(contentType)) {\n        contentType = ''\n      }\n\n      // 5.10.3. Let value be a new File object with name filename, type contentType, and body body.\n      value = new File([body], filename, { type: contentType })\n    } else {\n      // 5.11. Otherwise:\n\n      // 5.11.1. Let value be the UTF-8 decoding without BOM of body.\n      value = utf8DecodeBytes(Buffer.from(body))\n    }\n\n    // 5.12. Assert: name is a scalar value string and value is either a scalar value string or a File object.\n    assert(isUSVString(name))\n    assert((typeof value === 'string' && isUSVString(value)) || isFileLike(value))\n\n    // 5.13. Create an entry with name and value, and append it to entry list.\n    entryList.push(makeEntry(name, value, filename))\n  }\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#parse-multipart-form-data-headers\n * @param {Buffer} input\n * @param {{ position: number }} position\n */\nfunction parseMultipartFormDataHeaders (input, position) {\n  // 1. Let name, filename and contentType be null.\n  let name = null\n  let filename = null\n  let contentType = null\n  let encoding = null\n\n  // 2. While true:\n  while (true) {\n    // 2.1. If position points to a sequence of bytes starting with 0x0D 0x0A (CR LF):\n    if (input[position.position] === 0x0d && input[position.position + 1] === 0x0a) {\n      // 2.1.1. If name is null, return failure.\n      if (name === null) {\n        return 'failure'\n      }\n\n      // 2.1.2. Return name, filename and contentType.\n      return { name, filename, contentType, encoding }\n    }\n\n    // 2.2. Let header name be the result of collecting a sequence of bytes that are\n    //      not 0x0A (LF), 0x0D (CR) or 0x3A (:), given position.\n    let headerName = collectASequenceOfBytes(\n      (char) => char !== 0x0a && char !== 0x0d && char !== 0x3a,\n      input,\n      position\n    )\n\n    // 2.3. Remove any HTTP tab or space bytes from the start or end of header name.\n    headerName = removeChars(headerName, true, true, (char) => char === 0x9 || char === 0x20)\n\n    // 2.4. If header name does not match the field-name token production, return failure.\n    if (!HTTP_TOKEN_CODEPOINTS.test(headerName.toString())) {\n      return 'failure'\n    }\n\n    // 2.5. If the byte at position is not 0x3A (:), return failure.\n    if (input[position.position] !== 0x3a) {\n      return 'failure'\n    }\n\n    // 2.6. Advance position by 1.\n    position.position++\n\n    // 2.7. Collect a sequence of bytes that are HTTP tab or space bytes given position.\n    //      (Do nothing with those bytes.)\n    collectASequenceOfBytes(\n      (char) => char === 0x20 || char === 0x09,\n      input,\n      position\n    )\n\n    // 2.8. Byte-lowercase header name and switch on the result:\n    switch (bufferToLowerCasedHeaderName(headerName)) {\n      case 'content-disposition': {\n        // 1. Set name and filename to null.\n        name = filename = null\n\n        // 2. If position does not point to a sequence of bytes starting with\n        //    `form-data; name=\"`, return failure.\n        if (!bufferStartsWith(input, formDataNameBuffer, position)) {\n          return 'failure'\n        }\n\n        // 3. Advance position so it points at the byte after the next 0x22 (\")\n        //    byte (the one in the sequence of bytes matched above).\n        position.position += 17\n\n        // 4. Set name to the result of parsing a multipart/form-data name given\n        //    input and position, if the result is not failure. Otherwise, return\n        //    failure.\n        name = parseMultipartFormDataName(input, position)\n\n        if (name === null) {\n          return 'failure'\n        }\n\n        // 5. If position points to a sequence of bytes starting with `; filename=\"`:\n        if (bufferStartsWith(input, filenameBuffer, position)) {\n          // Note: undici also handles filename*\n          let check = position.position + filenameBuffer.length\n\n          if (input[check] === 0x2a) {\n            position.position += 1\n            check += 1\n          }\n\n          if (input[check] !== 0x3d || input[check + 1] !== 0x22) { // =\"\n            return 'failure'\n          }\n\n          // 1. Advance position so it points at the byte after the next 0x22 (\") byte\n          //    (the one in the sequence of bytes matched above).\n          position.position += 12\n\n          // 2. Set filename to the result of parsing a multipart/form-data name given\n          //    input and position, if the result is not failure. Otherwise, return failure.\n          filename = parseMultipartFormDataName(input, position)\n\n          if (filename === null) {\n            return 'failure'\n          }\n        }\n\n        break\n      }\n      case 'content-type': {\n        // 1. Let header value be the result of collecting a sequence of bytes that are\n        //    not 0x0A (LF) or 0x0D (CR), given position.\n        let headerValue = collectASequenceOfBytes(\n          (char) => char !== 0x0a && char !== 0x0d,\n          input,\n          position\n        )\n\n        // 2. Remove any HTTP tab or space bytes from the end of header value.\n        headerValue = removeChars(headerValue, false, true, (char) => char === 0x9 || char === 0x20)\n\n        // 3. Set contentType to the isomorphic decoding of header value.\n        contentType = isomorphicDecode(headerValue)\n\n        break\n      }\n      case 'content-transfer-encoding': {\n        let headerValue = collectASequenceOfBytes(\n          (char) => char !== 0x0a && char !== 0x0d,\n          input,\n          position\n        )\n\n        headerValue = removeChars(headerValue, false, true, (char) => char === 0x9 || char === 0x20)\n\n        encoding = isomorphicDecode(headerValue)\n\n        break\n      }\n      default: {\n        // Collect a sequence of bytes that are not 0x0A (LF) or 0x0D (CR), given position.\n        // (Do nothing with those bytes.)\n        collectASequenceOfBytes(\n          (char) => char !== 0x0a && char !== 0x0d,\n          input,\n          position\n        )\n      }\n    }\n\n    // 2.9. If position does not point to a sequence of bytes starting with 0x0D 0x0A\n    //      (CR LF), return failure. Otherwise, advance position by 2 (past the newline).\n    if (input[position.position] !== 0x0d && input[position.position + 1] !== 0x0a) {\n      return 'failure'\n    } else {\n      position.position += 2\n    }\n  }\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#parse-a-multipart-form-data-name\n * @param {Buffer} input\n * @param {{ position: number }} position\n */\nfunction parseMultipartFormDataName (input, position) {\n  // 1. Assert: The byte at (position - 1) is 0x22 (\").\n  assert(input[position.position - 1] === 0x22)\n\n  // 2. Let name be the result of collecting a sequence of bytes that are not 0x0A (LF), 0x0D (CR) or 0x22 (\"), given position.\n  /** @type {string | Buffer} */\n  let name = collectASequenceOfBytes(\n    (char) => char !== 0x0a && char !== 0x0d && char !== 0x22,\n    input,\n    position\n  )\n\n  // 3. If the byte at position is not 0x22 (\"), return failure. Otherwise, advance position by 1.\n  if (input[position.position] !== 0x22) {\n    return null // name could be 'failure'\n  } else {\n    position.position++\n  }\n\n  // 4. Replace any occurrence of the following subsequences in name with the given byte:\n  // - `%0A`: 0x0A (LF)\n  // - `%0D`: 0x0D (CR)\n  // - `%22`: 0x22 (\")\n  name = new TextDecoder().decode(name)\n    .replace(/%0A/ig, '\\n')\n    .replace(/%0D/ig, '\\r')\n    .replace(/%22/g, '\"')\n\n  // 5. Return the UTF-8 decoding without BOM of name.\n  return name\n}\n\n/**\n * @param {(char: number) => boolean} condition\n * @param {Buffer} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfBytes (condition, input, position) {\n  let start = position.position\n\n  while (start < input.length && condition(input[start])) {\n    ++start\n  }\n\n  return input.subarray(position.position, (position.position = start))\n}\n\n/**\n * @param {Buffer} buf\n * @param {boolean} leading\n * @param {boolean} trailing\n * @param {(charCode: number) => boolean} predicate\n * @returns {Buffer}\n */\nfunction removeChars (buf, leading, trailing, predicate) {\n  let lead = 0\n  let trail = buf.length - 1\n\n  if (leading) {\n    while (lead < buf.length && predicate(buf[lead])) lead++\n  }\n\n  if (trailing) {\n    while (trail > 0 && predicate(buf[trail])) trail--\n  }\n\n  return lead === 0 && trail === buf.length - 1 ? buf : buf.subarray(lead, trail + 1)\n}\n\n/**\n * Checks if {@param buffer} starts with {@param start}\n * @param {Buffer} buffer\n * @param {Buffer} start\n * @param {{ position: number }} position\n */\nfunction bufferStartsWith (buffer, start, position) {\n  if (buffer.length < start.length) {\n    return false\n  }\n\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== buffer[position.position + i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nmodule.exports = {\n  multipartFormDataParser,\n  validateBoundary\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"// Ported from https://github.com/nodejs/undici/pull/907\n\n'use strict';\n\nconst assert = require('node:assert');\nconst {\n  Readable\n} = require('node:stream');\nconst {\n  RequestAbortedError,\n  NotSupportedError,\n  InvalidArgumentError,\n  AbortError\n} = require('../core/errors');\nconst util = require('../core/util');\nconst {\n  ReadableStreamFrom\n} = require('../core/util');\nconst kConsume = Symbol('kConsume');\nconst kReading = Symbol('kReading');\nconst kBody = Symbol('kBody');\nconst kAbort = Symbol('kAbort');\nconst kContentType = Symbol('kContentType');\nconst kContentLength = Symbol('kContentLength');\nconst noop = () => {};\nclass BodyReadable extends Readable {\n  constructor({\n    resume,\n    abort,\n    contentType = '',\n    contentLength,\n    highWaterMark = 64 * 1024 // Same as nodejs fs streams.\n  }) {\n    super({\n      autoDestroy: true,\n      read: resume,\n      highWaterMark\n    });\n    this._readableState.dataEmitted = false;\n    this[kAbort] = abort;\n    this[kConsume] = null;\n    this[kBody] = null;\n    this[kContentType] = contentType;\n    this[kContentLength] = contentLength;\n\n    // Is stream being consumed through Readable API?\n    // This is an optimization so that we avoid checking\n    // for 'data' and 'readable' listeners in the hot path\n    // inside push().\n    this[kReading] = false;\n  }\n  destroy(err) {\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError();\n    }\n    if (err) {\n      this[kAbort]();\n    }\n    return super.destroy(err);\n  }\n  _destroy(err, callback) {\n    // Workaround for Node \"bug\". If the stream is destroyed in same\n    // tick as it is created, then a user who is waiting for a\n    // promise (i.e micro tick) for installing a 'error' listener will\n    // never get a chance and will always encounter an unhandled exception.\n    if (!this[kReading]) {\n      setImmediate(() => {\n        callback(err);\n      });\n    } else {\n      callback(err);\n    }\n  }\n  on(ev, ...args) {\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = true;\n    }\n    return super.on(ev, ...args);\n  }\n  addListener(ev, ...args) {\n    return this.on(ev, ...args);\n  }\n  off(ev, ...args) {\n    const ret = super.off(ev, ...args);\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = this.listenerCount('data') > 0 || this.listenerCount('readable') > 0;\n    }\n    return ret;\n  }\n  removeListener(ev, ...args) {\n    return this.off(ev, ...args);\n  }\n  push(chunk) {\n    if (this[kConsume] && chunk !== null) {\n      consumePush(this[kConsume], chunk);\n      return this[kReading] ? super.push(chunk) : true;\n    }\n    return super.push(chunk);\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-text\n  async text() {\n    return consume(this, 'text');\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-json\n  async json() {\n    return consume(this, 'json');\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-blob\n  async blob() {\n    return consume(this, 'blob');\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-arraybuffer\n  async arrayBuffer() {\n    return consume(this, 'arrayBuffer');\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-formdata\n  async formData() {\n    // TODO: Implement.\n    throw new NotSupportedError();\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-bodyused\n  get bodyUsed() {\n    return util.isDisturbed(this);\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-body\n  get body() {\n    if (!this[kBody]) {\n      this[kBody] = ReadableStreamFrom(this);\n      if (this[kConsume]) {\n        // TODO: Is this the best way to force a lock?\n        this[kBody].getReader(); // Ensure stream is locked.\n        assert(this[kBody].locked);\n      }\n    }\n    return this[kBody];\n  }\n  async dump(opts) {\n    let limit = Number.isFinite(opts?.limit) ? opts.limit : 128 * 1024;\n    const signal = opts?.signal;\n    if (signal != null && (typeof signal !== 'object' || !('aborted' in signal))) {\n      throw new InvalidArgumentError('signal must be an AbortSignal');\n    }\n    signal?.throwIfAborted();\n    if (this._readableState.closeEmitted) {\n      return null;\n    }\n    return await new Promise((resolve, reject) => {\n      if (this[kContentLength] > limit) {\n        this.destroy(new AbortError());\n      }\n      const onAbort = () => {\n        this.destroy(signal.reason ?? new AbortError());\n      };\n      signal?.addEventListener('abort', onAbort);\n      this.on('close', function () {\n        signal?.removeEventListener('abort', onAbort);\n        if (signal?.aborted) {\n          reject(signal.reason ?? new AbortError());\n        } else {\n          resolve(null);\n        }\n      }).on('error', noop).on('data', function (chunk) {\n        limit -= chunk.length;\n        if (limit <= 0) {\n          this.destroy();\n        }\n      }).resume();\n    });\n  }\n}\n\n// https://streams.spec.whatwg.org/#readablestream-locked\nfunction isLocked(self) {\n  // Consume is an implicit lock.\n  return self[kBody] && self[kBody].locked === true || self[kConsume];\n}\n\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction isUnusable(self) {\n  return util.isDisturbed(self) || isLocked(self);\n}\nasync function consume(stream, type) {\n  assert(!stream[kConsume]);\n  return new Promise((resolve, reject) => {\n    if (isUnusable(stream)) {\n      const rState = stream._readableState;\n      if (rState.destroyed && rState.closeEmitted === false) {\n        stream.on('error', err => {\n          reject(err);\n        }).on('close', () => {\n          reject(new TypeError('unusable'));\n        });\n      } else {\n        reject(rState.errored ?? new TypeError('unusable'));\n      }\n    } else {\n      queueMicrotask(() => {\n        stream[kConsume] = {\n          type,\n          stream,\n          resolve,\n          reject,\n          length: 0,\n          body: []\n        };\n        stream.on('error', function (err) {\n          consumeFinish(this[kConsume], err);\n        }).on('close', function () {\n          if (this[kConsume].body !== null) {\n            consumeFinish(this[kConsume], new RequestAbortedError());\n          }\n        });\n        consumeStart(stream[kConsume]);\n      });\n    }\n  });\n}\nfunction consumeStart(consume) {\n  if (consume.body === null) {\n    return;\n  }\n  const {\n    _readableState: state\n  } = consume.stream;\n  if (state.bufferIndex) {\n    const start = state.bufferIndex;\n    const end = state.buffer.length;\n    for (let n = start; n < end; n++) {\n      consumePush(consume, state.buffer[n]);\n    }\n  } else {\n    for (const chunk of state.buffer) {\n      consumePush(consume, chunk);\n    }\n  }\n  if (state.endEmitted) {\n    consumeEnd(this[kConsume]);\n  } else {\n    consume.stream.on('end', function () {\n      consumeEnd(this[kConsume]);\n    });\n  }\n  consume.stream.resume();\n  while (consume.stream.read() != null) {\n    // Loop\n  }\n}\n\n/**\n * @param {Buffer[]} chunks\n * @param {number} length\n */\nfunction chunksDecode(chunks, length) {\n  if (chunks.length === 0 || length === 0) {\n    return '';\n  }\n  const buffer = chunks.length === 1 ? chunks[0] : Buffer.concat(chunks, length);\n  const bufferLength = buffer.length;\n\n  // Skip BOM.\n  const start = bufferLength > 2 && buffer[0] === 0xef && buffer[1] === 0xbb && buffer[2] === 0xbf ? 3 : 0;\n  return buffer.utf8Slice(start, bufferLength);\n}\nfunction consumeEnd(consume) {\n  const {\n    type,\n    body,\n    resolve,\n    stream,\n    length\n  } = consume;\n  try {\n    if (type === 'text') {\n      resolve(chunksDecode(body, length));\n    } else if (type === 'json') {\n      resolve(JSON.parse(chunksDecode(body, length)));\n    } else if (type === 'arrayBuffer') {\n      const dst = new Uint8Array(length);\n      let pos = 0;\n      for (const buf of body) {\n        dst.set(buf, pos);\n        pos += buf.byteLength;\n      }\n      resolve(dst.buffer);\n    } else if (type === 'blob') {\n      resolve(new Blob(body, {\n        type: stream[kContentType]\n      }));\n    }\n    consumeFinish(consume);\n  } catch (err) {\n    stream.destroy(err);\n  }\n}\nfunction consumePush(consume, chunk) {\n  consume.length += chunk.length;\n  consume.body.push(chunk);\n}\nfunction consumeFinish(consume, err) {\n  if (consume.body === null) {\n    return;\n  }\n  if (err) {\n    consume.reject(err);\n  } else {\n    consume.resolve();\n  }\n  consume.type = null;\n  consume.stream = null;\n  consume.resolve = null;\n  consume.reject = null;\n  consume.length = 0;\n  consume.body = null;\n}\nmodule.exports = {\n  Readable: BodyReadable,\n  chunksDecode\n};","map":{"version":3,"names":["assert","require","Readable","RequestAbortedError","NotSupportedError","InvalidArgumentError","AbortError","util","ReadableStreamFrom","kConsume","Symbol","kReading","kBody","kAbort","kContentType","kContentLength","noop","BodyReadable","constructor","resume","abort","contentType","contentLength","highWaterMark","autoDestroy","read","_readableState","dataEmitted","destroy","err","endEmitted","_destroy","callback","setImmediate","on","ev","args","addListener","off","ret","listenerCount","removeListener","push","chunk","consumePush","text","consume","json","blob","arrayBuffer","formData","bodyUsed","isDisturbed","body","getReader","locked","dump","opts","limit","Number","isFinite","signal","throwIfAborted","closeEmitted","Promise","resolve","reject","onAbort","reason","addEventListener","removeEventListener","aborted","length","isLocked","self","isUnusable","stream","type","rState","destroyed","TypeError","errored","queueMicrotask","consumeFinish","consumeStart","state","bufferIndex","start","end","buffer","n","consumeEnd","chunksDecode","chunks","Buffer","concat","bufferLength","utf8Slice","JSON","parse","dst","Uint8Array","pos","buf","set","byteLength","Blob","module","exports"],"sources":["/Users/nataliia/PussyProjects/react-app/node_modules/undici/lib/api/readable.js"],"sourcesContent":["// Ported from https://github.com/nodejs/undici/pull/907\n\n'use strict'\n\nconst assert = require('node:assert')\nconst { Readable } = require('node:stream')\nconst { RequestAbortedError, NotSupportedError, InvalidArgumentError, AbortError } = require('../core/errors')\nconst util = require('../core/util')\nconst { ReadableStreamFrom } = require('../core/util')\n\nconst kConsume = Symbol('kConsume')\nconst kReading = Symbol('kReading')\nconst kBody = Symbol('kBody')\nconst kAbort = Symbol('kAbort')\nconst kContentType = Symbol('kContentType')\nconst kContentLength = Symbol('kContentLength')\n\nconst noop = () => {}\n\nclass BodyReadable extends Readable {\n  constructor ({\n    resume,\n    abort,\n    contentType = '',\n    contentLength,\n    highWaterMark = 64 * 1024 // Same as nodejs fs streams.\n  }) {\n    super({\n      autoDestroy: true,\n      read: resume,\n      highWaterMark\n    })\n\n    this._readableState.dataEmitted = false\n\n    this[kAbort] = abort\n    this[kConsume] = null\n    this[kBody] = null\n    this[kContentType] = contentType\n    this[kContentLength] = contentLength\n\n    // Is stream being consumed through Readable API?\n    // This is an optimization so that we avoid checking\n    // for 'data' and 'readable' listeners in the hot path\n    // inside push().\n    this[kReading] = false\n  }\n\n  destroy (err) {\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError()\n    }\n\n    if (err) {\n      this[kAbort]()\n    }\n\n    return super.destroy(err)\n  }\n\n  _destroy (err, callback) {\n    // Workaround for Node \"bug\". If the stream is destroyed in same\n    // tick as it is created, then a user who is waiting for a\n    // promise (i.e micro tick) for installing a 'error' listener will\n    // never get a chance and will always encounter an unhandled exception.\n    if (!this[kReading]) {\n      setImmediate(() => {\n        callback(err)\n      })\n    } else {\n      callback(err)\n    }\n  }\n\n  on (ev, ...args) {\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = true\n    }\n    return super.on(ev, ...args)\n  }\n\n  addListener (ev, ...args) {\n    return this.on(ev, ...args)\n  }\n\n  off (ev, ...args) {\n    const ret = super.off(ev, ...args)\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = (\n        this.listenerCount('data') > 0 ||\n        this.listenerCount('readable') > 0\n      )\n    }\n    return ret\n  }\n\n  removeListener (ev, ...args) {\n    return this.off(ev, ...args)\n  }\n\n  push (chunk) {\n    if (this[kConsume] && chunk !== null) {\n      consumePush(this[kConsume], chunk)\n      return this[kReading] ? super.push(chunk) : true\n    }\n    return super.push(chunk)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-text\n  async text () {\n    return consume(this, 'text')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-json\n  async json () {\n    return consume(this, 'json')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-blob\n  async blob () {\n    return consume(this, 'blob')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-arraybuffer\n  async arrayBuffer () {\n    return consume(this, 'arrayBuffer')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-formdata\n  async formData () {\n    // TODO: Implement.\n    throw new NotSupportedError()\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-bodyused\n  get bodyUsed () {\n    return util.isDisturbed(this)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-body\n  get body () {\n    if (!this[kBody]) {\n      this[kBody] = ReadableStreamFrom(this)\n      if (this[kConsume]) {\n        // TODO: Is this the best way to force a lock?\n        this[kBody].getReader() // Ensure stream is locked.\n        assert(this[kBody].locked)\n      }\n    }\n    return this[kBody]\n  }\n\n  async dump (opts) {\n    let limit = Number.isFinite(opts?.limit) ? opts.limit : 128 * 1024\n    const signal = opts?.signal\n\n    if (signal != null && (typeof signal !== 'object' || !('aborted' in signal))) {\n      throw new InvalidArgumentError('signal must be an AbortSignal')\n    }\n\n    signal?.throwIfAborted()\n\n    if (this._readableState.closeEmitted) {\n      return null\n    }\n\n    return await new Promise((resolve, reject) => {\n      if (this[kContentLength] > limit) {\n        this.destroy(new AbortError())\n      }\n\n      const onAbort = () => {\n        this.destroy(signal.reason ?? new AbortError())\n      }\n      signal?.addEventListener('abort', onAbort)\n\n      this\n        .on('close', function () {\n          signal?.removeEventListener('abort', onAbort)\n          if (signal?.aborted) {\n            reject(signal.reason ?? new AbortError())\n          } else {\n            resolve(null)\n          }\n        })\n        .on('error', noop)\n        .on('data', function (chunk) {\n          limit -= chunk.length\n          if (limit <= 0) {\n            this.destroy()\n          }\n        })\n        .resume()\n    })\n  }\n}\n\n// https://streams.spec.whatwg.org/#readablestream-locked\nfunction isLocked (self) {\n  // Consume is an implicit lock.\n  return (self[kBody] && self[kBody].locked === true) || self[kConsume]\n}\n\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction isUnusable (self) {\n  return util.isDisturbed(self) || isLocked(self)\n}\n\nasync function consume (stream, type) {\n  assert(!stream[kConsume])\n\n  return new Promise((resolve, reject) => {\n    if (isUnusable(stream)) {\n      const rState = stream._readableState\n      if (rState.destroyed && rState.closeEmitted === false) {\n        stream\n          .on('error', err => {\n            reject(err)\n          })\n          .on('close', () => {\n            reject(new TypeError('unusable'))\n          })\n      } else {\n        reject(rState.errored ?? new TypeError('unusable'))\n      }\n    } else {\n      queueMicrotask(() => {\n        stream[kConsume] = {\n          type,\n          stream,\n          resolve,\n          reject,\n          length: 0,\n          body: []\n        }\n\n        stream\n          .on('error', function (err) {\n            consumeFinish(this[kConsume], err)\n          })\n          .on('close', function () {\n            if (this[kConsume].body !== null) {\n              consumeFinish(this[kConsume], new RequestAbortedError())\n            }\n          })\n\n        consumeStart(stream[kConsume])\n      })\n    }\n  })\n}\n\nfunction consumeStart (consume) {\n  if (consume.body === null) {\n    return\n  }\n\n  const { _readableState: state } = consume.stream\n\n  if (state.bufferIndex) {\n    const start = state.bufferIndex\n    const end = state.buffer.length\n    for (let n = start; n < end; n++) {\n      consumePush(consume, state.buffer[n])\n    }\n  } else {\n    for (const chunk of state.buffer) {\n      consumePush(consume, chunk)\n    }\n  }\n\n  if (state.endEmitted) {\n    consumeEnd(this[kConsume])\n  } else {\n    consume.stream.on('end', function () {\n      consumeEnd(this[kConsume])\n    })\n  }\n\n  consume.stream.resume()\n\n  while (consume.stream.read() != null) {\n    // Loop\n  }\n}\n\n/**\n * @param {Buffer[]} chunks\n * @param {number} length\n */\nfunction chunksDecode (chunks, length) {\n  if (chunks.length === 0 || length === 0) {\n    return ''\n  }\n  const buffer = chunks.length === 1 ? chunks[0] : Buffer.concat(chunks, length)\n  const bufferLength = buffer.length\n\n  // Skip BOM.\n  const start =\n    bufferLength > 2 &&\n    buffer[0] === 0xef &&\n    buffer[1] === 0xbb &&\n    buffer[2] === 0xbf\n      ? 3\n      : 0\n  return buffer.utf8Slice(start, bufferLength)\n}\n\nfunction consumeEnd (consume) {\n  const { type, body, resolve, stream, length } = consume\n\n  try {\n    if (type === 'text') {\n      resolve(chunksDecode(body, length))\n    } else if (type === 'json') {\n      resolve(JSON.parse(chunksDecode(body, length)))\n    } else if (type === 'arrayBuffer') {\n      const dst = new Uint8Array(length)\n\n      let pos = 0\n      for (const buf of body) {\n        dst.set(buf, pos)\n        pos += buf.byteLength\n      }\n\n      resolve(dst.buffer)\n    } else if (type === 'blob') {\n      resolve(new Blob(body, { type: stream[kContentType] }))\n    }\n\n    consumeFinish(consume)\n  } catch (err) {\n    stream.destroy(err)\n  }\n}\n\nfunction consumePush (consume, chunk) {\n  consume.length += chunk.length\n  consume.body.push(chunk)\n}\n\nfunction consumeFinish (consume, err) {\n  if (consume.body === null) {\n    return\n  }\n\n  if (err) {\n    consume.reject(err)\n  } else {\n    consume.resolve()\n  }\n\n  consume.type = null\n  consume.stream = null\n  consume.resolve = null\n  consume.reject = null\n  consume.length = 0\n  consume.body = null\n}\n\nmodule.exports = { Readable: BodyReadable, chunksDecode }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
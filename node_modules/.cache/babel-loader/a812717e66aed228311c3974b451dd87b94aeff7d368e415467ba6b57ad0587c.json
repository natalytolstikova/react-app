{"ast":null,"code":"'use strict';\n\nconst assert = require('node:assert');\nconst {\n  kRetryHandlerDefaultRetry\n} = require('../core/symbols');\nconst {\n  RequestRetryError\n} = require('../core/errors');\nconst {\n  isDisturbed,\n  parseHeaders,\n  parseRangeHeader,\n  wrapRequestBody\n} = require('../core/util');\nfunction calculateRetryAfterHeader(retryAfter) {\n  const current = Date.now();\n  return new Date(retryAfter).getTime() - current;\n}\nclass RetryHandler {\n  constructor(opts, handlers) {\n    const {\n      retryOptions,\n      ...dispatchOpts\n    } = opts;\n    const {\n      // Retry scoped\n      retry: retryFn,\n      maxRetries,\n      maxTimeout,\n      minTimeout,\n      timeoutFactor,\n      // Response scoped\n      methods,\n      errorCodes,\n      retryAfter,\n      statusCodes\n    } = retryOptions ?? {};\n    this.dispatch = handlers.dispatch;\n    this.handler = handlers.handler;\n    this.opts = {\n      ...dispatchOpts,\n      body: wrapRequestBody(opts.body)\n    };\n    this.abort = null;\n    this.aborted = false;\n    this.retryOpts = {\n      retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],\n      retryAfter: retryAfter ?? true,\n      maxTimeout: maxTimeout ?? 30 * 1000,\n      // 30s,\n      minTimeout: minTimeout ?? 500,\n      // .5s\n      timeoutFactor: timeoutFactor ?? 2,\n      maxRetries: maxRetries ?? 5,\n      // What errors we should retry\n      methods: methods ?? ['GET', 'HEAD', 'OPTIONS', 'PUT', 'DELETE', 'TRACE'],\n      // Indicates which errors to retry\n      statusCodes: statusCodes ?? [500, 502, 503, 504, 429],\n      // List of errors to retry\n      errorCodes: errorCodes ?? ['ECONNRESET', 'ECONNREFUSED', 'ENOTFOUND', 'ENETDOWN', 'ENETUNREACH', 'EHOSTDOWN', 'EHOSTUNREACH', 'EPIPE', 'UND_ERR_SOCKET']\n    };\n    this.retryCount = 0;\n    this.retryCountCheckpoint = 0;\n    this.start = 0;\n    this.end = null;\n    this.etag = null;\n    this.resume = null;\n\n    // Handle possible onConnect duplication\n    this.handler.onConnect(reason => {\n      this.aborted = true;\n      if (this.abort) {\n        this.abort(reason);\n      } else {\n        this.reason = reason;\n      }\n    });\n  }\n  onRequestSent() {\n    if (this.handler.onRequestSent) {\n      this.handler.onRequestSent();\n    }\n  }\n  onUpgrade(statusCode, headers, socket) {\n    if (this.handler.onUpgrade) {\n      this.handler.onUpgrade(statusCode, headers, socket);\n    }\n  }\n  onConnect(abort) {\n    if (this.aborted) {\n      abort(this.reason);\n    } else {\n      this.abort = abort;\n    }\n  }\n  onBodySent(chunk) {\n    if (this.handler.onBodySent) return this.handler.onBodySent(chunk);\n  }\n  static [kRetryHandlerDefaultRetry](err, {\n    state,\n    opts\n  }, cb) {\n    const {\n      statusCode,\n      code,\n      headers\n    } = err;\n    const {\n      method,\n      retryOptions\n    } = opts;\n    const {\n      maxRetries,\n      minTimeout,\n      maxTimeout,\n      timeoutFactor,\n      statusCodes,\n      errorCodes,\n      methods\n    } = retryOptions;\n    const {\n      counter\n    } = state;\n\n    // Any code that is not a Undici's originated and allowed to retry\n    if (code && code !== 'UND_ERR_REQ_RETRY' && !errorCodes.includes(code)) {\n      cb(err);\n      return;\n    }\n\n    // If a set of method are provided and the current method is not in the list\n    if (Array.isArray(methods) && !methods.includes(method)) {\n      cb(err);\n      return;\n    }\n\n    // If a set of status code are provided and the current status code is not in the list\n    if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {\n      cb(err);\n      return;\n    }\n\n    // If we reached the max number of retries\n    if (counter > maxRetries) {\n      cb(err);\n      return;\n    }\n    let retryAfterHeader = headers?.['retry-after'];\n    if (retryAfterHeader) {\n      retryAfterHeader = Number(retryAfterHeader);\n      retryAfterHeader = Number.isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1e3; // Retry-After is in seconds\n    }\n    const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(minTimeout * timeoutFactor ** (counter - 1), maxTimeout);\n    setTimeout(() => cb(null), retryTimeout);\n  }\n  onHeaders(statusCode, rawHeaders, resume, statusMessage) {\n    const headers = parseHeaders(rawHeaders);\n    this.retryCount += 1;\n    if (statusCode >= 300) {\n      if (this.retryOpts.statusCodes.includes(statusCode) === false) {\n        return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);\n      } else {\n        this.abort(new RequestRetryError('Request failed', statusCode, {\n          headers,\n          data: {\n            count: this.retryCount\n          }\n        }));\n        return false;\n      }\n    }\n\n    // Checkpoint for resume from where we left it\n    if (this.resume != null) {\n      this.resume = null;\n      if (statusCode !== 206) {\n        return true;\n      }\n      const contentRange = parseRangeHeader(headers['content-range']);\n      // If no content range\n      if (!contentRange) {\n        this.abort(new RequestRetryError('Content-Range mismatch', statusCode, {\n          headers,\n          data: {\n            count: this.retryCount\n          }\n        }));\n        return false;\n      }\n\n      // Let's start with a weak etag check\n      if (this.etag != null && this.etag !== headers.etag) {\n        this.abort(new RequestRetryError('ETag mismatch', statusCode, {\n          headers,\n          data: {\n            count: this.retryCount\n          }\n        }));\n        return false;\n      }\n      const {\n        start,\n        size,\n        end = size\n      } = contentRange;\n      assert(this.start === start, 'content-range mismatch');\n      assert(this.end == null || this.end === end, 'content-range mismatch');\n      this.resume = resume;\n      return true;\n    }\n    if (this.end == null) {\n      if (statusCode === 206) {\n        // First time we receive 206\n        const range = parseRangeHeader(headers['content-range']);\n        if (range == null) {\n          return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);\n        }\n        const {\n          start,\n          size,\n          end = size\n        } = range;\n        assert(start != null && Number.isFinite(start), 'content-range mismatch');\n        assert(end != null && Number.isFinite(end), 'invalid content-length');\n        this.start = start;\n        this.end = end;\n      }\n\n      // We make our best to checkpoint the body for further range headers\n      if (this.end == null) {\n        const contentLength = headers['content-length'];\n        this.end = contentLength != null ? Number(contentLength) : null;\n      }\n      assert(Number.isFinite(this.start));\n      assert(this.end == null || Number.isFinite(this.end), 'invalid content-length');\n      this.resume = resume;\n      this.etag = headers.etag != null ? headers.etag : null;\n\n      // Weak etags are not useful for comparison nor cache\n      // for instance not safe to assume if the response is byte-per-byte\n      // equal\n      if (this.etag != null && this.etag.startsWith('W/')) {\n        this.etag = null;\n      }\n      return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);\n    }\n    const err = new RequestRetryError('Request failed', statusCode, {\n      headers,\n      data: {\n        count: this.retryCount\n      }\n    });\n    this.abort(err);\n    return false;\n  }\n  onData(chunk) {\n    this.start += chunk.length;\n    return this.handler.onData(chunk);\n  }\n  onComplete(rawTrailers) {\n    this.retryCount = 0;\n    return this.handler.onComplete(rawTrailers);\n  }\n  onError(err) {\n    if (this.aborted || isDisturbed(this.opts.body)) {\n      return this.handler.onError(err);\n    }\n\n    // We reconcile in case of a mix between network errors\n    // and server error response\n    if (this.retryCount - this.retryCountCheckpoint > 0) {\n      // We count the difference between the last checkpoint and the current retry count\n      this.retryCount = this.retryCountCheckpoint + (this.retryCount - this.retryCountCheckpoint);\n    } else {\n      this.retryCount += 1;\n    }\n    this.retryOpts.retry(err, {\n      state: {\n        counter: this.retryCount\n      },\n      opts: {\n        retryOptions: this.retryOpts,\n        ...this.opts\n      }\n    }, onRetry.bind(this));\n    function onRetry(err) {\n      if (err != null || this.aborted || isDisturbed(this.opts.body)) {\n        return this.handler.onError(err);\n      }\n      if (this.start !== 0) {\n        const headers = {\n          range: `bytes=${this.start}-${this.end ?? ''}`\n        };\n\n        // Weak etag check - weak etags will make comparison algorithms never match\n        if (this.etag != null) {\n          headers['if-match'] = this.etag;\n        }\n        this.opts = {\n          ...this.opts,\n          headers: {\n            ...this.opts.headers,\n            ...headers\n          }\n        };\n      }\n      try {\n        this.retryCountCheckpoint = this.retryCount;\n        this.dispatch(this.opts, this);\n      } catch (err) {\n        this.handler.onError(err);\n      }\n    }\n  }\n}\nmodule.exports = RetryHandler;","map":{"version":3,"names":["assert","require","kRetryHandlerDefaultRetry","RequestRetryError","isDisturbed","parseHeaders","parseRangeHeader","wrapRequestBody","calculateRetryAfterHeader","retryAfter","current","Date","now","getTime","RetryHandler","constructor","opts","handlers","retryOptions","dispatchOpts","retry","retryFn","maxRetries","maxTimeout","minTimeout","timeoutFactor","methods","errorCodes","statusCodes","dispatch","handler","body","abort","aborted","retryOpts","retryCount","retryCountCheckpoint","start","end","etag","resume","onConnect","reason","onRequestSent","onUpgrade","statusCode","headers","socket","onBodySent","chunk","err","state","cb","code","method","counter","includes","Array","isArray","retryAfterHeader","Number","isNaN","retryTimeout","Math","min","setTimeout","onHeaders","rawHeaders","statusMessage","data","count","contentRange","size","range","isFinite","contentLength","startsWith","onData","length","onComplete","rawTrailers","onError","onRetry","bind","module","exports"],"sources":["/Users/nataliia/PussyProjects/react-app/node_modules/undici/lib/handler/retry-handler.js"],"sourcesContent":["'use strict'\nconst assert = require('node:assert')\n\nconst { kRetryHandlerDefaultRetry } = require('../core/symbols')\nconst { RequestRetryError } = require('../core/errors')\nconst {\n  isDisturbed,\n  parseHeaders,\n  parseRangeHeader,\n  wrapRequestBody\n} = require('../core/util')\n\nfunction calculateRetryAfterHeader (retryAfter) {\n  const current = Date.now()\n  return new Date(retryAfter).getTime() - current\n}\n\nclass RetryHandler {\n  constructor (opts, handlers) {\n    const { retryOptions, ...dispatchOpts } = opts\n    const {\n      // Retry scoped\n      retry: retryFn,\n      maxRetries,\n      maxTimeout,\n      minTimeout,\n      timeoutFactor,\n      // Response scoped\n      methods,\n      errorCodes,\n      retryAfter,\n      statusCodes\n    } = retryOptions ?? {}\n\n    this.dispatch = handlers.dispatch\n    this.handler = handlers.handler\n    this.opts = { ...dispatchOpts, body: wrapRequestBody(opts.body) }\n    this.abort = null\n    this.aborted = false\n    this.retryOpts = {\n      retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],\n      retryAfter: retryAfter ?? true,\n      maxTimeout: maxTimeout ?? 30 * 1000, // 30s,\n      minTimeout: minTimeout ?? 500, // .5s\n      timeoutFactor: timeoutFactor ?? 2,\n      maxRetries: maxRetries ?? 5,\n      // What errors we should retry\n      methods: methods ?? ['GET', 'HEAD', 'OPTIONS', 'PUT', 'DELETE', 'TRACE'],\n      // Indicates which errors to retry\n      statusCodes: statusCodes ?? [500, 502, 503, 504, 429],\n      // List of errors to retry\n      errorCodes: errorCodes ?? [\n        'ECONNRESET',\n        'ECONNREFUSED',\n        'ENOTFOUND',\n        'ENETDOWN',\n        'ENETUNREACH',\n        'EHOSTDOWN',\n        'EHOSTUNREACH',\n        'EPIPE',\n        'UND_ERR_SOCKET'\n      ]\n    }\n\n    this.retryCount = 0\n    this.retryCountCheckpoint = 0\n    this.start = 0\n    this.end = null\n    this.etag = null\n    this.resume = null\n\n    // Handle possible onConnect duplication\n    this.handler.onConnect(reason => {\n      this.aborted = true\n      if (this.abort) {\n        this.abort(reason)\n      } else {\n        this.reason = reason\n      }\n    })\n  }\n\n  onRequestSent () {\n    if (this.handler.onRequestSent) {\n      this.handler.onRequestSent()\n    }\n  }\n\n  onUpgrade (statusCode, headers, socket) {\n    if (this.handler.onUpgrade) {\n      this.handler.onUpgrade(statusCode, headers, socket)\n    }\n  }\n\n  onConnect (abort) {\n    if (this.aborted) {\n      abort(this.reason)\n    } else {\n      this.abort = abort\n    }\n  }\n\n  onBodySent (chunk) {\n    if (this.handler.onBodySent) return this.handler.onBodySent(chunk)\n  }\n\n  static [kRetryHandlerDefaultRetry] (err, { state, opts }, cb) {\n    const { statusCode, code, headers } = err\n    const { method, retryOptions } = opts\n    const {\n      maxRetries,\n      minTimeout,\n      maxTimeout,\n      timeoutFactor,\n      statusCodes,\n      errorCodes,\n      methods\n    } = retryOptions\n    const { counter } = state\n\n    // Any code that is not a Undici's originated and allowed to retry\n    if (code && code !== 'UND_ERR_REQ_RETRY' && !errorCodes.includes(code)) {\n      cb(err)\n      return\n    }\n\n    // If a set of method are provided and the current method is not in the list\n    if (Array.isArray(methods) && !methods.includes(method)) {\n      cb(err)\n      return\n    }\n\n    // If a set of status code are provided and the current status code is not in the list\n    if (\n      statusCode != null &&\n      Array.isArray(statusCodes) &&\n      !statusCodes.includes(statusCode)\n    ) {\n      cb(err)\n      return\n    }\n\n    // If we reached the max number of retries\n    if (counter > maxRetries) {\n      cb(err)\n      return\n    }\n\n    let retryAfterHeader = headers?.['retry-after']\n    if (retryAfterHeader) {\n      retryAfterHeader = Number(retryAfterHeader)\n      retryAfterHeader = Number.isNaN(retryAfterHeader)\n        ? calculateRetryAfterHeader(retryAfterHeader)\n        : retryAfterHeader * 1e3 // Retry-After is in seconds\n    }\n\n    const retryTimeout =\n      retryAfterHeader > 0\n        ? Math.min(retryAfterHeader, maxTimeout)\n        : Math.min(minTimeout * timeoutFactor ** (counter - 1), maxTimeout)\n\n    setTimeout(() => cb(null), retryTimeout)\n  }\n\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    const headers = parseHeaders(rawHeaders)\n\n    this.retryCount += 1\n\n    if (statusCode >= 300) {\n      if (this.retryOpts.statusCodes.includes(statusCode) === false) {\n        return this.handler.onHeaders(\n          statusCode,\n          rawHeaders,\n          resume,\n          statusMessage\n        )\n      } else {\n        this.abort(\n          new RequestRetryError('Request failed', statusCode, {\n            headers,\n            data: {\n              count: this.retryCount\n            }\n          })\n        )\n        return false\n      }\n    }\n\n    // Checkpoint for resume from where we left it\n    if (this.resume != null) {\n      this.resume = null\n\n      if (statusCode !== 206) {\n        return true\n      }\n\n      const contentRange = parseRangeHeader(headers['content-range'])\n      // If no content range\n      if (!contentRange) {\n        this.abort(\n          new RequestRetryError('Content-Range mismatch', statusCode, {\n            headers,\n            data: { count: this.retryCount }\n          })\n        )\n        return false\n      }\n\n      // Let's start with a weak etag check\n      if (this.etag != null && this.etag !== headers.etag) {\n        this.abort(\n          new RequestRetryError('ETag mismatch', statusCode, {\n            headers,\n            data: { count: this.retryCount }\n          })\n        )\n        return false\n      }\n\n      const { start, size, end = size } = contentRange\n\n      assert(this.start === start, 'content-range mismatch')\n      assert(this.end == null || this.end === end, 'content-range mismatch')\n\n      this.resume = resume\n      return true\n    }\n\n    if (this.end == null) {\n      if (statusCode === 206) {\n        // First time we receive 206\n        const range = parseRangeHeader(headers['content-range'])\n\n        if (range == null) {\n          return this.handler.onHeaders(\n            statusCode,\n            rawHeaders,\n            resume,\n            statusMessage\n          )\n        }\n\n        const { start, size, end = size } = range\n        assert(\n          start != null && Number.isFinite(start),\n          'content-range mismatch'\n        )\n        assert(end != null && Number.isFinite(end), 'invalid content-length')\n\n        this.start = start\n        this.end = end\n      }\n\n      // We make our best to checkpoint the body for further range headers\n      if (this.end == null) {\n        const contentLength = headers['content-length']\n        this.end = contentLength != null ? Number(contentLength) : null\n      }\n\n      assert(Number.isFinite(this.start))\n      assert(\n        this.end == null || Number.isFinite(this.end),\n        'invalid content-length'\n      )\n\n      this.resume = resume\n      this.etag = headers.etag != null ? headers.etag : null\n\n      // Weak etags are not useful for comparison nor cache\n      // for instance not safe to assume if the response is byte-per-byte\n      // equal\n      if (this.etag != null && this.etag.startsWith('W/')) {\n        this.etag = null\n      }\n\n      return this.handler.onHeaders(\n        statusCode,\n        rawHeaders,\n        resume,\n        statusMessage\n      )\n    }\n\n    const err = new RequestRetryError('Request failed', statusCode, {\n      headers,\n      data: { count: this.retryCount }\n    })\n\n    this.abort(err)\n\n    return false\n  }\n\n  onData (chunk) {\n    this.start += chunk.length\n\n    return this.handler.onData(chunk)\n  }\n\n  onComplete (rawTrailers) {\n    this.retryCount = 0\n    return this.handler.onComplete(rawTrailers)\n  }\n\n  onError (err) {\n    if (this.aborted || isDisturbed(this.opts.body)) {\n      return this.handler.onError(err)\n    }\n\n    // We reconcile in case of a mix between network errors\n    // and server error response\n    if (this.retryCount - this.retryCountCheckpoint > 0) {\n      // We count the difference between the last checkpoint and the current retry count\n      this.retryCount =\n        this.retryCountCheckpoint +\n        (this.retryCount - this.retryCountCheckpoint)\n    } else {\n      this.retryCount += 1\n    }\n\n    this.retryOpts.retry(\n      err,\n      {\n        state: { counter: this.retryCount },\n        opts: { retryOptions: this.retryOpts, ...this.opts }\n      },\n      onRetry.bind(this)\n    )\n\n    function onRetry (err) {\n      if (err != null || this.aborted || isDisturbed(this.opts.body)) {\n        return this.handler.onError(err)\n      }\n\n      if (this.start !== 0) {\n        const headers = { range: `bytes=${this.start}-${this.end ?? ''}` }\n\n        // Weak etag check - weak etags will make comparison algorithms never match\n        if (this.etag != null) {\n          headers['if-match'] = this.etag\n        }\n\n        this.opts = {\n          ...this.opts,\n          headers: {\n            ...this.opts.headers,\n            ...headers\n          }\n        }\n      }\n\n      try {\n        this.retryCountCheckpoint = this.retryCount\n        this.dispatch(this.opts, this)\n      } catch (err) {\n        this.handler.onError(err)\n      }\n    }\n  }\n}\n\nmodule.exports = RetryHandler\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
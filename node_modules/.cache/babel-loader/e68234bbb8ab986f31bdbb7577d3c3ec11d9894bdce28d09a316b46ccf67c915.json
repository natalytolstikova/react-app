{"ast":null,"code":"'use strict';\n\nconst {\n  BalancedPoolMissingUpstreamError,\n  InvalidArgumentError\n} = require('../core/errors');\nconst {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kRemoveClient,\n  kGetDispatcher\n} = require('./pool-base');\nconst Pool = require('./pool');\nconst {\n  kUrl,\n  kInterceptors\n} = require('../core/symbols');\nconst {\n  parseOrigin\n} = require('../core/util');\nconst kFactory = Symbol('factory');\nconst kOptions = Symbol('options');\nconst kGreatestCommonDivisor = Symbol('kGreatestCommonDivisor');\nconst kCurrentWeight = Symbol('kCurrentWeight');\nconst kIndex = Symbol('kIndex');\nconst kWeight = Symbol('kWeight');\nconst kMaxWeightPerServer = Symbol('kMaxWeightPerServer');\nconst kErrorPenalty = Symbol('kErrorPenalty');\n\n/**\n * Calculate the greatest common divisor of two numbers by\n * using the Euclidean algorithm.\n *\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction getGreatestCommonDivisor(a, b) {\n  if (a === 0) return b;\n  while (b !== 0) {\n    const t = b;\n    b = a % b;\n    a = t;\n  }\n  return a;\n}\nfunction defaultFactory(origin, opts) {\n  return new Pool(origin, opts);\n}\nclass BalancedPool extends PoolBase {\n  constructor(upstreams = [], {\n    factory = defaultFactory,\n    ...opts\n  } = {}) {\n    super();\n    this[kOptions] = opts;\n    this[kIndex] = -1;\n    this[kCurrentWeight] = 0;\n    this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;\n    this[kErrorPenalty] = this[kOptions].errorPenalty || 15;\n    if (!Array.isArray(upstreams)) {\n      upstreams = [upstreams];\n    }\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.');\n    }\n    this[kInterceptors] = opts.interceptors?.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];\n    this[kFactory] = factory;\n    for (const upstream of upstreams) {\n      this.addUpstream(upstream);\n    }\n    this._updateBalancedPoolStats();\n  }\n  addUpstream(upstream) {\n    const upstreamOrigin = parseOrigin(upstream).origin;\n    if (this[kClients].find(pool => pool[kUrl].origin === upstreamOrigin && pool.closed !== true && pool.destroyed !== true)) {\n      return this;\n    }\n    const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));\n    this[kAddClient](pool);\n    pool.on('connect', () => {\n      pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);\n    });\n    pool.on('connectionError', () => {\n      pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);\n      this._updateBalancedPoolStats();\n    });\n    pool.on('disconnect', (...args) => {\n      const err = args[2];\n      if (err && err.code === 'UND_ERR_SOCKET') {\n        // decrease the weight of the pool.\n        pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);\n        this._updateBalancedPoolStats();\n      }\n    });\n    for (const client of this[kClients]) {\n      client[kWeight] = this[kMaxWeightPerServer];\n    }\n    this._updateBalancedPoolStats();\n    return this;\n  }\n  _updateBalancedPoolStats() {\n    let result = 0;\n    for (let i = 0; i < this[kClients].length; i++) {\n      result = getGreatestCommonDivisor(this[kClients][i][kWeight], result);\n    }\n    this[kGreatestCommonDivisor] = result;\n  }\n  removeUpstream(upstream) {\n    const upstreamOrigin = parseOrigin(upstream).origin;\n    const pool = this[kClients].find(pool => pool[kUrl].origin === upstreamOrigin && pool.closed !== true && pool.destroyed !== true);\n    if (pool) {\n      this[kRemoveClient](pool);\n    }\n    return this;\n  }\n  get upstreams() {\n    return this[kClients].filter(dispatcher => dispatcher.closed !== true && dispatcher.destroyed !== true).map(p => p[kUrl].origin);\n  }\n  [kGetDispatcher]() {\n    // We validate that pools is greater than 0,\n    // otherwise we would have to wait until an upstream\n    // is added, which might never happen.\n    if (this[kClients].length === 0) {\n      throw new BalancedPoolMissingUpstreamError();\n    }\n    const dispatcher = this[kClients].find(dispatcher => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);\n    if (!dispatcher) {\n      return;\n    }\n    const allClientsBusy = this[kClients].map(pool => pool[kNeedDrain]).reduce((a, b) => a && b, true);\n    if (allClientsBusy) {\n      return;\n    }\n    let counter = 0;\n    let maxWeightIndex = this[kClients].findIndex(pool => !pool[kNeedDrain]);\n    while (counter++ < this[kClients].length) {\n      this[kIndex] = (this[kIndex] + 1) % this[kClients].length;\n      const pool = this[kClients][this[kIndex]];\n\n      // find pool index with the largest weight\n      if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {\n        maxWeightIndex = this[kIndex];\n      }\n\n      // decrease the current weight every `this[kClients].length`.\n      if (this[kIndex] === 0) {\n        // Set the current weight to the next lower weight.\n        this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];\n        if (this[kCurrentWeight] <= 0) {\n          this[kCurrentWeight] = this[kMaxWeightPerServer];\n        }\n      }\n      if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {\n        return pool;\n      }\n    }\n    this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];\n    this[kIndex] = maxWeightIndex;\n    return this[kClients][maxWeightIndex];\n  }\n}\nmodule.exports = BalancedPool;","map":{"version":3,"names":["BalancedPoolMissingUpstreamError","InvalidArgumentError","require","PoolBase","kClients","kNeedDrain","kAddClient","kRemoveClient","kGetDispatcher","Pool","kUrl","kInterceptors","parseOrigin","kFactory","Symbol","kOptions","kGreatestCommonDivisor","kCurrentWeight","kIndex","kWeight","kMaxWeightPerServer","kErrorPenalty","getGreatestCommonDivisor","a","b","t","defaultFactory","origin","opts","BalancedPool","constructor","upstreams","factory","maxWeightPerServer","errorPenalty","Array","isArray","interceptors","upstream","addUpstream","_updateBalancedPoolStats","upstreamOrigin","find","pool","closed","destroyed","Object","assign","on","Math","min","max","args","err","code","client","result","i","length","removeUpstream","filter","dispatcher","map","p","allClientsBusy","reduce","counter","maxWeightIndex","findIndex","module","exports"],"sources":["/Users/nataliia/PussyProjects/react-app/node_modules/undici/lib/dispatcher/balanced-pool.js"],"sourcesContent":["'use strict'\n\nconst {\n  BalancedPoolMissingUpstreamError,\n  InvalidArgumentError\n} = require('../core/errors')\nconst {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kRemoveClient,\n  kGetDispatcher\n} = require('./pool-base')\nconst Pool = require('./pool')\nconst { kUrl, kInterceptors } = require('../core/symbols')\nconst { parseOrigin } = require('../core/util')\nconst kFactory = Symbol('factory')\n\nconst kOptions = Symbol('options')\nconst kGreatestCommonDivisor = Symbol('kGreatestCommonDivisor')\nconst kCurrentWeight = Symbol('kCurrentWeight')\nconst kIndex = Symbol('kIndex')\nconst kWeight = Symbol('kWeight')\nconst kMaxWeightPerServer = Symbol('kMaxWeightPerServer')\nconst kErrorPenalty = Symbol('kErrorPenalty')\n\n/**\n * Calculate the greatest common divisor of two numbers by\n * using the Euclidean algorithm.\n *\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction getGreatestCommonDivisor (a, b) {\n  if (a === 0) return b\n\n  while (b !== 0) {\n    const t = b\n    b = a % b\n    a = t\n  }\n  return a\n}\n\nfunction defaultFactory (origin, opts) {\n  return new Pool(origin, opts)\n}\n\nclass BalancedPool extends PoolBase {\n  constructor (upstreams = [], { factory = defaultFactory, ...opts } = {}) {\n    super()\n\n    this[kOptions] = opts\n    this[kIndex] = -1\n    this[kCurrentWeight] = 0\n\n    this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100\n    this[kErrorPenalty] = this[kOptions].errorPenalty || 15\n\n    if (!Array.isArray(upstreams)) {\n      upstreams = [upstreams]\n    }\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    this[kInterceptors] = opts.interceptors?.BalancedPool && Array.isArray(opts.interceptors.BalancedPool)\n      ? opts.interceptors.BalancedPool\n      : []\n    this[kFactory] = factory\n\n    for (const upstream of upstreams) {\n      this.addUpstream(upstream)\n    }\n    this._updateBalancedPoolStats()\n  }\n\n  addUpstream (upstream) {\n    const upstreamOrigin = parseOrigin(upstream).origin\n\n    if (this[kClients].find((pool) => (\n      pool[kUrl].origin === upstreamOrigin &&\n      pool.closed !== true &&\n      pool.destroyed !== true\n    ))) {\n      return this\n    }\n    const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]))\n\n    this[kAddClient](pool)\n    pool.on('connect', () => {\n      pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty])\n    })\n\n    pool.on('connectionError', () => {\n      pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty])\n      this._updateBalancedPoolStats()\n    })\n\n    pool.on('disconnect', (...args) => {\n      const err = args[2]\n      if (err && err.code === 'UND_ERR_SOCKET') {\n        // decrease the weight of the pool.\n        pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty])\n        this._updateBalancedPoolStats()\n      }\n    })\n\n    for (const client of this[kClients]) {\n      client[kWeight] = this[kMaxWeightPerServer]\n    }\n\n    this._updateBalancedPoolStats()\n\n    return this\n  }\n\n  _updateBalancedPoolStats () {\n    let result = 0\n    for (let i = 0; i < this[kClients].length; i++) {\n      result = getGreatestCommonDivisor(this[kClients][i][kWeight], result)\n    }\n\n    this[kGreatestCommonDivisor] = result\n  }\n\n  removeUpstream (upstream) {\n    const upstreamOrigin = parseOrigin(upstream).origin\n\n    const pool = this[kClients].find((pool) => (\n      pool[kUrl].origin === upstreamOrigin &&\n      pool.closed !== true &&\n      pool.destroyed !== true\n    ))\n\n    if (pool) {\n      this[kRemoveClient](pool)\n    }\n\n    return this\n  }\n\n  get upstreams () {\n    return this[kClients]\n      .filter(dispatcher => dispatcher.closed !== true && dispatcher.destroyed !== true)\n      .map((p) => p[kUrl].origin)\n  }\n\n  [kGetDispatcher] () {\n    // We validate that pools is greater than 0,\n    // otherwise we would have to wait until an upstream\n    // is added, which might never happen.\n    if (this[kClients].length === 0) {\n      throw new BalancedPoolMissingUpstreamError()\n    }\n\n    const dispatcher = this[kClients].find(dispatcher => (\n      !dispatcher[kNeedDrain] &&\n      dispatcher.closed !== true &&\n      dispatcher.destroyed !== true\n    ))\n\n    if (!dispatcher) {\n      return\n    }\n\n    const allClientsBusy = this[kClients].map(pool => pool[kNeedDrain]).reduce((a, b) => a && b, true)\n\n    if (allClientsBusy) {\n      return\n    }\n\n    let counter = 0\n\n    let maxWeightIndex = this[kClients].findIndex(pool => !pool[kNeedDrain])\n\n    while (counter++ < this[kClients].length) {\n      this[kIndex] = (this[kIndex] + 1) % this[kClients].length\n      const pool = this[kClients][this[kIndex]]\n\n      // find pool index with the largest weight\n      if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {\n        maxWeightIndex = this[kIndex]\n      }\n\n      // decrease the current weight every `this[kClients].length`.\n      if (this[kIndex] === 0) {\n        // Set the current weight to the next lower weight.\n        this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor]\n\n        if (this[kCurrentWeight] <= 0) {\n          this[kCurrentWeight] = this[kMaxWeightPerServer]\n        }\n      }\n      if (pool[kWeight] >= this[kCurrentWeight] && (!pool[kNeedDrain])) {\n        return pool\n      }\n    }\n\n    this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight]\n    this[kIndex] = maxWeightIndex\n    return this[kClients][maxWeightIndex]\n  }\n}\n\nmodule.exports = BalancedPool\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
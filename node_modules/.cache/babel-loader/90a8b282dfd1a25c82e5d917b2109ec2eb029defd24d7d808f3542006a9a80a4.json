{"ast":null,"code":"'use strict';\n\nconst assert = require('node:assert');\nconst {\n  Readable\n} = require('./readable');\nconst {\n  InvalidArgumentError,\n  RequestAbortedError\n} = require('../core/errors');\nconst util = require('../core/util');\nconst {\n  getResolveErrorBodyCallback\n} = require('./util');\nconst {\n  AsyncResource\n} = require('node:async_hooks');\nclass RequestHandler extends AsyncResource {\n  constructor(opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts');\n    }\n    const {\n      signal,\n      method,\n      opaque,\n      body,\n      onInfo,\n      responseHeaders,\n      throwOnError,\n      highWaterMark\n    } = opts;\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback');\n      }\n      if (highWaterMark && (typeof highWaterMark !== 'number' || highWaterMark < 0)) {\n        throw new InvalidArgumentError('invalid highWaterMark');\n      }\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');\n      }\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method');\n      }\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback');\n      }\n      super('UNDICI_REQUEST');\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err);\n      }\n      throw err;\n    }\n    this.method = method;\n    this.responseHeaders = responseHeaders || null;\n    this.opaque = opaque || null;\n    this.callback = callback;\n    this.res = null;\n    this.abort = null;\n    this.body = body;\n    this.trailers = {};\n    this.context = null;\n    this.onInfo = onInfo || null;\n    this.throwOnError = throwOnError;\n    this.highWaterMark = highWaterMark;\n    this.signal = signal;\n    this.reason = null;\n    this.removeAbortListener = null;\n    if (util.isStream(body)) {\n      body.on('error', err => {\n        this.onError(err);\n      });\n    }\n    if (this.signal) {\n      if (this.signal.aborted) {\n        this.reason = this.signal.reason ?? new RequestAbortedError();\n      } else {\n        this.removeAbortListener = util.addAbortListener(this.signal, () => {\n          this.reason = this.signal.reason ?? new RequestAbortedError();\n          if (this.res) {\n            util.destroy(this.res, this.reason);\n          } else if (this.abort) {\n            this.abort(this.reason);\n          }\n          if (this.removeAbortListener) {\n            this.res?.off('close', this.removeAbortListener);\n            this.removeAbortListener();\n            this.removeAbortListener = null;\n          }\n        });\n      }\n    }\n  }\n  onConnect(abort, context) {\n    if (this.reason) {\n      abort(this.reason);\n      return;\n    }\n    assert(this.callback);\n    this.abort = abort;\n    this.context = context;\n  }\n  onHeaders(statusCode, rawHeaders, resume, statusMessage) {\n    const {\n      callback,\n      opaque,\n      abort,\n      context,\n      responseHeaders,\n      highWaterMark\n    } = this;\n    const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        this.onInfo({\n          statusCode,\n          headers\n        });\n      }\n      return;\n    }\n    const parsedHeaders = responseHeaders === 'raw' ? util.parseHeaders(rawHeaders) : headers;\n    const contentType = parsedHeaders['content-type'];\n    const contentLength = parsedHeaders['content-length'];\n    const res = new Readable({\n      resume,\n      abort,\n      contentType,\n      contentLength: this.method !== 'HEAD' && contentLength ? Number(contentLength) : null,\n      highWaterMark\n    });\n    if (this.removeAbortListener) {\n      res.on('close', this.removeAbortListener);\n    }\n    this.callback = null;\n    this.res = res;\n    if (callback !== null) {\n      if (this.throwOnError && statusCode >= 400) {\n        this.runInAsyncScope(getResolveErrorBodyCallback, null, {\n          callback,\n          body: res,\n          contentType,\n          statusCode,\n          statusMessage,\n          headers\n        });\n      } else {\n        this.runInAsyncScope(callback, null, null, {\n          statusCode,\n          headers,\n          trailers: this.trailers,\n          opaque,\n          body: res,\n          context\n        });\n      }\n    }\n  }\n  onData(chunk) {\n    return this.res.push(chunk);\n  }\n  onComplete(trailers) {\n    util.parseHeaders(trailers, this.trailers);\n    this.res.push(null);\n  }\n  onError(err) {\n    const {\n      res,\n      callback,\n      body,\n      opaque\n    } = this;\n    if (callback) {\n      // TODO: Does this need queueMicrotask?\n      this.callback = null;\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, {\n          opaque\n        });\n      });\n    }\n    if (res) {\n      this.res = null;\n      // Ensure all queued handlers are invoked before destroying res.\n      queueMicrotask(() => {\n        util.destroy(res, err);\n      });\n    }\n    if (body) {\n      this.body = null;\n      util.destroy(body, err);\n    }\n    if (this.removeAbortListener) {\n      res?.off('close', this.removeAbortListener);\n      this.removeAbortListener();\n      this.removeAbortListener = null;\n    }\n  }\n}\nfunction request(opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      request.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data);\n      });\n    });\n  }\n  try {\n    this.dispatch(opts, new RequestHandler(opts, callback));\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err;\n    }\n    const opaque = opts?.opaque;\n    queueMicrotask(() => callback(err, {\n      opaque\n    }));\n  }\n}\nmodule.exports = request;\nmodule.exports.RequestHandler = RequestHandler;","map":{"version":3,"names":["assert","require","Readable","InvalidArgumentError","RequestAbortedError","util","getResolveErrorBodyCallback","AsyncResource","RequestHandler","constructor","opts","callback","signal","method","opaque","body","onInfo","responseHeaders","throwOnError","highWaterMark","on","addEventListener","err","isStream","destroy","nop","res","abort","trailers","context","reason","removeAbortListener","onError","aborted","addAbortListener","off","onConnect","onHeaders","statusCode","rawHeaders","resume","statusMessage","headers","parseRawHeaders","parseHeaders","parsedHeaders","contentType","contentLength","Number","runInAsyncScope","onData","chunk","push","onComplete","queueMicrotask","request","undefined","Promise","resolve","reject","call","data","dispatch","module","exports"],"sources":["/Users/nataliia/PussyProjects/react-app/node_modules/undici/lib/api/api-request.js"],"sourcesContent":["'use strict'\n\nconst assert = require('node:assert')\nconst { Readable } = require('./readable')\nconst { InvalidArgumentError, RequestAbortedError } = require('../core/errors')\nconst util = require('../core/util')\nconst { getResolveErrorBodyCallback } = require('./util')\nconst { AsyncResource } = require('node:async_hooks')\n\nclass RequestHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (highWaterMark && (typeof highWaterMark !== 'number' || highWaterMark < 0)) {\n        throw new InvalidArgumentError('invalid highWaterMark')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback')\n      }\n\n      super('UNDICI_REQUEST')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err)\n      }\n      throw err\n    }\n\n    this.method = method\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.body = body\n    this.trailers = {}\n    this.context = null\n    this.onInfo = onInfo || null\n    this.throwOnError = throwOnError\n    this.highWaterMark = highWaterMark\n    this.signal = signal\n    this.reason = null\n    this.removeAbortListener = null\n\n    if (util.isStream(body)) {\n      body.on('error', (err) => {\n        this.onError(err)\n      })\n    }\n\n    if (this.signal) {\n      if (this.signal.aborted) {\n        this.reason = this.signal.reason ?? new RequestAbortedError()\n      } else {\n        this.removeAbortListener = util.addAbortListener(this.signal, () => {\n          this.reason = this.signal.reason ?? new RequestAbortedError()\n          if (this.res) {\n            util.destroy(this.res, this.reason)\n          } else if (this.abort) {\n            this.abort(this.reason)\n          }\n\n          if (this.removeAbortListener) {\n            this.res?.off('close', this.removeAbortListener)\n            this.removeAbortListener()\n            this.removeAbortListener = null\n          }\n        })\n      }\n    }\n  }\n\n  onConnect (abort, context) {\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(this.callback)\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this\n\n    const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    const parsedHeaders = responseHeaders === 'raw' ? util.parseHeaders(rawHeaders) : headers\n    const contentType = parsedHeaders['content-type']\n    const contentLength = parsedHeaders['content-length']\n    const res = new Readable({\n      resume,\n      abort,\n      contentType,\n      contentLength: this.method !== 'HEAD' && contentLength\n        ? Number(contentLength)\n        : null,\n      highWaterMark\n    })\n\n    if (this.removeAbortListener) {\n      res.on('close', this.removeAbortListener)\n    }\n\n    this.callback = null\n    this.res = res\n    if (callback !== null) {\n      if (this.throwOnError && statusCode >= 400) {\n        this.runInAsyncScope(getResolveErrorBodyCallback, null,\n          { callback, body: res, contentType, statusCode, statusMessage, headers }\n        )\n      } else {\n        this.runInAsyncScope(callback, null, null, {\n          statusCode,\n          headers,\n          trailers: this.trailers,\n          opaque,\n          body: res,\n          context\n        })\n      }\n    }\n  }\n\n  onData (chunk) {\n    return this.res.push(chunk)\n  }\n\n  onComplete (trailers) {\n    util.parseHeaders(trailers, this.trailers)\n    this.res.push(null)\n  }\n\n  onError (err) {\n    const { res, callback, body, opaque } = this\n\n    if (callback) {\n      // TODO: Does this need queueMicrotask?\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n\n    if (res) {\n      this.res = null\n      // Ensure all queued handlers are invoked before destroying res.\n      queueMicrotask(() => {\n        util.destroy(res, err)\n      })\n    }\n\n    if (body) {\n      this.body = null\n      util.destroy(body, err)\n    }\n\n    if (this.removeAbortListener) {\n      res?.off('close', this.removeAbortListener)\n      this.removeAbortListener()\n      this.removeAbortListener = null\n    }\n  }\n}\n\nfunction request (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      request.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    this.dispatch(opts, new RequestHandler(opts, callback))\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts?.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = request\nmodule.exports.RequestHandler = RequestHandler\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
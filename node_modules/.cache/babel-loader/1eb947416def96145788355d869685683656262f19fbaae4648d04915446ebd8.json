{"ast":null,"code":"'use strict';\n\nconst {\n  types,\n  inspect\n} = require('node:util');\nconst {\n  toUSVString\n} = require('../../core/util');\n\n/** @type {import('../../../types/webidl').Webidl} */\nconst webidl = {};\nwebidl.converters = {};\nwebidl.util = {};\nwebidl.errors = {};\nwebidl.errors.exception = function (message) {\n  return new TypeError(`${message.header}: ${message.message}`);\n};\nwebidl.errors.conversionFailed = function (context) {\n  const plural = context.types.length === 1 ? '' : ' one of';\n  const message = `${context.argument} could not be converted to` + `${plural}: ${context.types.join(', ')}.`;\n  return webidl.errors.exception({\n    header: context.prefix,\n    message\n  });\n};\nwebidl.errors.invalidArgument = function (context) {\n  return webidl.errors.exception({\n    header: context.prefix,\n    message: `\"${context.value}\" is an invalid ${context.type}.`\n  });\n};\n\n// https://webidl.spec.whatwg.org/#implements\nwebidl.brandCheck = function (V, I, opts) {\n  if (opts?.strict !== false) {\n    if (!(V instanceof I)) {\n      const err = new TypeError('Illegal invocation');\n      err.code = 'ERR_INVALID_THIS'; // node compat.\n      throw err;\n    }\n  } else {\n    if (V?.[Symbol.toStringTag] !== I.prototype[Symbol.toStringTag]) {\n      const err = new TypeError('Illegal invocation');\n      err.code = 'ERR_INVALID_THIS'; // node compat.\n      throw err;\n    }\n  }\n};\nwebidl.argumentLengthCheck = function ({\n  length\n}, min, ctx) {\n  if (length < min) {\n    throw webidl.errors.exception({\n      message: `${min} argument${min !== 1 ? 's' : ''} required, ` + `but${length ? ' only' : ''} ${length} found.`,\n      header: ctx\n    });\n  }\n};\nwebidl.illegalConstructor = function () {\n  throw webidl.errors.exception({\n    header: 'TypeError',\n    message: 'Illegal constructor'\n  });\n};\n\n// https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values\nwebidl.util.Type = function (V) {\n  switch (typeof V) {\n    case 'undefined':\n      return 'Undefined';\n    case 'boolean':\n      return 'Boolean';\n    case 'string':\n      return 'String';\n    case 'symbol':\n      return 'Symbol';\n    case 'number':\n      return 'Number';\n    case 'bigint':\n      return 'BigInt';\n    case 'function':\n    case 'object':\n      {\n        if (V === null) {\n          return 'Null';\n        }\n        return 'Object';\n      }\n  }\n};\n\n// https://webidl.spec.whatwg.org/#abstract-opdef-converttoint\nwebidl.util.ConvertToInt = function (V, bitLength, signedness, opts) {\n  let upperBound;\n  let lowerBound;\n\n  // 1. If bitLength is 64, then:\n  if (bitLength === 64) {\n    // 1. Let upperBound be 2^53 − 1.\n    upperBound = Math.pow(2, 53) - 1;\n\n    // 2. If signedness is \"unsigned\", then let lowerBound be 0.\n    if (signedness === 'unsigned') {\n      lowerBound = 0;\n    } else {\n      // 3. Otherwise let lowerBound be −2^53 + 1.\n      lowerBound = Math.pow(-2, 53) + 1;\n    }\n  } else if (signedness === 'unsigned') {\n    // 2. Otherwise, if signedness is \"unsigned\", then:\n\n    // 1. Let lowerBound be 0.\n    lowerBound = 0;\n\n    // 2. Let upperBound be 2^bitLength − 1.\n    upperBound = Math.pow(2, bitLength) - 1;\n  } else {\n    // 3. Otherwise:\n\n    // 1. Let lowerBound be -2^bitLength − 1.\n    lowerBound = Math.pow(-2, bitLength) - 1;\n\n    // 2. Let upperBound be 2^bitLength − 1 − 1.\n    upperBound = Math.pow(2, bitLength - 1) - 1;\n  }\n\n  // 4. Let x be ? ToNumber(V).\n  let x = Number(V);\n\n  // 5. If x is −0, then set x to +0.\n  if (x === 0) {\n    x = 0;\n  }\n\n  // 6. If the conversion is to an IDL type associated\n  //    with the [EnforceRange] extended attribute, then:\n  if (opts?.enforceRange === true) {\n    // 1. If x is NaN, +∞, or −∞, then throw a TypeError.\n    if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {\n      throw webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Could not convert ${webidl.util.Stringify(V)} to an integer.`\n      });\n    }\n\n    // 2. Set x to IntegerPart(x).\n    x = webidl.util.IntegerPart(x);\n\n    // 3. If x < lowerBound or x > upperBound, then\n    //    throw a TypeError.\n    if (x < lowerBound || x > upperBound) {\n      throw webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`\n      });\n    }\n\n    // 4. Return x.\n    return x;\n  }\n\n  // 7. If x is not NaN and the conversion is to an IDL\n  //    type associated with the [Clamp] extended\n  //    attribute, then:\n  if (!Number.isNaN(x) && opts?.clamp === true) {\n    // 1. Set x to min(max(x, lowerBound), upperBound).\n    x = Math.min(Math.max(x, lowerBound), upperBound);\n\n    // 2. Round x to the nearest integer, choosing the\n    //    even integer if it lies halfway between two,\n    //    and choosing +0 rather than −0.\n    if (Math.floor(x) % 2 === 0) {\n      x = Math.floor(x);\n    } else {\n      x = Math.ceil(x);\n    }\n\n    // 3. Return x.\n    return x;\n  }\n\n  // 8. If x is NaN, +0, +∞, or −∞, then return +0.\n  if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {\n    return 0;\n  }\n\n  // 9. Set x to IntegerPart(x).\n  x = webidl.util.IntegerPart(x);\n\n  // 10. Set x to x modulo 2^bitLength.\n  x = x % Math.pow(2, bitLength);\n\n  // 11. If signedness is \"signed\" and x ≥ 2^bitLength − 1,\n  //    then return x − 2^bitLength.\n  if (signedness === 'signed' && x >= Math.pow(2, bitLength) - 1) {\n    return x - Math.pow(2, bitLength);\n  }\n\n  // 12. Otherwise, return x.\n  return x;\n};\n\n// https://webidl.spec.whatwg.org/#abstract-opdef-integerpart\nwebidl.util.IntegerPart = function (n) {\n  // 1. Let r be floor(abs(n)).\n  const r = Math.floor(Math.abs(n));\n\n  // 2. If n < 0, then return -1 × r.\n  if (n < 0) {\n    return -1 * r;\n  }\n\n  // 3. Otherwise, return r.\n  return r;\n};\nwebidl.util.Stringify = function (V) {\n  const type = webidl.util.Type(V);\n  switch (type) {\n    case 'Symbol':\n      return `Symbol(${V.description})`;\n    case 'Object':\n      return inspect(V);\n    case 'String':\n      return `\"${V}\"`;\n    default:\n      return `${V}`;\n  }\n};\n\n// https://webidl.spec.whatwg.org/#es-sequence\nwebidl.sequenceConverter = function (converter) {\n  return (V, prefix, argument, Iterable) => {\n    // 1. If Type(V) is not Object, throw a TypeError.\n    if (webidl.util.Type(V) !== 'Object') {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `${argument} (${webidl.util.Stringify(V)}) is not iterable.`\n      });\n    }\n\n    // 2. Let method be ? GetMethod(V, @@iterator).\n    /** @type {Generator} */\n    const method = typeof Iterable === 'function' ? Iterable() : V?.[Symbol.iterator]?.();\n    const seq = [];\n    let index = 0;\n\n    // 3. If method is undefined, throw a TypeError.\n    if (method === undefined || typeof method.next !== 'function') {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `${argument} is not iterable.`\n      });\n    }\n\n    // https://webidl.spec.whatwg.org/#create-sequence-from-iterable\n    while (true) {\n      const {\n        done,\n        value\n      } = method.next();\n      if (done) {\n        break;\n      }\n      seq.push(converter(value, prefix, `${argument}[${index++}]`));\n    }\n    return seq;\n  };\n};\n\n// https://webidl.spec.whatwg.org/#es-to-record\nwebidl.recordConverter = function (keyConverter, valueConverter) {\n  return (O, prefix, argument) => {\n    // 1. If Type(O) is not Object, throw a TypeError.\n    if (webidl.util.Type(O) !== 'Object') {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `${argument} (\"${webidl.util.Type(O)}\") is not an Object.`\n      });\n    }\n\n    // 2. Let result be a new empty instance of record<K, V>.\n    const result = {};\n    if (!types.isProxy(O)) {\n      // 1. Let desc be ? O.[[GetOwnProperty]](key).\n      const keys = [...Object.getOwnPropertyNames(O), ...Object.getOwnPropertySymbols(O)];\n      for (const key of keys) {\n        // 1. Let typedKey be key converted to an IDL value of type K.\n        const typedKey = keyConverter(key, prefix, argument);\n\n        // 2. Let value be ? Get(O, key).\n        // 3. Let typedValue be value converted to an IDL value of type V.\n        const typedValue = valueConverter(O[key], prefix, argument);\n\n        // 4. Set result[typedKey] to typedValue.\n        result[typedKey] = typedValue;\n      }\n\n      // 5. Return result.\n      return result;\n    }\n\n    // 3. Let keys be ? O.[[OwnPropertyKeys]]().\n    const keys = Reflect.ownKeys(O);\n\n    // 4. For each key of keys.\n    for (const key of keys) {\n      // 1. Let desc be ? O.[[GetOwnProperty]](key).\n      const desc = Reflect.getOwnPropertyDescriptor(O, key);\n\n      // 2. If desc is not undefined and desc.[[Enumerable]] is true:\n      if (desc?.enumerable) {\n        // 1. Let typedKey be key converted to an IDL value of type K.\n        const typedKey = keyConverter(key, prefix, argument);\n\n        // 2. Let value be ? Get(O, key).\n        // 3. Let typedValue be value converted to an IDL value of type V.\n        const typedValue = valueConverter(O[key], prefix, argument);\n\n        // 4. Set result[typedKey] to typedValue.\n        result[typedKey] = typedValue;\n      }\n    }\n\n    // 5. Return result.\n    return result;\n  };\n};\nwebidl.interfaceConverter = function (i) {\n  return (V, prefix, argument, opts) => {\n    if (opts?.strict !== false && !(V instanceof i)) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `Expected ${argument} (\"${webidl.util.Stringify(V)}\") to be an instance of ${i.name}.`\n      });\n    }\n    return V;\n  };\n};\nwebidl.dictionaryConverter = function (converters) {\n  return (dictionary, prefix, argument) => {\n    const type = webidl.util.Type(dictionary);\n    const dict = {};\n    if (type === 'Null' || type === 'Undefined') {\n      return dict;\n    } else if (type !== 'Object') {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`\n      });\n    }\n    for (const options of converters) {\n      const {\n        key,\n        defaultValue,\n        required,\n        converter\n      } = options;\n      if (required === true) {\n        if (!Object.hasOwn(dictionary, key)) {\n          throw webidl.errors.exception({\n            header: prefix,\n            message: `Missing required key \"${key}\".`\n          });\n        }\n      }\n      let value = dictionary[key];\n      const hasDefault = Object.hasOwn(options, 'defaultValue');\n\n      // Only use defaultValue if value is undefined and\n      // a defaultValue options was provided.\n      if (hasDefault && value !== null) {\n        value ??= defaultValue();\n      }\n\n      // A key can be optional and have no default value.\n      // When this happens, do not perform a conversion,\n      // and do not assign the key a value.\n      if (required || hasDefault || value !== undefined) {\n        value = converter(value, prefix, `${argument}.${key}`);\n        if (options.allowedValues && !options.allowedValues.includes(value)) {\n          throw webidl.errors.exception({\n            header: prefix,\n            message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(', ')}.`\n          });\n        }\n        dict[key] = value;\n      }\n    }\n    return dict;\n  };\n};\nwebidl.nullableConverter = function (converter) {\n  return (V, prefix, argument) => {\n    if (V === null) {\n      return V;\n    }\n    return converter(V, prefix, argument);\n  };\n};\n\n// https://webidl.spec.whatwg.org/#es-DOMString\nwebidl.converters.DOMString = function (V, prefix, argument, opts) {\n  // 1. If V is null and the conversion is to an IDL type\n  //    associated with the [LegacyNullToEmptyString]\n  //    extended attribute, then return the DOMString value\n  //    that represents the empty string.\n  if (V === null && opts?.legacyNullToEmptyString) {\n    return '';\n  }\n\n  // 2. Let x be ? ToString(V).\n  if (typeof V === 'symbol') {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${argument} is a symbol, which cannot be converted to a DOMString.`\n    });\n  }\n\n  // 3. Return the IDL DOMString value that represents the\n  //    same sequence of code units as the one the\n  //    ECMAScript String value x represents.\n  return String(V);\n};\n\n// https://webidl.spec.whatwg.org/#es-ByteString\nwebidl.converters.ByteString = function (V, prefix, argument) {\n  // 1. Let x be ? ToString(V).\n  // Note: DOMString converter perform ? ToString(V)\n  const x = webidl.converters.DOMString(V, prefix, argument);\n\n  // 2. If the value of any element of x is greater than\n  //    255, then throw a TypeError.\n  for (let index = 0; index < x.length; index++) {\n    if (x.charCodeAt(index) > 255) {\n      throw new TypeError('Cannot convert argument to a ByteString because the character at ' + `index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`);\n    }\n  }\n\n  // 3. Return an IDL ByteString value whose length is the\n  //    length of x, and where the value of each element is\n  //    the value of the corresponding element of x.\n  return x;\n};\n\n// https://webidl.spec.whatwg.org/#es-USVString\n// TODO: rewrite this so we can control the errors thrown\nwebidl.converters.USVString = toUSVString;\n\n// https://webidl.spec.whatwg.org/#es-boolean\nwebidl.converters.boolean = function (V) {\n  // 1. Let x be the result of computing ToBoolean(V).\n  const x = Boolean(V);\n\n  // 2. Return the IDL boolean value that is the one that represents\n  //    the same truth value as the ECMAScript Boolean value x.\n  return x;\n};\n\n// https://webidl.spec.whatwg.org/#es-any\nwebidl.converters.any = function (V) {\n  return V;\n};\n\n// https://webidl.spec.whatwg.org/#es-long-long\nwebidl.converters['long long'] = function (V, prefix, argument) {\n  // 1. Let x be ? ConvertToInt(V, 64, \"signed\").\n  const x = webidl.util.ConvertToInt(V, 64, 'signed', undefined, prefix, argument);\n\n  // 2. Return the IDL long long value that represents\n  //    the same numeric value as x.\n  return x;\n};\n\n// https://webidl.spec.whatwg.org/#es-unsigned-long-long\nwebidl.converters['unsigned long long'] = function (V, prefix, argument) {\n  // 1. Let x be ? ConvertToInt(V, 64, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 64, 'unsigned', undefined, prefix, argument);\n\n  // 2. Return the IDL unsigned long long value that\n  //    represents the same numeric value as x.\n  return x;\n};\n\n// https://webidl.spec.whatwg.org/#es-unsigned-long\nwebidl.converters['unsigned long'] = function (V, prefix, argument) {\n  // 1. Let x be ? ConvertToInt(V, 32, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 32, 'unsigned', undefined, prefix, argument);\n\n  // 2. Return the IDL unsigned long value that\n  //    represents the same numeric value as x.\n  return x;\n};\n\n// https://webidl.spec.whatwg.org/#es-unsigned-short\nwebidl.converters['unsigned short'] = function (V, prefix, argument, opts) {\n  // 1. Let x be ? ConvertToInt(V, 16, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 16, 'unsigned', opts, prefix, argument);\n\n  // 2. Return the IDL unsigned short value that represents\n  //    the same numeric value as x.\n  return x;\n};\n\n// https://webidl.spec.whatwg.org/#idl-ArrayBuffer\nwebidl.converters.ArrayBuffer = function (V, prefix, argument, opts) {\n  // 1. If Type(V) is not Object, or V does not have an\n  //    [[ArrayBufferData]] internal slot, then throw a\n  //    TypeError.\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-arraybuffer-instances\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-sharedarraybuffer-instances\n  if (webidl.util.Type(V) !== 'Object' || !types.isAnyArrayBuffer(V)) {\n    throw webidl.errors.conversionFailed({\n      prefix,\n      argument: `${argument} (\"${webidl.util.Stringify(V)}\")`,\n      types: ['ArrayBuffer']\n    });\n  }\n\n  // 2. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  if (opts?.allowShared === false && types.isSharedArrayBuffer(V)) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    });\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  if (V.resizable || V.growable) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'Received a resizable ArrayBuffer.'\n    });\n  }\n\n  // 4. Return the IDL ArrayBuffer value that is a\n  //    reference to the same object as V.\n  return V;\n};\nwebidl.converters.TypedArray = function (V, T, prefix, name, opts) {\n  // 1. Let T be the IDL type V is being converted to.\n\n  // 2. If Type(V) is not Object, or V does not have a\n  //    [[TypedArrayName]] internal slot with a value\n  //    equal to T’s name, then throw a TypeError.\n  if (webidl.util.Type(V) !== 'Object' || !types.isTypedArray(V) || V.constructor.name !== T.name) {\n    throw webidl.errors.conversionFailed({\n      prefix,\n      argument: `${name} (\"${webidl.util.Stringify(V)}\")`,\n      types: [T.name]\n    });\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (opts?.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    });\n  }\n\n  // 4. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (V.buffer.resizable || V.buffer.growable) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'Received a resizable ArrayBuffer.'\n    });\n  }\n\n  // 5. Return the IDL value of type T that is a reference\n  //    to the same object as V.\n  return V;\n};\nwebidl.converters.DataView = function (V, prefix, name, opts) {\n  // 1. If Type(V) is not Object, or V does not have a\n  //    [[DataView]] internal slot, then throw a TypeError.\n  if (webidl.util.Type(V) !== 'Object' || !types.isDataView(V)) {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${name} is not a DataView.`\n    });\n  }\n\n  // 2. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true,\n  //    then throw a TypeError.\n  if (opts?.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    });\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (V.buffer.resizable || V.buffer.growable) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'Received a resizable ArrayBuffer.'\n    });\n  }\n\n  // 4. Return the IDL DataView value that is a reference\n  //    to the same object as V.\n  return V;\n};\n\n// https://webidl.spec.whatwg.org/#BufferSource\nwebidl.converters.BufferSource = function (V, prefix, name, opts) {\n  if (types.isAnyArrayBuffer(V)) {\n    return webidl.converters.ArrayBuffer(V, prefix, name, {\n      ...opts,\n      allowShared: false\n    });\n  }\n  if (types.isTypedArray(V)) {\n    return webidl.converters.TypedArray(V, V.constructor, prefix, name, {\n      ...opts,\n      allowShared: false\n    });\n  }\n  if (types.isDataView(V)) {\n    return webidl.converters.DataView(V, prefix, name, {\n      ...opts,\n      allowShared: false\n    });\n  }\n  throw webidl.errors.conversionFailed({\n    prefix,\n    argument: `${name} (\"${webidl.util.Stringify(V)}\")`,\n    types: ['BufferSource']\n  });\n};\nwebidl.converters['sequence<ByteString>'] = webidl.sequenceConverter(webidl.converters.ByteString);\nwebidl.converters['sequence<sequence<ByteString>>'] = webidl.sequenceConverter(webidl.converters['sequence<ByteString>']);\nwebidl.converters['record<ByteString, ByteString>'] = webidl.recordConverter(webidl.converters.ByteString, webidl.converters.ByteString);\nmodule.exports = {\n  webidl\n};","map":{"version":3,"names":["types","inspect","require","toUSVString","webidl","converters","util","errors","exception","message","TypeError","header","conversionFailed","context","plural","length","argument","join","prefix","invalidArgument","value","type","brandCheck","V","I","opts","strict","err","code","Symbol","toStringTag","prototype","argumentLengthCheck","min","ctx","illegalConstructor","Type","ConvertToInt","bitLength","signedness","upperBound","lowerBound","Math","pow","x","Number","enforceRange","isNaN","POSITIVE_INFINITY","NEGATIVE_INFINITY","Stringify","IntegerPart","clamp","max","floor","ceil","Object","is","n","r","abs","description","sequenceConverter","converter","Iterable","method","iterator","seq","index","undefined","next","done","push","recordConverter","keyConverter","valueConverter","O","result","isProxy","keys","getOwnPropertyNames","getOwnPropertySymbols","key","typedKey","typedValue","Reflect","ownKeys","desc","getOwnPropertyDescriptor","enumerable","interfaceConverter","i","name","dictionaryConverter","dictionary","dict","options","defaultValue","required","hasOwn","hasDefault","allowedValues","includes","nullableConverter","DOMString","legacyNullToEmptyString","String","ByteString","charCodeAt","USVString","boolean","Boolean","any","ArrayBuffer","isAnyArrayBuffer","allowShared","isSharedArrayBuffer","resizable","growable","TypedArray","T","isTypedArray","constructor","buffer","DataView","isDataView","BufferSource","module","exports"],"sources":["/Users/nataliia/PussyProjects/react-app/node_modules/undici/lib/web/fetch/webidl.js"],"sourcesContent":["'use strict'\n\nconst { types, inspect } = require('node:util')\nconst { toUSVString } = require('../../core/util')\n\n/** @type {import('../../../types/webidl').Webidl} */\nconst webidl = {}\nwebidl.converters = {}\nwebidl.util = {}\nwebidl.errors = {}\n\nwebidl.errors.exception = function (message) {\n  return new TypeError(`${message.header}: ${message.message}`)\n}\n\nwebidl.errors.conversionFailed = function (context) {\n  const plural = context.types.length === 1 ? '' : ' one of'\n  const message =\n    `${context.argument} could not be converted to` +\n    `${plural}: ${context.types.join(', ')}.`\n\n  return webidl.errors.exception({\n    header: context.prefix,\n    message\n  })\n}\n\nwebidl.errors.invalidArgument = function (context) {\n  return webidl.errors.exception({\n    header: context.prefix,\n    message: `\"${context.value}\" is an invalid ${context.type}.`\n  })\n}\n\n// https://webidl.spec.whatwg.org/#implements\nwebidl.brandCheck = function (V, I, opts) {\n  if (opts?.strict !== false) {\n    if (!(V instanceof I)) {\n      const err = new TypeError('Illegal invocation')\n      err.code = 'ERR_INVALID_THIS' // node compat.\n      throw err\n    }\n  } else {\n    if (V?.[Symbol.toStringTag] !== I.prototype[Symbol.toStringTag]) {\n      const err = new TypeError('Illegal invocation')\n      err.code = 'ERR_INVALID_THIS' // node compat.\n      throw err\n    }\n  }\n}\n\nwebidl.argumentLengthCheck = function ({ length }, min, ctx) {\n  if (length < min) {\n    throw webidl.errors.exception({\n      message: `${min} argument${min !== 1 ? 's' : ''} required, ` +\n               `but${length ? ' only' : ''} ${length} found.`,\n      header: ctx\n    })\n  }\n}\n\nwebidl.illegalConstructor = function () {\n  throw webidl.errors.exception({\n    header: 'TypeError',\n    message: 'Illegal constructor'\n  })\n}\n\n// https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values\nwebidl.util.Type = function (V) {\n  switch (typeof V) {\n    case 'undefined': return 'Undefined'\n    case 'boolean': return 'Boolean'\n    case 'string': return 'String'\n    case 'symbol': return 'Symbol'\n    case 'number': return 'Number'\n    case 'bigint': return 'BigInt'\n    case 'function':\n    case 'object': {\n      if (V === null) {\n        return 'Null'\n      }\n\n      return 'Object'\n    }\n  }\n}\n\n// https://webidl.spec.whatwg.org/#abstract-opdef-converttoint\nwebidl.util.ConvertToInt = function (V, bitLength, signedness, opts) {\n  let upperBound\n  let lowerBound\n\n  // 1. If bitLength is 64, then:\n  if (bitLength === 64) {\n    // 1. Let upperBound be 2^53 − 1.\n    upperBound = Math.pow(2, 53) - 1\n\n    // 2. If signedness is \"unsigned\", then let lowerBound be 0.\n    if (signedness === 'unsigned') {\n      lowerBound = 0\n    } else {\n      // 3. Otherwise let lowerBound be −2^53 + 1.\n      lowerBound = Math.pow(-2, 53) + 1\n    }\n  } else if (signedness === 'unsigned') {\n    // 2. Otherwise, if signedness is \"unsigned\", then:\n\n    // 1. Let lowerBound be 0.\n    lowerBound = 0\n\n    // 2. Let upperBound be 2^bitLength − 1.\n    upperBound = Math.pow(2, bitLength) - 1\n  } else {\n    // 3. Otherwise:\n\n    // 1. Let lowerBound be -2^bitLength − 1.\n    lowerBound = Math.pow(-2, bitLength) - 1\n\n    // 2. Let upperBound be 2^bitLength − 1 − 1.\n    upperBound = Math.pow(2, bitLength - 1) - 1\n  }\n\n  // 4. Let x be ? ToNumber(V).\n  let x = Number(V)\n\n  // 5. If x is −0, then set x to +0.\n  if (x === 0) {\n    x = 0\n  }\n\n  // 6. If the conversion is to an IDL type associated\n  //    with the [EnforceRange] extended attribute, then:\n  if (opts?.enforceRange === true) {\n    // 1. If x is NaN, +∞, or −∞, then throw a TypeError.\n    if (\n      Number.isNaN(x) ||\n      x === Number.POSITIVE_INFINITY ||\n      x === Number.NEGATIVE_INFINITY\n    ) {\n      throw webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Could not convert ${webidl.util.Stringify(V)} to an integer.`\n      })\n    }\n\n    // 2. Set x to IntegerPart(x).\n    x = webidl.util.IntegerPart(x)\n\n    // 3. If x < lowerBound or x > upperBound, then\n    //    throw a TypeError.\n    if (x < lowerBound || x > upperBound) {\n      throw webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`\n      })\n    }\n\n    // 4. Return x.\n    return x\n  }\n\n  // 7. If x is not NaN and the conversion is to an IDL\n  //    type associated with the [Clamp] extended\n  //    attribute, then:\n  if (!Number.isNaN(x) && opts?.clamp === true) {\n    // 1. Set x to min(max(x, lowerBound), upperBound).\n    x = Math.min(Math.max(x, lowerBound), upperBound)\n\n    // 2. Round x to the nearest integer, choosing the\n    //    even integer if it lies halfway between two,\n    //    and choosing +0 rather than −0.\n    if (Math.floor(x) % 2 === 0) {\n      x = Math.floor(x)\n    } else {\n      x = Math.ceil(x)\n    }\n\n    // 3. Return x.\n    return x\n  }\n\n  // 8. If x is NaN, +0, +∞, or −∞, then return +0.\n  if (\n    Number.isNaN(x) ||\n    (x === 0 && Object.is(0, x)) ||\n    x === Number.POSITIVE_INFINITY ||\n    x === Number.NEGATIVE_INFINITY\n  ) {\n    return 0\n  }\n\n  // 9. Set x to IntegerPart(x).\n  x = webidl.util.IntegerPart(x)\n\n  // 10. Set x to x modulo 2^bitLength.\n  x = x % Math.pow(2, bitLength)\n\n  // 11. If signedness is \"signed\" and x ≥ 2^bitLength − 1,\n  //    then return x − 2^bitLength.\n  if (signedness === 'signed' && x >= Math.pow(2, bitLength) - 1) {\n    return x - Math.pow(2, bitLength)\n  }\n\n  // 12. Otherwise, return x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#abstract-opdef-integerpart\nwebidl.util.IntegerPart = function (n) {\n  // 1. Let r be floor(abs(n)).\n  const r = Math.floor(Math.abs(n))\n\n  // 2. If n < 0, then return -1 × r.\n  if (n < 0) {\n    return -1 * r\n  }\n\n  // 3. Otherwise, return r.\n  return r\n}\n\nwebidl.util.Stringify = function (V) {\n  const type = webidl.util.Type(V)\n\n  switch (type) {\n    case 'Symbol':\n      return `Symbol(${V.description})`\n    case 'Object':\n      return inspect(V)\n    case 'String':\n      return `\"${V}\"`\n    default:\n      return `${V}`\n  }\n}\n\n// https://webidl.spec.whatwg.org/#es-sequence\nwebidl.sequenceConverter = function (converter) {\n  return (V, prefix, argument, Iterable) => {\n    // 1. If Type(V) is not Object, throw a TypeError.\n    if (webidl.util.Type(V) !== 'Object') {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `${argument} (${webidl.util.Stringify(V)}) is not iterable.`\n      })\n    }\n\n    // 2. Let method be ? GetMethod(V, @@iterator).\n    /** @type {Generator} */\n    const method = typeof Iterable === 'function' ? Iterable() : V?.[Symbol.iterator]?.()\n    const seq = []\n    let index = 0\n\n    // 3. If method is undefined, throw a TypeError.\n    if (\n      method === undefined ||\n      typeof method.next !== 'function'\n    ) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `${argument} is not iterable.`\n      })\n    }\n\n    // https://webidl.spec.whatwg.org/#create-sequence-from-iterable\n    while (true) {\n      const { done, value } = method.next()\n\n      if (done) {\n        break\n      }\n\n      seq.push(converter(value, prefix, `${argument}[${index++}]`))\n    }\n\n    return seq\n  }\n}\n\n// https://webidl.spec.whatwg.org/#es-to-record\nwebidl.recordConverter = function (keyConverter, valueConverter) {\n  return (O, prefix, argument) => {\n    // 1. If Type(O) is not Object, throw a TypeError.\n    if (webidl.util.Type(O) !== 'Object') {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `${argument} (\"${webidl.util.Type(O)}\") is not an Object.`\n      })\n    }\n\n    // 2. Let result be a new empty instance of record<K, V>.\n    const result = {}\n\n    if (!types.isProxy(O)) {\n      // 1. Let desc be ? O.[[GetOwnProperty]](key).\n      const keys = [...Object.getOwnPropertyNames(O), ...Object.getOwnPropertySymbols(O)]\n\n      for (const key of keys) {\n        // 1. Let typedKey be key converted to an IDL value of type K.\n        const typedKey = keyConverter(key, prefix, argument)\n\n        // 2. Let value be ? Get(O, key).\n        // 3. Let typedValue be value converted to an IDL value of type V.\n        const typedValue = valueConverter(O[key], prefix, argument)\n\n        // 4. Set result[typedKey] to typedValue.\n        result[typedKey] = typedValue\n      }\n\n      // 5. Return result.\n      return result\n    }\n\n    // 3. Let keys be ? O.[[OwnPropertyKeys]]().\n    const keys = Reflect.ownKeys(O)\n\n    // 4. For each key of keys.\n    for (const key of keys) {\n      // 1. Let desc be ? O.[[GetOwnProperty]](key).\n      const desc = Reflect.getOwnPropertyDescriptor(O, key)\n\n      // 2. If desc is not undefined and desc.[[Enumerable]] is true:\n      if (desc?.enumerable) {\n        // 1. Let typedKey be key converted to an IDL value of type K.\n        const typedKey = keyConverter(key, prefix, argument)\n\n        // 2. Let value be ? Get(O, key).\n        // 3. Let typedValue be value converted to an IDL value of type V.\n        const typedValue = valueConverter(O[key], prefix, argument)\n\n        // 4. Set result[typedKey] to typedValue.\n        result[typedKey] = typedValue\n      }\n    }\n\n    // 5. Return result.\n    return result\n  }\n}\n\nwebidl.interfaceConverter = function (i) {\n  return (V, prefix, argument, opts) => {\n    if (opts?.strict !== false && !(V instanceof i)) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `Expected ${argument} (\"${webidl.util.Stringify(V)}\") to be an instance of ${i.name}.`\n      })\n    }\n\n    return V\n  }\n}\n\nwebidl.dictionaryConverter = function (converters) {\n  return (dictionary, prefix, argument) => {\n    const type = webidl.util.Type(dictionary)\n    const dict = {}\n\n    if (type === 'Null' || type === 'Undefined') {\n      return dict\n    } else if (type !== 'Object') {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`\n      })\n    }\n\n    for (const options of converters) {\n      const { key, defaultValue, required, converter } = options\n\n      if (required === true) {\n        if (!Object.hasOwn(dictionary, key)) {\n          throw webidl.errors.exception({\n            header: prefix,\n            message: `Missing required key \"${key}\".`\n          })\n        }\n      }\n\n      let value = dictionary[key]\n      const hasDefault = Object.hasOwn(options, 'defaultValue')\n\n      // Only use defaultValue if value is undefined and\n      // a defaultValue options was provided.\n      if (hasDefault && value !== null) {\n        value ??= defaultValue()\n      }\n\n      // A key can be optional and have no default value.\n      // When this happens, do not perform a conversion,\n      // and do not assign the key a value.\n      if (required || hasDefault || value !== undefined) {\n        value = converter(value, prefix, `${argument}.${key}`)\n\n        if (\n          options.allowedValues &&\n          !options.allowedValues.includes(value)\n        ) {\n          throw webidl.errors.exception({\n            header: prefix,\n            message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(', ')}.`\n          })\n        }\n\n        dict[key] = value\n      }\n    }\n\n    return dict\n  }\n}\n\nwebidl.nullableConverter = function (converter) {\n  return (V, prefix, argument) => {\n    if (V === null) {\n      return V\n    }\n\n    return converter(V, prefix, argument)\n  }\n}\n\n// https://webidl.spec.whatwg.org/#es-DOMString\nwebidl.converters.DOMString = function (V, prefix, argument, opts) {\n  // 1. If V is null and the conversion is to an IDL type\n  //    associated with the [LegacyNullToEmptyString]\n  //    extended attribute, then return the DOMString value\n  //    that represents the empty string.\n  if (V === null && opts?.legacyNullToEmptyString) {\n    return ''\n  }\n\n  // 2. Let x be ? ToString(V).\n  if (typeof V === 'symbol') {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${argument} is a symbol, which cannot be converted to a DOMString.`\n    })\n  }\n\n  // 3. Return the IDL DOMString value that represents the\n  //    same sequence of code units as the one the\n  //    ECMAScript String value x represents.\n  return String(V)\n}\n\n// https://webidl.spec.whatwg.org/#es-ByteString\nwebidl.converters.ByteString = function (V, prefix, argument) {\n  // 1. Let x be ? ToString(V).\n  // Note: DOMString converter perform ? ToString(V)\n  const x = webidl.converters.DOMString(V, prefix, argument)\n\n  // 2. If the value of any element of x is greater than\n  //    255, then throw a TypeError.\n  for (let index = 0; index < x.length; index++) {\n    if (x.charCodeAt(index) > 255) {\n      throw new TypeError(\n        'Cannot convert argument to a ByteString because the character at ' +\n        `index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`\n      )\n    }\n  }\n\n  // 3. Return an IDL ByteString value whose length is the\n  //    length of x, and where the value of each element is\n  //    the value of the corresponding element of x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-USVString\n// TODO: rewrite this so we can control the errors thrown\nwebidl.converters.USVString = toUSVString\n\n// https://webidl.spec.whatwg.org/#es-boolean\nwebidl.converters.boolean = function (V) {\n  // 1. Let x be the result of computing ToBoolean(V).\n  const x = Boolean(V)\n\n  // 2. Return the IDL boolean value that is the one that represents\n  //    the same truth value as the ECMAScript Boolean value x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-any\nwebidl.converters.any = function (V) {\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#es-long-long\nwebidl.converters['long long'] = function (V, prefix, argument) {\n  // 1. Let x be ? ConvertToInt(V, 64, \"signed\").\n  const x = webidl.util.ConvertToInt(V, 64, 'signed', undefined, prefix, argument)\n\n  // 2. Return the IDL long long value that represents\n  //    the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-long-long\nwebidl.converters['unsigned long long'] = function (V, prefix, argument) {\n  // 1. Let x be ? ConvertToInt(V, 64, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 64, 'unsigned', undefined, prefix, argument)\n\n  // 2. Return the IDL unsigned long long value that\n  //    represents the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-long\nwebidl.converters['unsigned long'] = function (V, prefix, argument) {\n  // 1. Let x be ? ConvertToInt(V, 32, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 32, 'unsigned', undefined, prefix, argument)\n\n  // 2. Return the IDL unsigned long value that\n  //    represents the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-short\nwebidl.converters['unsigned short'] = function (V, prefix, argument, opts) {\n  // 1. Let x be ? ConvertToInt(V, 16, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 16, 'unsigned', opts, prefix, argument)\n\n  // 2. Return the IDL unsigned short value that represents\n  //    the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#idl-ArrayBuffer\nwebidl.converters.ArrayBuffer = function (V, prefix, argument, opts) {\n  // 1. If Type(V) is not Object, or V does not have an\n  //    [[ArrayBufferData]] internal slot, then throw a\n  //    TypeError.\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-arraybuffer-instances\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-sharedarraybuffer-instances\n  if (\n    webidl.util.Type(V) !== 'Object' ||\n    !types.isAnyArrayBuffer(V)\n  ) {\n    throw webidl.errors.conversionFailed({\n      prefix,\n      argument: `${argument} (\"${webidl.util.Stringify(V)}\")`,\n      types: ['ArrayBuffer']\n    })\n  }\n\n  // 2. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  if (opts?.allowShared === false && types.isSharedArrayBuffer(V)) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  if (V.resizable || V.growable) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'Received a resizable ArrayBuffer.'\n    })\n  }\n\n  // 4. Return the IDL ArrayBuffer value that is a\n  //    reference to the same object as V.\n  return V\n}\n\nwebidl.converters.TypedArray = function (V, T, prefix, name, opts) {\n  // 1. Let T be the IDL type V is being converted to.\n\n  // 2. If Type(V) is not Object, or V does not have a\n  //    [[TypedArrayName]] internal slot with a value\n  //    equal to T’s name, then throw a TypeError.\n  if (\n    webidl.util.Type(V) !== 'Object' ||\n    !types.isTypedArray(V) ||\n    V.constructor.name !== T.name\n  ) {\n    throw webidl.errors.conversionFailed({\n      prefix,\n      argument: `${name} (\"${webidl.util.Stringify(V)}\")`,\n      types: [T.name]\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (opts?.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    })\n  }\n\n  // 4. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (V.buffer.resizable || V.buffer.growable) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'Received a resizable ArrayBuffer.'\n    })\n  }\n\n  // 5. Return the IDL value of type T that is a reference\n  //    to the same object as V.\n  return V\n}\n\nwebidl.converters.DataView = function (V, prefix, name, opts) {\n  // 1. If Type(V) is not Object, or V does not have a\n  //    [[DataView]] internal slot, then throw a TypeError.\n  if (webidl.util.Type(V) !== 'Object' || !types.isDataView(V)) {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${name} is not a DataView.`\n    })\n  }\n\n  // 2. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true,\n  //    then throw a TypeError.\n  if (opts?.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (V.buffer.resizable || V.buffer.growable) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'Received a resizable ArrayBuffer.'\n    })\n  }\n\n  // 4. Return the IDL DataView value that is a reference\n  //    to the same object as V.\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#BufferSource\nwebidl.converters.BufferSource = function (V, prefix, name, opts) {\n  if (types.isAnyArrayBuffer(V)) {\n    return webidl.converters.ArrayBuffer(V, prefix, name, { ...opts, allowShared: false })\n  }\n\n  if (types.isTypedArray(V)) {\n    return webidl.converters.TypedArray(V, V.constructor, prefix, name, { ...opts, allowShared: false })\n  }\n\n  if (types.isDataView(V)) {\n    return webidl.converters.DataView(V, prefix, name, { ...opts, allowShared: false })\n  }\n\n  throw webidl.errors.conversionFailed({\n    prefix,\n    argument: `${name} (\"${webidl.util.Stringify(V)}\")`,\n    types: ['BufferSource']\n  })\n}\n\nwebidl.converters['sequence<ByteString>'] = webidl.sequenceConverter(\n  webidl.converters.ByteString\n)\n\nwebidl.converters['sequence<sequence<ByteString>>'] = webidl.sequenceConverter(\n  webidl.converters['sequence<ByteString>']\n)\n\nwebidl.converters['record<ByteString, ByteString>'] = webidl.recordConverter(\n  webidl.converters.ByteString,\n  webidl.converters.ByteString\n)\n\nmodule.exports = {\n  webidl\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"'use strict';\n\nconst {\n  kProxy,\n  kClose,\n  kDestroy,\n  kInterceptors\n} = require('../core/symbols');\nconst {\n  URL\n} = require('node:url');\nconst Agent = require('./agent');\nconst Pool = require('./pool');\nconst DispatcherBase = require('./dispatcher-base');\nconst {\n  InvalidArgumentError,\n  RequestAbortedError,\n  SecureProxyConnectionError\n} = require('../core/errors');\nconst buildConnector = require('../core/connect');\nconst kAgent = Symbol('proxy agent');\nconst kClient = Symbol('proxy client');\nconst kProxyHeaders = Symbol('proxy headers');\nconst kRequestTls = Symbol('request tls settings');\nconst kProxyTls = Symbol('proxy tls settings');\nconst kConnectEndpoint = Symbol('connect endpoint function');\nfunction defaultProtocolPort(protocol) {\n  return protocol === 'https:' ? 443 : 80;\n}\nfunction defaultFactory(origin, opts) {\n  return new Pool(origin, opts);\n}\nclass ProxyAgent extends DispatcherBase {\n  constructor(opts) {\n    super();\n    if (!opts || typeof opts === 'object' && !(opts instanceof URL) && !opts.uri) {\n      throw new InvalidArgumentError('Proxy uri is mandatory');\n    }\n    const {\n      clientFactory = defaultFactory\n    } = opts;\n    if (typeof clientFactory !== 'function') {\n      throw new InvalidArgumentError('Proxy opts.clientFactory must be a function.');\n    }\n    const url = this.#getUrl(opts);\n    const {\n      href,\n      origin,\n      port,\n      protocol,\n      username,\n      password,\n      hostname: proxyHostname\n    } = url;\n    this[kProxy] = {\n      uri: href,\n      protocol\n    };\n    this[kInterceptors] = opts.interceptors?.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];\n    this[kRequestTls] = opts.requestTls;\n    this[kProxyTls] = opts.proxyTls;\n    this[kProxyHeaders] = opts.headers || {};\n    if (opts.auth && opts.token) {\n      throw new InvalidArgumentError('opts.auth cannot be used in combination with opts.token');\n    } else if (opts.auth) {\n      /* @deprecated in favour of opts.token */\n      this[kProxyHeaders]['proxy-authorization'] = `Basic ${opts.auth}`;\n    } else if (opts.token) {\n      this[kProxyHeaders]['proxy-authorization'] = opts.token;\n    } else if (username && password) {\n      this[kProxyHeaders]['proxy-authorization'] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString('base64')}`;\n    }\n    const connect = buildConnector({\n      ...opts.proxyTls\n    });\n    this[kConnectEndpoint] = buildConnector({\n      ...opts.requestTls\n    });\n    this[kClient] = clientFactory(url, {\n      connect\n    });\n    this[kAgent] = new Agent({\n      ...opts,\n      connect: async (opts, callback) => {\n        let requestedPath = opts.host;\n        if (!opts.port) {\n          requestedPath += `:${defaultProtocolPort(opts.protocol)}`;\n        }\n        try {\n          const {\n            socket,\n            statusCode\n          } = await this[kClient].connect({\n            origin,\n            port,\n            path: requestedPath,\n            signal: opts.signal,\n            headers: {\n              ...this[kProxyHeaders],\n              host: opts.host\n            },\n            servername: this[kProxyTls]?.servername || proxyHostname\n          });\n          if (statusCode !== 200) {\n            socket.on('error', () => {}).destroy();\n            callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));\n          }\n          if (opts.protocol !== 'https:') {\n            callback(null, socket);\n            return;\n          }\n          let servername;\n          if (this[kRequestTls]) {\n            servername = this[kRequestTls].servername;\n          } else {\n            servername = opts.servername;\n          }\n          this[kConnectEndpoint]({\n            ...opts,\n            servername,\n            httpSocket: socket\n          }, callback);\n        } catch (err) {\n          if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n            // Throw a custom error to avoid loop in client.js#connect\n            callback(new SecureProxyConnectionError(err));\n          } else {\n            callback(err);\n          }\n        }\n      }\n    });\n  }\n  dispatch(opts, handler) {\n    const headers = buildHeaders(opts.headers);\n    throwIfProxyAuthIsSent(headers);\n    if (headers && !('host' in headers) && !('Host' in headers)) {\n      const {\n        host\n      } = new URL(opts.origin);\n      headers.host = host;\n    }\n    return this[kAgent].dispatch({\n      ...opts,\n      headers\n    }, handler);\n  }\n\n  /**\n   * @param {import('../types/proxy-agent').ProxyAgent.Options | string | URL} opts\n   * @returns {URL}\n   */\n  #getUrl(opts) {\n    if (typeof opts === 'string') {\n      return new URL(opts);\n    } else if (opts instanceof URL) {\n      return opts;\n    } else {\n      return new URL(opts.uri);\n    }\n  }\n  async [kClose]() {\n    await this[kAgent].close();\n    await this[kClient].close();\n  }\n  async [kDestroy]() {\n    await this[kAgent].destroy();\n    await this[kClient].destroy();\n  }\n}\n\n/**\n * @param {string[] | Record<string, string>} headers\n * @returns {Record<string, string>}\n */\nfunction buildHeaders(headers) {\n  // When using undici.fetch, the headers list is stored\n  // as an array.\n  if (Array.isArray(headers)) {\n    /** @type {Record<string, string>} */\n    const headersPair = {};\n    for (let i = 0; i < headers.length; i += 2) {\n      headersPair[headers[i]] = headers[i + 1];\n    }\n    return headersPair;\n  }\n  return headers;\n}\n\n/**\n * @param {Record<string, string>} headers\n *\n * Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers\n * Nevertheless, it was changed and to avoid a security vulnerability by end users\n * this check was created.\n * It should be removed in the next major version for performance reasons\n */\nfunction throwIfProxyAuthIsSent(headers) {\n  const existProxyAuth = headers && Object.keys(headers).find(key => key.toLowerCase() === 'proxy-authorization');\n  if (existProxyAuth) {\n    throw new InvalidArgumentError('Proxy-Authorization should be sent in ProxyAgent constructor');\n  }\n}\nmodule.exports = ProxyAgent;","map":{"version":3,"names":["kProxy","kClose","kDestroy","kInterceptors","require","URL","Agent","Pool","DispatcherBase","InvalidArgumentError","RequestAbortedError","SecureProxyConnectionError","buildConnector","kAgent","Symbol","kClient","kProxyHeaders","kRequestTls","kProxyTls","kConnectEndpoint","defaultProtocolPort","protocol","defaultFactory","origin","opts","ProxyAgent","constructor","uri","clientFactory","url","getUrl","href","port","username","password","hostname","proxyHostname","interceptors","Array","isArray","requestTls","proxyTls","headers","auth","token","Buffer","from","decodeURIComponent","toString","connect","callback","requestedPath","host","socket","statusCode","path","signal","servername","on","destroy","httpSocket","err","code","dispatch","handler","buildHeaders","throwIfProxyAuthIsSent","#getUrl","close","headersPair","i","length","existProxyAuth","Object","keys","find","key","toLowerCase","module","exports"],"sources":["/Users/nataliia/PussyProjects/react-app/node_modules/undici/lib/dispatcher/proxy-agent.js"],"sourcesContent":["'use strict'\n\nconst { kProxy, kClose, kDestroy, kInterceptors } = require('../core/symbols')\nconst { URL } = require('node:url')\nconst Agent = require('./agent')\nconst Pool = require('./pool')\nconst DispatcherBase = require('./dispatcher-base')\nconst { InvalidArgumentError, RequestAbortedError, SecureProxyConnectionError } = require('../core/errors')\nconst buildConnector = require('../core/connect')\n\nconst kAgent = Symbol('proxy agent')\nconst kClient = Symbol('proxy client')\nconst kProxyHeaders = Symbol('proxy headers')\nconst kRequestTls = Symbol('request tls settings')\nconst kProxyTls = Symbol('proxy tls settings')\nconst kConnectEndpoint = Symbol('connect endpoint function')\n\nfunction defaultProtocolPort (protocol) {\n  return protocol === 'https:' ? 443 : 80\n}\n\nfunction defaultFactory (origin, opts) {\n  return new Pool(origin, opts)\n}\n\nclass ProxyAgent extends DispatcherBase {\n  constructor (opts) {\n    super()\n\n    if (!opts || (typeof opts === 'object' && !(opts instanceof URL) && !opts.uri)) {\n      throw new InvalidArgumentError('Proxy uri is mandatory')\n    }\n\n    const { clientFactory = defaultFactory } = opts\n    if (typeof clientFactory !== 'function') {\n      throw new InvalidArgumentError('Proxy opts.clientFactory must be a function.')\n    }\n\n    const url = this.#getUrl(opts)\n    const { href, origin, port, protocol, username, password, hostname: proxyHostname } = url\n\n    this[kProxy] = { uri: href, protocol }\n    this[kInterceptors] = opts.interceptors?.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent)\n      ? opts.interceptors.ProxyAgent\n      : []\n    this[kRequestTls] = opts.requestTls\n    this[kProxyTls] = opts.proxyTls\n    this[kProxyHeaders] = opts.headers || {}\n\n    if (opts.auth && opts.token) {\n      throw new InvalidArgumentError('opts.auth cannot be used in combination with opts.token')\n    } else if (opts.auth) {\n      /* @deprecated in favour of opts.token */\n      this[kProxyHeaders]['proxy-authorization'] = `Basic ${opts.auth}`\n    } else if (opts.token) {\n      this[kProxyHeaders]['proxy-authorization'] = opts.token\n    } else if (username && password) {\n      this[kProxyHeaders]['proxy-authorization'] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString('base64')}`\n    }\n\n    const connect = buildConnector({ ...opts.proxyTls })\n    this[kConnectEndpoint] = buildConnector({ ...opts.requestTls })\n    this[kClient] = clientFactory(url, { connect })\n    this[kAgent] = new Agent({\n      ...opts,\n      connect: async (opts, callback) => {\n        let requestedPath = opts.host\n        if (!opts.port) {\n          requestedPath += `:${defaultProtocolPort(opts.protocol)}`\n        }\n        try {\n          const { socket, statusCode } = await this[kClient].connect({\n            origin,\n            port,\n            path: requestedPath,\n            signal: opts.signal,\n            headers: {\n              ...this[kProxyHeaders],\n              host: opts.host\n            },\n            servername: this[kProxyTls]?.servername || proxyHostname\n          })\n          if (statusCode !== 200) {\n            socket.on('error', () => {}).destroy()\n            callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`))\n          }\n          if (opts.protocol !== 'https:') {\n            callback(null, socket)\n            return\n          }\n          let servername\n          if (this[kRequestTls]) {\n            servername = this[kRequestTls].servername\n          } else {\n            servername = opts.servername\n          }\n          this[kConnectEndpoint]({ ...opts, servername, httpSocket: socket }, callback)\n        } catch (err) {\n          if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n            // Throw a custom error to avoid loop in client.js#connect\n            callback(new SecureProxyConnectionError(err))\n          } else {\n            callback(err)\n          }\n        }\n      }\n    })\n  }\n\n  dispatch (opts, handler) {\n    const headers = buildHeaders(opts.headers)\n    throwIfProxyAuthIsSent(headers)\n\n    if (headers && !('host' in headers) && !('Host' in headers)) {\n      const { host } = new URL(opts.origin)\n      headers.host = host\n    }\n\n    return this[kAgent].dispatch(\n      {\n        ...opts,\n        headers\n      },\n      handler\n    )\n  }\n\n  /**\n   * @param {import('../types/proxy-agent').ProxyAgent.Options | string | URL} opts\n   * @returns {URL}\n   */\n  #getUrl (opts) {\n    if (typeof opts === 'string') {\n      return new URL(opts)\n    } else if (opts instanceof URL) {\n      return opts\n    } else {\n      return new URL(opts.uri)\n    }\n  }\n\n  async [kClose] () {\n    await this[kAgent].close()\n    await this[kClient].close()\n  }\n\n  async [kDestroy] () {\n    await this[kAgent].destroy()\n    await this[kClient].destroy()\n  }\n}\n\n/**\n * @param {string[] | Record<string, string>} headers\n * @returns {Record<string, string>}\n */\nfunction buildHeaders (headers) {\n  // When using undici.fetch, the headers list is stored\n  // as an array.\n  if (Array.isArray(headers)) {\n    /** @type {Record<string, string>} */\n    const headersPair = {}\n\n    for (let i = 0; i < headers.length; i += 2) {\n      headersPair[headers[i]] = headers[i + 1]\n    }\n\n    return headersPair\n  }\n\n  return headers\n}\n\n/**\n * @param {Record<string, string>} headers\n *\n * Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers\n * Nevertheless, it was changed and to avoid a security vulnerability by end users\n * this check was created.\n * It should be removed in the next major version for performance reasons\n */\nfunction throwIfProxyAuthIsSent (headers) {\n  const existProxyAuth = headers && Object.keys(headers)\n    .find((key) => key.toLowerCase() === 'proxy-authorization')\n  if (existProxyAuth) {\n    throw new InvalidArgumentError('Proxy-Authorization should be sent in ProxyAgent constructor')\n  }\n}\n\nmodule.exports = ProxyAgent\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
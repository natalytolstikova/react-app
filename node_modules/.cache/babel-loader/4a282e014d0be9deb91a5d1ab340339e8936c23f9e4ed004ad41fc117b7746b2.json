{"ast":null,"code":"'use strict';\n\n/* global WebAssembly */\nconst assert = require('node:assert');\nconst util = require('../core/util.js');\nconst {\n  channels\n} = require('../core/diagnostics.js');\nconst timers = require('../util/timers.js');\nconst {\n  RequestContentLengthMismatchError,\n  ResponseContentLengthMismatchError,\n  RequestAbortedError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  SocketError,\n  InformationalError,\n  BodyTimeoutError,\n  HTTPParserError,\n  ResponseExceededMaxSizeError\n} = require('../core/errors.js');\nconst {\n  kUrl,\n  kReset,\n  kClient,\n  kParser,\n  kBlocking,\n  kRunning,\n  kPending,\n  kSize,\n  kWriting,\n  kQueue,\n  kNoRef,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kPipelining,\n  kSocket,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kMaxRequests,\n  kCounter,\n  kMaxResponseSize,\n  kOnError,\n  kResume,\n  kHTTPContext\n} = require('../core/symbols.js');\nconst constants = require('../llhttp/constants.js');\nconst EMPTY_BUF = Buffer.alloc(0);\nconst FastBuffer = Buffer[Symbol.species];\nconst addListener = util.addListener;\nconst removeAllListeners = util.removeAllListeners;\nlet extractBody;\nasync function lazyllhttp() {\n  const llhttpWasmData = process.env.JEST_WORKER_ID ? require('../llhttp/llhttp-wasm.js') : undefined;\n  let mod;\n  try {\n    mod = await WebAssembly.compile(require('../llhttp/llhttp_simd-wasm.js'));\n  } catch (e) {\n    /* istanbul ignore next */\n\n    // We could check if the error was caused by the simd option not\n    // being enabled, but the occurring of this other error\n    // * https://github.com/emscripten-core/emscripten/issues/11495\n    // got me to remove that check to avoid breaking Node 12.\n    mod = await WebAssembly.compile(llhttpWasmData || require('../llhttp/llhttp-wasm.js'));\n  }\n  return await WebAssembly.instantiate(mod, {\n    env: {\n      /* eslint-disable camelcase */\n\n      wasm_on_url: (p, at, len) => {\n        /* istanbul ignore next */\n        return 0;\n      },\n      wasm_on_status: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n        return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n      },\n      wasm_on_message_begin: p => {\n        assert.strictEqual(currentParser.ptr, p);\n        return currentParser.onMessageBegin() || 0;\n      },\n      wasm_on_header_field: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n        return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n      },\n      wasm_on_header_value: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n        return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n      },\n      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {\n        assert.strictEqual(currentParser.ptr, p);\n        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;\n      },\n      wasm_on_body: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n        return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n      },\n      wasm_on_message_complete: p => {\n        assert.strictEqual(currentParser.ptr, p);\n        return currentParser.onMessageComplete() || 0;\n      }\n\n      /* eslint-enable camelcase */\n    }\n  });\n}\nlet llhttpInstance = null;\nlet llhttpPromise = lazyllhttp();\nllhttpPromise.catch();\nlet currentParser = null;\nlet currentBufferRef = null;\nlet currentBufferSize = 0;\nlet currentBufferPtr = null;\nconst TIMEOUT_HEADERS = 1;\nconst TIMEOUT_BODY = 2;\nconst TIMEOUT_IDLE = 3;\nclass Parser {\n  constructor(client, socket, {\n    exports\n  }) {\n    assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);\n    this.llhttp = exports;\n    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);\n    this.client = client;\n    this.socket = socket;\n    this.timeout = null;\n    this.timeoutValue = null;\n    this.timeoutType = null;\n    this.statusCode = null;\n    this.statusText = '';\n    this.upgrade = false;\n    this.headers = [];\n    this.headersSize = 0;\n    this.headersMaxSize = client[kMaxHeadersSize];\n    this.shouldKeepAlive = false;\n    this.paused = false;\n    this.resume = this.resume.bind(this);\n    this.bytesRead = 0;\n    this.keepAlive = '';\n    this.contentLength = '';\n    this.connection = '';\n    this.maxResponseSize = client[kMaxResponseSize];\n  }\n  setTimeout(value, type) {\n    this.timeoutType = type;\n    if (value !== this.timeoutValue) {\n      timers.clearTimeout(this.timeout);\n      if (value) {\n        this.timeout = timers.setTimeout(onParserTimeout, value, this);\n        // istanbul ignore else: only for jest\n        if (this.timeout.unref) {\n          this.timeout.unref();\n        }\n      } else {\n        this.timeout = null;\n      }\n      this.timeoutValue = value;\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n  }\n  resume() {\n    if (this.socket.destroyed || !this.paused) {\n      return;\n    }\n    assert(this.ptr != null);\n    assert(currentParser == null);\n    this.llhttp.llhttp_resume(this.ptr);\n    assert(this.timeoutType === TIMEOUT_BODY);\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n    this.paused = false;\n    this.execute(this.socket.read() || EMPTY_BUF); // Flush parser.\n    this.readMore();\n  }\n  readMore() {\n    while (!this.paused && this.ptr) {\n      const chunk = this.socket.read();\n      if (chunk === null) {\n        break;\n      }\n      this.execute(chunk);\n    }\n  }\n  execute(data) {\n    assert(this.ptr != null);\n    assert(currentParser == null);\n    assert(!this.paused);\n    const {\n      socket,\n      llhttp\n    } = this;\n    if (data.length > currentBufferSize) {\n      if (currentBufferPtr) {\n        llhttp.free(currentBufferPtr);\n      }\n      currentBufferSize = Math.ceil(data.length / 4096) * 4096;\n      currentBufferPtr = llhttp.malloc(currentBufferSize);\n    }\n    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);\n\n    // Call `execute` on the wasm parser.\n    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n    // and finally the length of bytes to parse.\n    // The return value is an error code or `constants.ERROR.OK`.\n    try {\n      let ret;\n      try {\n        currentBufferRef = data;\n        currentParser = this;\n        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);\n        /* eslint-disable-next-line no-useless-catch */\n      } catch (err) {\n        /* istanbul ignore next: difficult to make a test case for */\n        throw err;\n      } finally {\n        currentParser = null;\n        currentBufferRef = null;\n      }\n      const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;\n      if (ret === constants.ERROR.PAUSED_UPGRADE) {\n        this.onUpgrade(data.slice(offset));\n      } else if (ret === constants.ERROR.PAUSED) {\n        this.paused = true;\n        socket.unshift(data.slice(offset));\n      } else if (ret !== constants.ERROR.OK) {\n        const ptr = llhttp.llhttp_get_error_reason(this.ptr);\n        let message = '';\n        /* istanbul ignore else: difficult to make a test case for */\n        if (ptr) {\n          const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);\n          message = 'Response does not match the HTTP/1.1 protocol (' + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ')';\n        }\n        throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));\n      }\n    } catch (err) {\n      util.destroy(socket, err);\n    }\n  }\n  destroy() {\n    assert(this.ptr != null);\n    assert(currentParser == null);\n    this.llhttp.llhttp_free(this.ptr);\n    this.ptr = null;\n    timers.clearTimeout(this.timeout);\n    this.timeout = null;\n    this.timeoutValue = null;\n    this.timeoutType = null;\n    this.paused = false;\n  }\n  onStatus(buf) {\n    this.statusText = buf.toString();\n  }\n  onMessageBegin() {\n    const {\n      socket,\n      client\n    } = this;\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1;\n    }\n    const request = client[kQueue][client[kRunningIdx]];\n    if (!request) {\n      return -1;\n    }\n    request.onResponseStarted();\n  }\n  onHeaderField(buf) {\n    const len = this.headers.length;\n    if ((len & 1) === 0) {\n      this.headers.push(buf);\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);\n    }\n    this.trackHeader(buf.length);\n  }\n  onHeaderValue(buf) {\n    let len = this.headers.length;\n    if ((len & 1) === 1) {\n      this.headers.push(buf);\n      len += 1;\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);\n    }\n    const key = this.headers[len - 2];\n    if (key.length === 10) {\n      const headerName = util.bufferToLowerCasedHeaderName(key);\n      if (headerName === 'keep-alive') {\n        this.keepAlive += buf.toString();\n      } else if (headerName === 'connection') {\n        this.connection += buf.toString();\n      }\n    } else if (key.length === 14 && util.bufferToLowerCasedHeaderName(key) === 'content-length') {\n      this.contentLength += buf.toString();\n    }\n    this.trackHeader(buf.length);\n  }\n  trackHeader(len) {\n    this.headersSize += len;\n    if (this.headersSize >= this.headersMaxSize) {\n      util.destroy(this.socket, new HeadersOverflowError());\n    }\n  }\n  onUpgrade(head) {\n    const {\n      upgrade,\n      client,\n      socket,\n      headers,\n      statusCode\n    } = this;\n    assert(upgrade);\n    const request = client[kQueue][client[kRunningIdx]];\n    assert(request);\n    assert(!socket.destroyed);\n    assert(socket === client[kSocket]);\n    assert(!this.paused);\n    assert(request.upgrade || request.method === 'CONNECT');\n    this.statusCode = null;\n    this.statusText = '';\n    this.shouldKeepAlive = null;\n    assert(this.headers.length % 2 === 0);\n    this.headers = [];\n    this.headersSize = 0;\n    socket.unshift(head);\n    socket[kParser].destroy();\n    socket[kParser] = null;\n    socket[kClient] = null;\n    socket[kError] = null;\n    removeAllListeners(socket);\n    client[kSocket] = null;\n    client[kHTTPContext] = null; // TODO (fix): This is hacky...\n    client[kQueue][client[kRunningIdx]++] = null;\n    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'));\n    try {\n      request.onUpgrade(statusCode, headers, socket);\n    } catch (err) {\n      util.destroy(socket, err);\n    }\n    client[kResume]();\n  }\n  onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {\n    const {\n      client,\n      socket,\n      headers,\n      statusText\n    } = this;\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1;\n    }\n    const request = client[kQueue][client[kRunningIdx]];\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (!request) {\n      return -1;\n    }\n    assert(!this.upgrade);\n    assert(this.statusCode < 200);\n    if (statusCode === 100) {\n      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)));\n      return -1;\n    }\n\n    /* this can only happen if server is misbehaving */\n    if (upgrade && !request.upgrade) {\n      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)));\n      return -1;\n    }\n    assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);\n    this.statusCode = statusCode;\n    this.shouldKeepAlive = shouldKeepAlive ||\n    // Override llhttp value which does not allow keepAlive for HEAD.\n    request.method === 'HEAD' && !socket[kReset] && this.connection.toLowerCase() === 'keep-alive';\n    if (this.statusCode >= 200) {\n      const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];\n      this.setTimeout(bodyTimeout, TIMEOUT_BODY);\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n    if (request.method === 'CONNECT') {\n      assert(client[kRunning] === 1);\n      this.upgrade = true;\n      return 2;\n    }\n    if (upgrade) {\n      assert(client[kRunning] === 1);\n      this.upgrade = true;\n      return 2;\n    }\n    assert(this.headers.length % 2 === 0);\n    this.headers = [];\n    this.headersSize = 0;\n    if (this.shouldKeepAlive && client[kPipelining]) {\n      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;\n      if (keepAliveTimeout != null) {\n        const timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);\n        if (timeout <= 0) {\n          socket[kReset] = true;\n        } else {\n          client[kKeepAliveTimeoutValue] = timeout;\n        }\n      } else {\n        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];\n      }\n    } else {\n      // Stop more requests from being dispatched.\n      socket[kReset] = true;\n    }\n    const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;\n    if (request.aborted) {\n      return -1;\n    }\n    if (request.method === 'HEAD') {\n      return 1;\n    }\n    if (statusCode < 200) {\n      return 1;\n    }\n    if (socket[kBlocking]) {\n      socket[kBlocking] = false;\n      client[kResume]();\n    }\n    return pause ? constants.ERROR.PAUSED : 0;\n  }\n  onBody(buf) {\n    const {\n      client,\n      socket,\n      statusCode,\n      maxResponseSize\n    } = this;\n    if (socket.destroyed) {\n      return -1;\n    }\n    const request = client[kQueue][client[kRunningIdx]];\n    assert(request);\n    assert.strictEqual(this.timeoutType, TIMEOUT_BODY);\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n    assert(statusCode >= 200);\n    if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {\n      util.destroy(socket, new ResponseExceededMaxSizeError());\n      return -1;\n    }\n    this.bytesRead += buf.length;\n    if (request.onData(buf) === false) {\n      return constants.ERROR.PAUSED;\n    }\n  }\n  onMessageComplete() {\n    const {\n      client,\n      socket,\n      statusCode,\n      upgrade,\n      headers,\n      contentLength,\n      bytesRead,\n      shouldKeepAlive\n    } = this;\n    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n      return -1;\n    }\n    if (upgrade) {\n      return;\n    }\n    const request = client[kQueue][client[kRunningIdx]];\n    assert(request);\n    assert(statusCode >= 100);\n    this.statusCode = null;\n    this.statusText = '';\n    this.bytesRead = 0;\n    this.contentLength = '';\n    this.keepAlive = '';\n    this.connection = '';\n    assert(this.headers.length % 2 === 0);\n    this.headers = [];\n    this.headersSize = 0;\n    if (statusCode < 200) {\n      return;\n    }\n\n    /* istanbul ignore next: should be handled by llhttp? */\n    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n      util.destroy(socket, new ResponseContentLengthMismatchError());\n      return -1;\n    }\n    request.onComplete(headers);\n    client[kQueue][client[kRunningIdx]++] = null;\n    if (socket[kWriting]) {\n      assert.strictEqual(client[kRunning], 0);\n      // Response completed before request.\n      util.destroy(socket, new InformationalError('reset'));\n      return constants.ERROR.PAUSED;\n    } else if (!shouldKeepAlive) {\n      util.destroy(socket, new InformationalError('reset'));\n      return constants.ERROR.PAUSED;\n    } else if (socket[kReset] && client[kRunning] === 0) {\n      // Destroy socket once all requests have completed.\n      // The request at the tail of the pipeline is the one\n      // that requested reset and no further requests should\n      // have been queued since then.\n      util.destroy(socket, new InformationalError('reset'));\n      return constants.ERROR.PAUSED;\n    } else if (client[kPipelining] == null || client[kPipelining] === 1) {\n      // We must wait a full event loop cycle to reuse this socket to make sure\n      // that non-spec compliant servers are not closing the connection even if they\n      // said they won't.\n      setImmediate(() => client[kResume]());\n    } else {\n      client[kResume]();\n    }\n  }\n}\nfunction onParserTimeout(parser) {\n  const {\n    socket,\n    timeoutType,\n    client\n  } = parser;\n\n  /* istanbul ignore else */\n  if (timeoutType === TIMEOUT_HEADERS) {\n    if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {\n      assert(!parser.paused, 'cannot be paused while waiting for headers');\n      util.destroy(socket, new HeadersTimeoutError());\n    }\n  } else if (timeoutType === TIMEOUT_BODY) {\n    if (!parser.paused) {\n      util.destroy(socket, new BodyTimeoutError());\n    }\n  } else if (timeoutType === TIMEOUT_IDLE) {\n    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);\n    util.destroy(socket, new InformationalError('socket idle timeout'));\n  }\n}\nasync function connectH1(client, socket) {\n  client[kSocket] = socket;\n  if (!llhttpInstance) {\n    llhttpInstance = await llhttpPromise;\n    llhttpPromise = null;\n  }\n  socket[kNoRef] = false;\n  socket[kWriting] = false;\n  socket[kReset] = false;\n  socket[kBlocking] = false;\n  socket[kParser] = new Parser(client, socket, llhttpInstance);\n  addListener(socket, 'error', function (err) {\n    const parser = this[kParser];\n    assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID');\n\n    // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n    // to the user.\n    if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {\n      // We treat all incoming data so for as a valid response.\n      parser.onMessageComplete();\n      return;\n    }\n    this[kError] = err;\n    this[kClient][kOnError](err);\n  });\n  addListener(socket, 'readable', function () {\n    const parser = this[kParser];\n    if (parser) {\n      parser.readMore();\n    }\n  });\n  addListener(socket, 'end', function () {\n    const parser = this[kParser];\n    if (parser.statusCode && !parser.shouldKeepAlive) {\n      // We treat all incoming data so far as a valid response.\n      parser.onMessageComplete();\n      return;\n    }\n    util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)));\n  });\n  addListener(socket, 'close', function () {\n    const client = this[kClient];\n    const parser = this[kParser];\n    if (parser) {\n      if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {\n        // We treat all incoming data so far as a valid response.\n        parser.onMessageComplete();\n      }\n      this[kParser].destroy();\n      this[kParser] = null;\n    }\n    const err = this[kError] || new SocketError('closed', util.getSocketInfo(this));\n    client[kSocket] = null;\n    client[kHTTPContext] = null; // TODO (fix): This is hacky...\n\n    if (client.destroyed) {\n      assert(client[kPending] === 0);\n\n      // Fail entire queue.\n      const requests = client[kQueue].splice(client[kRunningIdx]);\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i];\n        util.errorRequest(client, request, err);\n      }\n    } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {\n      // Fail head of pipeline.\n      const request = client[kQueue][client[kRunningIdx]];\n      client[kQueue][client[kRunningIdx]++] = null;\n      util.errorRequest(client, request, err);\n    }\n    client[kPendingIdx] = client[kRunningIdx];\n    assert(client[kRunning] === 0);\n    client.emit('disconnect', client[kUrl], [client], err);\n    client[kResume]();\n  });\n  let closed = false;\n  socket.on('close', () => {\n    closed = true;\n  });\n  return {\n    version: 'h1',\n    defaultPipelining: 1,\n    write(...args) {\n      return writeH1(client, ...args);\n    },\n    resume() {\n      resumeH1(client);\n    },\n    destroy(err, callback) {\n      if (closed) {\n        queueMicrotask(callback);\n      } else {\n        socket.destroy(err).on('close', callback);\n      }\n    },\n    get destroyed() {\n      return socket.destroyed;\n    },\n    busy(request) {\n      if (socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n        return true;\n      }\n      if (request) {\n        if (client[kRunning] > 0 && !request.idempotent) {\n          // Non-idempotent request cannot be retried.\n          // Ensure that no other requests are inflight and\n          // could cause failure.\n          return true;\n        }\n        if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {\n          // Don't dispatch an upgrade until all preceding requests have completed.\n          // A misbehaving server might upgrade the connection before all pipelined\n          // request has completed.\n          return true;\n        }\n        if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body) || util.isFormDataLike(request.body))) {\n          // Request with stream or iterator body can error while other requests\n          // are inflight and indirectly error those as well.\n          // Ensure this doesn't happen by waiting for inflight\n          // to complete before dispatching.\n\n          // Request with stream or iterator body cannot be retried.\n          // Ensure that no other requests are inflight and\n          // could cause failure.\n          return true;\n        }\n      }\n      return false;\n    }\n  };\n}\nfunction resumeH1(client) {\n  const socket = client[kSocket];\n  if (socket && !socket.destroyed) {\n    if (client[kSize] === 0) {\n      if (!socket[kNoRef] && socket.unref) {\n        socket.unref();\n        socket[kNoRef] = true;\n      }\n    } else if (socket[kNoRef] && socket.ref) {\n      socket.ref();\n      socket[kNoRef] = false;\n    }\n    if (client[kSize] === 0) {\n      if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {\n        socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);\n      }\n    } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n      if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n        const request = client[kQueue][client[kRunningIdx]];\n        const headersTimeout = request.headersTimeout != null ? request.headersTimeout : client[kHeadersTimeout];\n        socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);\n      }\n    }\n  }\n}\n\n// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2\nfunction shouldSendContentLength(method) {\n  return method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS' && method !== 'TRACE' && method !== 'CONNECT';\n}\nfunction writeH1(client, request) {\n  const {\n    method,\n    path,\n    host,\n    upgrade,\n    blocking,\n    reset\n  } = request;\n  let {\n    body,\n    headers,\n    contentLength\n  } = request;\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = method === 'PUT' || method === 'POST' || method === 'PATCH';\n  if (util.isFormDataLike(body)) {\n    if (!extractBody) {\n      extractBody = require('../web/fetch/body.js').extractBody;\n    }\n    const [bodyStream, contentType] = extractBody(body);\n    if (request.contentType == null) {\n      headers.push('content-type', contentType);\n    }\n    body = bodyStream.stream;\n    contentLength = bodyStream.length;\n  } else if (util.isBlobLike(body) && request.contentType == null && body.type) {\n    headers.push('content-type', body.type);\n  }\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0);\n  }\n  const bodyLength = util.bodyLength(body);\n  contentLength = bodyLength ?? contentLength;\n  if (contentLength === null) {\n    contentLength = request.contentLength;\n  }\n  if (contentLength === 0 && !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null;\n  }\n\n  // https://github.com/nodejs/undici/issues/2046\n  // A user agent may send a Content-Length header with 0 value, this should be allowed.\n  if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      util.errorRequest(client, request, new RequestContentLengthMismatchError());\n      return false;\n    }\n    process.emitWarning(new RequestContentLengthMismatchError());\n  }\n  const socket = client[kSocket];\n  const abort = err => {\n    if (request.aborted || request.completed) {\n      return;\n    }\n    util.errorRequest(client, request, err || new RequestAbortedError());\n    util.destroy(body);\n    util.destroy(socket, new InformationalError('aborted'));\n  };\n  try {\n    request.onConnect(abort);\n  } catch (err) {\n    util.errorRequest(client, request, err);\n  }\n  if (request.aborted) {\n    return false;\n  }\n  if (method === 'HEAD') {\n    // https://github.com/mcollina/undici/issues/258\n    // Close after a HEAD request to interop with misbehaving servers\n    // that may send a body in the response.\n\n    socket[kReset] = true;\n  }\n  if (upgrade || method === 'CONNECT') {\n    // On CONNECT or upgrade, block pipeline from dispatching further\n    // requests on this connection.\n\n    socket[kReset] = true;\n  }\n  if (reset != null) {\n    socket[kReset] = reset;\n  }\n  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n    socket[kReset] = true;\n  }\n  if (blocking) {\n    socket[kBlocking] = true;\n  }\n  let header = `${method} ${path} HTTP/1.1\\r\\n`;\n  if (typeof host === 'string') {\n    header += `host: ${host}\\r\\n`;\n  } else {\n    header += client[kHostHeader];\n  }\n  if (upgrade) {\n    header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`;\n  } else if (client[kPipelining] && !socket[kReset]) {\n    header += 'connection: keep-alive\\r\\n';\n  } else {\n    header += 'connection: close\\r\\n';\n  }\n  if (Array.isArray(headers)) {\n    for (let n = 0; n < headers.length; n += 2) {\n      const key = headers[n + 0];\n      const val = headers[n + 1];\n      if (Array.isArray(val)) {\n        for (let i = 0; i < val.length; i++) {\n          header += `${key}: ${val[i]}\\r\\n`;\n        }\n      } else {\n        header += `${key}: ${val}\\r\\n`;\n      }\n    }\n  }\n  if (channels.sendHeaders.hasSubscribers) {\n    channels.sendHeaders.publish({\n      request,\n      headers: header,\n      socket\n    });\n  }\n\n  /* istanbul ignore else: assertion */\n  if (!body || bodyLength === 0) {\n    writeBuffer(abort, null, client, request, socket, contentLength, header, expectsPayload);\n  } else if (util.isBuffer(body)) {\n    writeBuffer(abort, body, client, request, socket, contentLength, header, expectsPayload);\n  } else if (util.isBlobLike(body)) {\n    if (typeof body.stream === 'function') {\n      writeIterable(abort, body.stream(), client, request, socket, contentLength, header, expectsPayload);\n    } else {\n      writeBlob(abort, body, client, request, socket, contentLength, header, expectsPayload);\n    }\n  } else if (util.isStream(body)) {\n    writeStream(abort, body, client, request, socket, contentLength, header, expectsPayload);\n  } else if (util.isIterable(body)) {\n    writeIterable(abort, body, client, request, socket, contentLength, header, expectsPayload);\n  } else {\n    assert(false);\n  }\n  return true;\n}\nfunction writeStream(abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined');\n  let finished = false;\n  const writer = new AsyncWriter({\n    abort,\n    socket,\n    request,\n    contentLength,\n    client,\n    expectsPayload,\n    header\n  });\n  const onData = function (chunk) {\n    if (finished) {\n      return;\n    }\n    try {\n      if (!writer.write(chunk) && this.pause) {\n        this.pause();\n      }\n    } catch (err) {\n      util.destroy(this, err);\n    }\n  };\n  const onDrain = function () {\n    if (finished) {\n      return;\n    }\n    if (body.resume) {\n      body.resume();\n    }\n  };\n  const onClose = function () {\n    // 'close' might be emitted *before* 'error' for\n    // broken streams. Wait a tick to avoid this case.\n    queueMicrotask(() => {\n      // It's only safe to remove 'error' listener after\n      // 'close'.\n      body.removeListener('error', onFinished);\n    });\n    if (!finished) {\n      const err = new RequestAbortedError();\n      queueMicrotask(() => onFinished(err));\n    }\n  };\n  const onFinished = function (err) {\n    if (finished) {\n      return;\n    }\n    finished = true;\n    assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);\n    socket.off('drain', onDrain).off('error', onFinished);\n    body.removeListener('data', onData).removeListener('end', onFinished).removeListener('close', onClose);\n    if (!err) {\n      try {\n        writer.end();\n      } catch (er) {\n        err = er;\n      }\n    }\n    writer.destroy(err);\n    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {\n      util.destroy(body, err);\n    } else {\n      util.destroy(body);\n    }\n  };\n  body.on('data', onData).on('end', onFinished).on('error', onFinished).on('close', onClose);\n  if (body.resume) {\n    body.resume();\n  }\n  socket.on('drain', onDrain).on('error', onFinished);\n  if (body.errorEmitted ?? body.errored) {\n    setImmediate(() => onFinished(body.errored));\n  } else if (body.endEmitted ?? body.readableEnded) {\n    setImmediate(() => onFinished(null));\n  }\n  if (body.closeEmitted ?? body.closed) {\n    setImmediate(onClose);\n  }\n}\nfunction writeBuffer(abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  try {\n    if (!body) {\n      if (contentLength === 0) {\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1');\n      } else {\n        assert(contentLength === null, 'no body must not have content length');\n        socket.write(`${header}\\r\\n`, 'latin1');\n      }\n    } else if (util.isBuffer(body)) {\n      assert(contentLength === body.byteLength, 'buffer body must have content length');\n      socket.cork();\n      socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1');\n      socket.write(body);\n      socket.uncork();\n      request.onBodySent(body);\n      if (!expectsPayload) {\n        socket[kReset] = true;\n      }\n    }\n    request.onRequestSent();\n    client[kResume]();\n  } catch (err) {\n    abort(err);\n  }\n}\nasync function writeBlob(abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  assert(contentLength === body.size, 'blob body must have content length');\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError();\n    }\n    const buffer = Buffer.from(await body.arrayBuffer());\n    socket.cork();\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1');\n    socket.write(buffer);\n    socket.uncork();\n    request.onBodySent(buffer);\n    request.onRequestSent();\n    if (!expectsPayload) {\n      socket[kReset] = true;\n    }\n    client[kResume]();\n  } catch (err) {\n    abort(err);\n  }\n}\nasync function writeIterable(abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined');\n  let callback = null;\n  function onDrain() {\n    if (callback) {\n      const cb = callback;\n      callback = null;\n      cb();\n    }\n  }\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null);\n    if (socket[kError]) {\n      reject(socket[kError]);\n    } else {\n      callback = resolve;\n    }\n  });\n  socket.on('close', onDrain).on('drain', onDrain);\n  const writer = new AsyncWriter({\n    abort,\n    socket,\n    request,\n    contentLength,\n    client,\n    expectsPayload,\n    header\n  });\n  try {\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError];\n      }\n      if (!writer.write(chunk)) {\n        await waitForDrain();\n      }\n    }\n    writer.end();\n  } catch (err) {\n    writer.destroy(err);\n  } finally {\n    socket.off('close', onDrain).off('drain', onDrain);\n  }\n}\nclass AsyncWriter {\n  constructor({\n    abort,\n    socket,\n    request,\n    contentLength,\n    client,\n    expectsPayload,\n    header\n  }) {\n    this.socket = socket;\n    this.request = request;\n    this.contentLength = contentLength;\n    this.client = client;\n    this.bytesWritten = 0;\n    this.expectsPayload = expectsPayload;\n    this.header = header;\n    this.abort = abort;\n    socket[kWriting] = true;\n  }\n  write(chunk) {\n    const {\n      socket,\n      request,\n      contentLength,\n      client,\n      bytesWritten,\n      expectsPayload,\n      header\n    } = this;\n    if (socket[kError]) {\n      throw socket[kError];\n    }\n    if (socket.destroyed) {\n      return false;\n    }\n    const len = Buffer.byteLength(chunk);\n    if (!len) {\n      return true;\n    }\n\n    // We should defer writing chunks.\n    if (contentLength !== null && bytesWritten + len > contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError();\n      }\n      process.emitWarning(new RequestContentLengthMismatchError());\n    }\n    socket.cork();\n    if (bytesWritten === 0) {\n      if (!expectsPayload) {\n        socket[kReset] = true;\n      }\n      if (contentLength === null) {\n        socket.write(`${header}transfer-encoding: chunked\\r\\n`, 'latin1');\n      } else {\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1');\n      }\n    }\n    if (contentLength === null) {\n      socket.write(`\\r\\n${len.toString(16)}\\r\\n`, 'latin1');\n    }\n    this.bytesWritten += len;\n    const ret = socket.write(chunk);\n    socket.uncork();\n    request.onBodySent(chunk);\n    if (!ret) {\n      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n        // istanbul ignore else: only for jest\n        if (socket[kParser].timeout.refresh) {\n          socket[kParser].timeout.refresh();\n        }\n      }\n    }\n    return ret;\n  }\n  end() {\n    const {\n      socket,\n      contentLength,\n      client,\n      bytesWritten,\n      expectsPayload,\n      header,\n      request\n    } = this;\n    request.onRequestSent();\n    socket[kWriting] = false;\n    if (socket[kError]) {\n      throw socket[kError];\n    }\n    if (socket.destroyed) {\n      return;\n    }\n    if (bytesWritten === 0) {\n      if (expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD send a Content-Length in a request message when\n        // no Transfer-Encoding is sent and the request method defines a meaning\n        // for an enclosed payload body.\n\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1');\n      } else {\n        socket.write(`${header}\\r\\n`, 'latin1');\n      }\n    } else if (contentLength === null) {\n      socket.write('\\r\\n0\\r\\n\\r\\n', 'latin1');\n    }\n    if (contentLength !== null && bytesWritten !== contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError();\n      } else {\n        process.emitWarning(new RequestContentLengthMismatchError());\n      }\n    }\n    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n      // istanbul ignore else: only for jest\n      if (socket[kParser].timeout.refresh) {\n        socket[kParser].timeout.refresh();\n      }\n    }\n    client[kResume]();\n  }\n  destroy(err) {\n    const {\n      socket,\n      client,\n      abort\n    } = this;\n    socket[kWriting] = false;\n    if (err) {\n      assert(client[kRunning] <= 1, 'pipeline should only contain this request');\n      abort(err);\n    }\n  }\n}\nmodule.exports = connectH1;","map":{"version":3,"names":["assert","require","util","channels","timers","RequestContentLengthMismatchError","ResponseContentLengthMismatchError","RequestAbortedError","HeadersTimeoutError","HeadersOverflowError","SocketError","InformationalError","BodyTimeoutError","HTTPParserError","ResponseExceededMaxSizeError","kUrl","kReset","kClient","kParser","kBlocking","kRunning","kPending","kSize","kWriting","kQueue","kNoRef","kKeepAliveDefaultTimeout","kHostHeader","kPendingIdx","kRunningIdx","kError","kPipelining","kSocket","kKeepAliveTimeoutValue","kMaxHeadersSize","kKeepAliveMaxTimeout","kKeepAliveTimeoutThreshold","kHeadersTimeout","kBodyTimeout","kStrictContentLength","kMaxRequests","kCounter","kMaxResponseSize","kOnError","kResume","kHTTPContext","constants","EMPTY_BUF","Buffer","alloc","FastBuffer","Symbol","species","addListener","removeAllListeners","extractBody","lazyllhttp","llhttpWasmData","process","env","JEST_WORKER_ID","undefined","mod","WebAssembly","compile","e","instantiate","wasm_on_url","p","at","len","wasm_on_status","strictEqual","currentParser","ptr","start","currentBufferPtr","currentBufferRef","byteOffset","onStatus","buffer","wasm_on_message_begin","onMessageBegin","wasm_on_header_field","onHeaderField","wasm_on_header_value","onHeaderValue","wasm_on_headers_complete","statusCode","upgrade","shouldKeepAlive","onHeadersComplete","Boolean","wasm_on_body","onBody","wasm_on_message_complete","onMessageComplete","llhttpInstance","llhttpPromise","catch","currentBufferSize","TIMEOUT_HEADERS","TIMEOUT_BODY","TIMEOUT_IDLE","Parser","constructor","client","socket","exports","Number","isFinite","llhttp","llhttp_alloc","TYPE","RESPONSE","timeout","timeoutValue","timeoutType","statusText","headers","headersSize","headersMaxSize","paused","resume","bind","bytesRead","keepAlive","contentLength","connection","maxResponseSize","setTimeout","value","type","clearTimeout","onParserTimeout","unref","refresh","destroyed","llhttp_resume","execute","read","readMore","chunk","data","length","free","Math","ceil","malloc","Uint8Array","memory","set","ret","llhttp_execute","err","offset","llhttp_get_error_pos","ERROR","PAUSED_UPGRADE","onUpgrade","slice","PAUSED","unshift","OK","llhttp_get_error_reason","message","indexOf","from","toString","destroy","llhttp_free","buf","request","onResponseStarted","push","concat","trackHeader","key","headerName","bufferToLowerCasedHeaderName","head","method","emit","getSocketInfo","toLowerCase","bodyTimeout","keepAliveTimeout","parseKeepAliveTimeout","min","pause","onHeaders","aborted","onData","parseInt","onComplete","setImmediate","parser","writableNeedDrain","connectH1","code","requests","splice","i","errorRequest","closed","on","version","defaultPipelining","write","args","writeH1","resumeH1","callback","queueMicrotask","busy","idempotent","bodyLength","body","isStream","isAsyncIterable","isFormDataLike","ref","headersTimeout","shouldSendContentLength","path","host","blocking","reset","expectsPayload","bodyStream","contentType","stream","isBlobLike","emitWarning","abort","completed","onConnect","header","Array","isArray","n","val","sendHeaders","hasSubscribers","publish","writeBuffer","isBuffer","writeIterable","writeBlob","writeStream","isIterable","finished","writer","AsyncWriter","onDrain","onClose","removeListener","onFinished","off","end","er","errorEmitted","errored","endEmitted","readableEnded","closeEmitted","byteLength","cork","uncork","onBodySent","onRequestSent","size","arrayBuffer","cb","waitForDrain","Promise","resolve","reject","bytesWritten","module"],"sources":["/Users/nataliia/PussyProjects/react-app/node_modules/undici/lib/dispatcher/client-h1.js"],"sourcesContent":["'use strict'\n\n/* global WebAssembly */\n\nconst assert = require('node:assert')\nconst util = require('../core/util.js')\nconst { channels } = require('../core/diagnostics.js')\nconst timers = require('../util/timers.js')\nconst {\n  RequestContentLengthMismatchError,\n  ResponseContentLengthMismatchError,\n  RequestAbortedError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  SocketError,\n  InformationalError,\n  BodyTimeoutError,\n  HTTPParserError,\n  ResponseExceededMaxSizeError\n} = require('../core/errors.js')\nconst {\n  kUrl,\n  kReset,\n  kClient,\n  kParser,\n  kBlocking,\n  kRunning,\n  kPending,\n  kSize,\n  kWriting,\n  kQueue,\n  kNoRef,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kPipelining,\n  kSocket,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kMaxRequests,\n  kCounter,\n  kMaxResponseSize,\n  kOnError,\n  kResume,\n  kHTTPContext\n} = require('../core/symbols.js')\n\nconst constants = require('../llhttp/constants.js')\nconst EMPTY_BUF = Buffer.alloc(0)\nconst FastBuffer = Buffer[Symbol.species]\nconst addListener = util.addListener\nconst removeAllListeners = util.removeAllListeners\n\nlet extractBody\n\nasync function lazyllhttp () {\n  const llhttpWasmData = process.env.JEST_WORKER_ID ? require('../llhttp/llhttp-wasm.js') : undefined\n\n  let mod\n  try {\n    mod = await WebAssembly.compile(require('../llhttp/llhttp_simd-wasm.js'))\n  } catch (e) {\n    /* istanbul ignore next */\n\n    // We could check if the error was caused by the simd option not\n    // being enabled, but the occurring of this other error\n    // * https://github.com/emscripten-core/emscripten/issues/11495\n    // got me to remove that check to avoid breaking Node 12.\n    mod = await WebAssembly.compile(llhttpWasmData || require('../llhttp/llhttp-wasm.js'))\n  }\n\n  return await WebAssembly.instantiate(mod, {\n    env: {\n      /* eslint-disable camelcase */\n\n      wasm_on_url: (p, at, len) => {\n        /* istanbul ignore next */\n        return 0\n      },\n      wasm_on_status: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_message_begin: (p) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onMessageBegin() || 0\n      },\n      wasm_on_header_field: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_header_value: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0\n      },\n      wasm_on_body: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_message_complete: (p) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onMessageComplete() || 0\n      }\n\n      /* eslint-enable camelcase */\n    }\n  })\n}\n\nlet llhttpInstance = null\nlet llhttpPromise = lazyllhttp()\nllhttpPromise.catch()\n\nlet currentParser = null\nlet currentBufferRef = null\nlet currentBufferSize = 0\nlet currentBufferPtr = null\n\nconst TIMEOUT_HEADERS = 1\nconst TIMEOUT_BODY = 2\nconst TIMEOUT_IDLE = 3\n\nclass Parser {\n  constructor (client, socket, { exports }) {\n    assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0)\n\n    this.llhttp = exports\n    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE)\n    this.client = client\n    this.socket = socket\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n    this.statusCode = null\n    this.statusText = ''\n    this.upgrade = false\n    this.headers = []\n    this.headersSize = 0\n    this.headersMaxSize = client[kMaxHeadersSize]\n    this.shouldKeepAlive = false\n    this.paused = false\n    this.resume = this.resume.bind(this)\n\n    this.bytesRead = 0\n\n    this.keepAlive = ''\n    this.contentLength = ''\n    this.connection = ''\n    this.maxResponseSize = client[kMaxResponseSize]\n  }\n\n  setTimeout (value, type) {\n    this.timeoutType = type\n    if (value !== this.timeoutValue) {\n      timers.clearTimeout(this.timeout)\n      if (value) {\n        this.timeout = timers.setTimeout(onParserTimeout, value, this)\n        // istanbul ignore else: only for jest\n        if (this.timeout.unref) {\n          this.timeout.unref()\n        }\n      } else {\n        this.timeout = null\n      }\n      this.timeoutValue = value\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n  }\n\n  resume () {\n    if (this.socket.destroyed || !this.paused) {\n      return\n    }\n\n    assert(this.ptr != null)\n    assert(currentParser == null)\n\n    this.llhttp.llhttp_resume(this.ptr)\n\n    assert(this.timeoutType === TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    this.paused = false\n    this.execute(this.socket.read() || EMPTY_BUF) // Flush parser.\n    this.readMore()\n  }\n\n  readMore () {\n    while (!this.paused && this.ptr) {\n      const chunk = this.socket.read()\n      if (chunk === null) {\n        break\n      }\n      this.execute(chunk)\n    }\n  }\n\n  execute (data) {\n    assert(this.ptr != null)\n    assert(currentParser == null)\n    assert(!this.paused)\n\n    const { socket, llhttp } = this\n\n    if (data.length > currentBufferSize) {\n      if (currentBufferPtr) {\n        llhttp.free(currentBufferPtr)\n      }\n      currentBufferSize = Math.ceil(data.length / 4096) * 4096\n      currentBufferPtr = llhttp.malloc(currentBufferSize)\n    }\n\n    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data)\n\n    // Call `execute` on the wasm parser.\n    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n    // and finally the length of bytes to parse.\n    // The return value is an error code or `constants.ERROR.OK`.\n    try {\n      let ret\n\n      try {\n        currentBufferRef = data\n        currentParser = this\n        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length)\n        /* eslint-disable-next-line no-useless-catch */\n      } catch (err) {\n        /* istanbul ignore next: difficult to make a test case for */\n        throw err\n      } finally {\n        currentParser = null\n        currentBufferRef = null\n      }\n\n      const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr\n\n      if (ret === constants.ERROR.PAUSED_UPGRADE) {\n        this.onUpgrade(data.slice(offset))\n      } else if (ret === constants.ERROR.PAUSED) {\n        this.paused = true\n        socket.unshift(data.slice(offset))\n      } else if (ret !== constants.ERROR.OK) {\n        const ptr = llhttp.llhttp_get_error_reason(this.ptr)\n        let message = ''\n        /* istanbul ignore else: difficult to make a test case for */\n        if (ptr) {\n          const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0)\n          message =\n            'Response does not match the HTTP/1.1 protocol (' +\n            Buffer.from(llhttp.memory.buffer, ptr, len).toString() +\n            ')'\n        }\n        throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset))\n      }\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n  }\n\n  destroy () {\n    assert(this.ptr != null)\n    assert(currentParser == null)\n\n    this.llhttp.llhttp_free(this.ptr)\n    this.ptr = null\n\n    timers.clearTimeout(this.timeout)\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n\n    this.paused = false\n  }\n\n  onStatus (buf) {\n    this.statusText = buf.toString()\n  }\n\n  onMessageBegin () {\n    const { socket, client } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    if (!request) {\n      return -1\n    }\n    request.onResponseStarted()\n  }\n\n  onHeaderField (buf) {\n    const len = this.headers.length\n\n    if ((len & 1) === 0) {\n      this.headers.push(buf)\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    this.trackHeader(buf.length)\n  }\n\n  onHeaderValue (buf) {\n    let len = this.headers.length\n\n    if ((len & 1) === 1) {\n      this.headers.push(buf)\n      len += 1\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    const key = this.headers[len - 2]\n    if (key.length === 10) {\n      const headerName = util.bufferToLowerCasedHeaderName(key)\n      if (headerName === 'keep-alive') {\n        this.keepAlive += buf.toString()\n      } else if (headerName === 'connection') {\n        this.connection += buf.toString()\n      }\n    } else if (key.length === 14 && util.bufferToLowerCasedHeaderName(key) === 'content-length') {\n      this.contentLength += buf.toString()\n    }\n\n    this.trackHeader(buf.length)\n  }\n\n  trackHeader (len) {\n    this.headersSize += len\n    if (this.headersSize >= this.headersMaxSize) {\n      util.destroy(this.socket, new HeadersOverflowError())\n    }\n  }\n\n  onUpgrade (head) {\n    const { upgrade, client, socket, headers, statusCode } = this\n\n    assert(upgrade)\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(!socket.destroyed)\n    assert(socket === client[kSocket])\n    assert(!this.paused)\n    assert(request.upgrade || request.method === 'CONNECT')\n\n    this.statusCode = null\n    this.statusText = ''\n    this.shouldKeepAlive = null\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    socket.unshift(head)\n\n    socket[kParser].destroy()\n    socket[kParser] = null\n\n    socket[kClient] = null\n    socket[kError] = null\n\n    removeAllListeners(socket)\n\n    client[kSocket] = null\n    client[kHTTPContext] = null // TODO (fix): This is hacky...\n    client[kQueue][client[kRunningIdx]++] = null\n    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'))\n\n    try {\n      request.onUpgrade(statusCode, headers, socket)\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n\n    client[kResume]()\n  }\n\n  onHeadersComplete (statusCode, upgrade, shouldKeepAlive) {\n    const { client, socket, headers, statusText } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (!request) {\n      return -1\n    }\n\n    assert(!this.upgrade)\n    assert(this.statusCode < 200)\n\n    if (statusCode === 100) {\n      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    /* this can only happen if server is misbehaving */\n    if (upgrade && !request.upgrade) {\n      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS)\n\n    this.statusCode = statusCode\n    this.shouldKeepAlive = (\n      shouldKeepAlive ||\n      // Override llhttp value which does not allow keepAlive for HEAD.\n      (request.method === 'HEAD' && !socket[kReset] && this.connection.toLowerCase() === 'keep-alive')\n    )\n\n    if (this.statusCode >= 200) {\n      const bodyTimeout = request.bodyTimeout != null\n        ? request.bodyTimeout\n        : client[kBodyTimeout]\n      this.setTimeout(bodyTimeout, TIMEOUT_BODY)\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    if (request.method === 'CONNECT') {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    if (upgrade) {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (this.shouldKeepAlive && client[kPipelining]) {\n      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null\n\n      if (keepAliveTimeout != null) {\n        const timeout = Math.min(\n          keepAliveTimeout - client[kKeepAliveTimeoutThreshold],\n          client[kKeepAliveMaxTimeout]\n        )\n        if (timeout <= 0) {\n          socket[kReset] = true\n        } else {\n          client[kKeepAliveTimeoutValue] = timeout\n        }\n      } else {\n        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout]\n      }\n    } else {\n      // Stop more requests from being dispatched.\n      socket[kReset] = true\n    }\n\n    const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false\n\n    if (request.aborted) {\n      return -1\n    }\n\n    if (request.method === 'HEAD') {\n      return 1\n    }\n\n    if (statusCode < 200) {\n      return 1\n    }\n\n    if (socket[kBlocking]) {\n      socket[kBlocking] = false\n      client[kResume]()\n    }\n\n    return pause ? constants.ERROR.PAUSED : 0\n  }\n\n  onBody (buf) {\n    const { client, socket, statusCode, maxResponseSize } = this\n\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert.strictEqual(this.timeoutType, TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    assert(statusCode >= 200)\n\n    if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {\n      util.destroy(socket, new ResponseExceededMaxSizeError())\n      return -1\n    }\n\n    this.bytesRead += buf.length\n\n    if (request.onData(buf) === false) {\n      return constants.ERROR.PAUSED\n    }\n  }\n\n  onMessageComplete () {\n    const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this\n\n    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n      return -1\n    }\n\n    if (upgrade) {\n      return\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(statusCode >= 100)\n\n    this.statusCode = null\n    this.statusText = ''\n    this.bytesRead = 0\n    this.contentLength = ''\n    this.keepAlive = ''\n    this.connection = ''\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (statusCode < 200) {\n      return\n    }\n\n    /* istanbul ignore next: should be handled by llhttp? */\n    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n      util.destroy(socket, new ResponseContentLengthMismatchError())\n      return -1\n    }\n\n    request.onComplete(headers)\n\n    client[kQueue][client[kRunningIdx]++] = null\n\n    if (socket[kWriting]) {\n      assert.strictEqual(client[kRunning], 0)\n      // Response completed before request.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (!shouldKeepAlive) {\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (socket[kReset] && client[kRunning] === 0) {\n      // Destroy socket once all requests have completed.\n      // The request at the tail of the pipeline is the one\n      // that requested reset and no further requests should\n      // have been queued since then.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (client[kPipelining] == null || client[kPipelining] === 1) {\n      // We must wait a full event loop cycle to reuse this socket to make sure\n      // that non-spec compliant servers are not closing the connection even if they\n      // said they won't.\n      setImmediate(() => client[kResume]())\n    } else {\n      client[kResume]()\n    }\n  }\n}\n\nfunction onParserTimeout (parser) {\n  const { socket, timeoutType, client } = parser\n\n  /* istanbul ignore else */\n  if (timeoutType === TIMEOUT_HEADERS) {\n    if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {\n      assert(!parser.paused, 'cannot be paused while waiting for headers')\n      util.destroy(socket, new HeadersTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_BODY) {\n    if (!parser.paused) {\n      util.destroy(socket, new BodyTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_IDLE) {\n    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue])\n    util.destroy(socket, new InformationalError('socket idle timeout'))\n  }\n}\n\nasync function connectH1 (client, socket) {\n  client[kSocket] = socket\n\n  if (!llhttpInstance) {\n    llhttpInstance = await llhttpPromise\n    llhttpPromise = null\n  }\n\n  socket[kNoRef] = false\n  socket[kWriting] = false\n  socket[kReset] = false\n  socket[kBlocking] = false\n  socket[kParser] = new Parser(client, socket, llhttpInstance)\n\n  addListener(socket, 'error', function (err) {\n    const parser = this[kParser]\n\n    assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n    // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n    // to the user.\n    if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {\n      // We treat all incoming data so for as a valid response.\n      parser.onMessageComplete()\n      return\n    }\n\n    this[kError] = err\n\n    this[kClient][kOnError](err)\n  })\n  addListener(socket, 'readable', function () {\n    const parser = this[kParser]\n\n    if (parser) {\n      parser.readMore()\n    }\n  })\n  addListener(socket, 'end', function () {\n    const parser = this[kParser]\n\n    if (parser.statusCode && !parser.shouldKeepAlive) {\n      // We treat all incoming data so far as a valid response.\n      parser.onMessageComplete()\n      return\n    }\n\n    util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)))\n  })\n  addListener(socket, 'close', function () {\n    const client = this[kClient]\n    const parser = this[kParser]\n\n    if (parser) {\n      if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {\n        // We treat all incoming data so far as a valid response.\n        parser.onMessageComplete()\n      }\n\n      this[kParser].destroy()\n      this[kParser] = null\n    }\n\n    const err = this[kError] || new SocketError('closed', util.getSocketInfo(this))\n\n    client[kSocket] = null\n    client[kHTTPContext] = null // TODO (fix): This is hacky...\n\n    if (client.destroyed) {\n      assert(client[kPending] === 0)\n\n      // Fail entire queue.\n      const requests = client[kQueue].splice(client[kRunningIdx])\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i]\n        util.errorRequest(client, request, err)\n      }\n    } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {\n      // Fail head of pipeline.\n      const request = client[kQueue][client[kRunningIdx]]\n      client[kQueue][client[kRunningIdx]++] = null\n\n      util.errorRequest(client, request, err)\n    }\n\n    client[kPendingIdx] = client[kRunningIdx]\n\n    assert(client[kRunning] === 0)\n\n    client.emit('disconnect', client[kUrl], [client], err)\n\n    client[kResume]()\n  })\n\n  let closed = false\n  socket.on('close', () => {\n    closed = true\n  })\n\n  return {\n    version: 'h1',\n    defaultPipelining: 1,\n    write (...args) {\n      return writeH1(client, ...args)\n    },\n    resume () {\n      resumeH1(client)\n    },\n    destroy (err, callback) {\n      if (closed) {\n        queueMicrotask(callback)\n      } else {\n        socket.destroy(err).on('close', callback)\n      }\n    },\n    get destroyed () {\n      return socket.destroyed\n    },\n    busy (request) {\n      if (socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n        return true\n      }\n\n      if (request) {\n        if (client[kRunning] > 0 && !request.idempotent) {\n          // Non-idempotent request cannot be retried.\n          // Ensure that no other requests are inflight and\n          // could cause failure.\n          return true\n        }\n\n        if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {\n          // Don't dispatch an upgrade until all preceding requests have completed.\n          // A misbehaving server might upgrade the connection before all pipelined\n          // request has completed.\n          return true\n        }\n\n        if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 &&\n          (util.isStream(request.body) || util.isAsyncIterable(request.body) || util.isFormDataLike(request.body))) {\n          // Request with stream or iterator body can error while other requests\n          // are inflight and indirectly error those as well.\n          // Ensure this doesn't happen by waiting for inflight\n          // to complete before dispatching.\n\n          // Request with stream or iterator body cannot be retried.\n          // Ensure that no other requests are inflight and\n          // could cause failure.\n          return true\n        }\n      }\n\n      return false\n    }\n  }\n}\n\nfunction resumeH1 (client) {\n  const socket = client[kSocket]\n\n  if (socket && !socket.destroyed) {\n    if (client[kSize] === 0) {\n      if (!socket[kNoRef] && socket.unref) {\n        socket.unref()\n        socket[kNoRef] = true\n      }\n    } else if (socket[kNoRef] && socket.ref) {\n      socket.ref()\n      socket[kNoRef] = false\n    }\n\n    if (client[kSize] === 0) {\n      if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {\n        socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE)\n      }\n    } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n      if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n        const request = client[kQueue][client[kRunningIdx]]\n        const headersTimeout = request.headersTimeout != null\n          ? request.headersTimeout\n          : client[kHeadersTimeout]\n        socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS)\n      }\n    }\n  }\n}\n\n// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2\nfunction shouldSendContentLength (method) {\n  return method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS' && method !== 'TRACE' && method !== 'CONNECT'\n}\n\nfunction writeH1 (client, request) {\n  const { method, path, host, upgrade, blocking, reset } = request\n\n  let { body, headers, contentLength } = request\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = (\n    method === 'PUT' ||\n    method === 'POST' ||\n    method === 'PATCH'\n  )\n\n  if (util.isFormDataLike(body)) {\n    if (!extractBody) {\n      extractBody = require('../web/fetch/body.js').extractBody\n    }\n\n    const [bodyStream, contentType] = extractBody(body)\n    if (request.contentType == null) {\n      headers.push('content-type', contentType)\n    }\n    body = bodyStream.stream\n    contentLength = bodyStream.length\n  } else if (util.isBlobLike(body) && request.contentType == null && body.type) {\n    headers.push('content-type', body.type)\n  }\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0)\n  }\n\n  const bodyLength = util.bodyLength(body)\n\n  contentLength = bodyLength ?? contentLength\n\n  if (contentLength === null) {\n    contentLength = request.contentLength\n  }\n\n  if (contentLength === 0 && !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null\n  }\n\n  // https://github.com/nodejs/undici/issues/2046\n  // A user agent may send a Content-Length header with 0 value, this should be allowed.\n  if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      util.errorRequest(client, request, new RequestContentLengthMismatchError())\n      return false\n    }\n\n    process.emitWarning(new RequestContentLengthMismatchError())\n  }\n\n  const socket = client[kSocket]\n\n  const abort = (err) => {\n    if (request.aborted || request.completed) {\n      return\n    }\n\n    util.errorRequest(client, request, err || new RequestAbortedError())\n\n    util.destroy(body)\n    util.destroy(socket, new InformationalError('aborted'))\n  }\n\n  try {\n    request.onConnect(abort)\n  } catch (err) {\n    util.errorRequest(client, request, err)\n  }\n\n  if (request.aborted) {\n    return false\n  }\n\n  if (method === 'HEAD') {\n    // https://github.com/mcollina/undici/issues/258\n    // Close after a HEAD request to interop with misbehaving servers\n    // that may send a body in the response.\n\n    socket[kReset] = true\n  }\n\n  if (upgrade || method === 'CONNECT') {\n    // On CONNECT or upgrade, block pipeline from dispatching further\n    // requests on this connection.\n\n    socket[kReset] = true\n  }\n\n  if (reset != null) {\n    socket[kReset] = reset\n  }\n\n  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n    socket[kReset] = true\n  }\n\n  if (blocking) {\n    socket[kBlocking] = true\n  }\n\n  let header = `${method} ${path} HTTP/1.1\\r\\n`\n\n  if (typeof host === 'string') {\n    header += `host: ${host}\\r\\n`\n  } else {\n    header += client[kHostHeader]\n  }\n\n  if (upgrade) {\n    header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`\n  } else if (client[kPipelining] && !socket[kReset]) {\n    header += 'connection: keep-alive\\r\\n'\n  } else {\n    header += 'connection: close\\r\\n'\n  }\n\n  if (Array.isArray(headers)) {\n    for (let n = 0; n < headers.length; n += 2) {\n      const key = headers[n + 0]\n      const val = headers[n + 1]\n\n      if (Array.isArray(val)) {\n        for (let i = 0; i < val.length; i++) {\n          header += `${key}: ${val[i]}\\r\\n`\n        }\n      } else {\n        header += `${key}: ${val}\\r\\n`\n      }\n    }\n  }\n\n  if (channels.sendHeaders.hasSubscribers) {\n    channels.sendHeaders.publish({ request, headers: header, socket })\n  }\n\n  /* istanbul ignore else: assertion */\n  if (!body || bodyLength === 0) {\n    writeBuffer(abort, null, client, request, socket, contentLength, header, expectsPayload)\n  } else if (util.isBuffer(body)) {\n    writeBuffer(abort, body, client, request, socket, contentLength, header, expectsPayload)\n  } else if (util.isBlobLike(body)) {\n    if (typeof body.stream === 'function') {\n      writeIterable(abort, body.stream(), client, request, socket, contentLength, header, expectsPayload)\n    } else {\n      writeBlob(abort, body, client, request, socket, contentLength, header, expectsPayload)\n    }\n  } else if (util.isStream(body)) {\n    writeStream(abort, body, client, request, socket, contentLength, header, expectsPayload)\n  } else if (util.isIterable(body)) {\n    writeIterable(abort, body, client, request, socket, contentLength, header, expectsPayload)\n  } else {\n    assert(false)\n  }\n\n  return true\n}\n\nfunction writeStream (abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined')\n\n  let finished = false\n\n  const writer = new AsyncWriter({ abort, socket, request, contentLength, client, expectsPayload, header })\n\n  const onData = function (chunk) {\n    if (finished) {\n      return\n    }\n\n    try {\n      if (!writer.write(chunk) && this.pause) {\n        this.pause()\n      }\n    } catch (err) {\n      util.destroy(this, err)\n    }\n  }\n  const onDrain = function () {\n    if (finished) {\n      return\n    }\n\n    if (body.resume) {\n      body.resume()\n    }\n  }\n  const onClose = function () {\n    // 'close' might be emitted *before* 'error' for\n    // broken streams. Wait a tick to avoid this case.\n    queueMicrotask(() => {\n      // It's only safe to remove 'error' listener after\n      // 'close'.\n      body.removeListener('error', onFinished)\n    })\n\n    if (!finished) {\n      const err = new RequestAbortedError()\n      queueMicrotask(() => onFinished(err))\n    }\n  }\n  const onFinished = function (err) {\n    if (finished) {\n      return\n    }\n\n    finished = true\n\n    assert(socket.destroyed || (socket[kWriting] && client[kRunning] <= 1))\n\n    socket\n      .off('drain', onDrain)\n      .off('error', onFinished)\n\n    body\n      .removeListener('data', onData)\n      .removeListener('end', onFinished)\n      .removeListener('close', onClose)\n\n    if (!err) {\n      try {\n        writer.end()\n      } catch (er) {\n        err = er\n      }\n    }\n\n    writer.destroy(err)\n\n    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {\n      util.destroy(body, err)\n    } else {\n      util.destroy(body)\n    }\n  }\n\n  body\n    .on('data', onData)\n    .on('end', onFinished)\n    .on('error', onFinished)\n    .on('close', onClose)\n\n  if (body.resume) {\n    body.resume()\n  }\n\n  socket\n    .on('drain', onDrain)\n    .on('error', onFinished)\n\n  if (body.errorEmitted ?? body.errored) {\n    setImmediate(() => onFinished(body.errored))\n  } else if (body.endEmitted ?? body.readableEnded) {\n    setImmediate(() => onFinished(null))\n  }\n\n  if (body.closeEmitted ?? body.closed) {\n    setImmediate(onClose)\n  }\n}\n\nfunction writeBuffer (abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  try {\n    if (!body) {\n      if (contentLength === 0) {\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1')\n      } else {\n        assert(contentLength === null, 'no body must not have content length')\n        socket.write(`${header}\\r\\n`, 'latin1')\n      }\n    } else if (util.isBuffer(body)) {\n      assert(contentLength === body.byteLength, 'buffer body must have content length')\n\n      socket.cork()\n      socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n      socket.write(body)\n      socket.uncork()\n      request.onBodySent(body)\n\n      if (!expectsPayload) {\n        socket[kReset] = true\n      }\n    }\n    request.onRequestSent()\n\n    client[kResume]()\n  } catch (err) {\n    abort(err)\n  }\n}\n\nasync function writeBlob (abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  assert(contentLength === body.size, 'blob body must have content length')\n\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError()\n    }\n\n    const buffer = Buffer.from(await body.arrayBuffer())\n\n    socket.cork()\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n    socket.write(buffer)\n    socket.uncork()\n\n    request.onBodySent(buffer)\n    request.onRequestSent()\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    client[kResume]()\n  } catch (err) {\n    abort(err)\n  }\n}\n\nasync function writeIterable (abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined')\n\n  let callback = null\n  function onDrain () {\n    if (callback) {\n      const cb = callback\n      callback = null\n      cb()\n    }\n  }\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null)\n\n    if (socket[kError]) {\n      reject(socket[kError])\n    } else {\n      callback = resolve\n    }\n  })\n\n  socket\n    .on('close', onDrain)\n    .on('drain', onDrain)\n\n  const writer = new AsyncWriter({ abort, socket, request, contentLength, client, expectsPayload, header })\n  try {\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError]\n      }\n\n      if (!writer.write(chunk)) {\n        await waitForDrain()\n      }\n    }\n\n    writer.end()\n  } catch (err) {\n    writer.destroy(err)\n  } finally {\n    socket\n      .off('close', onDrain)\n      .off('drain', onDrain)\n  }\n}\n\nclass AsyncWriter {\n  constructor ({ abort, socket, request, contentLength, client, expectsPayload, header }) {\n    this.socket = socket\n    this.request = request\n    this.contentLength = contentLength\n    this.client = client\n    this.bytesWritten = 0\n    this.expectsPayload = expectsPayload\n    this.header = header\n    this.abort = abort\n\n    socket[kWriting] = true\n  }\n\n  write (chunk) {\n    const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return false\n    }\n\n    const len = Buffer.byteLength(chunk)\n    if (!len) {\n      return true\n    }\n\n    // We should defer writing chunks.\n    if (contentLength !== null && bytesWritten + len > contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      }\n\n      process.emitWarning(new RequestContentLengthMismatchError())\n    }\n\n    socket.cork()\n\n    if (bytesWritten === 0) {\n      if (!expectsPayload) {\n        socket[kReset] = true\n      }\n\n      if (contentLength === null) {\n        socket.write(`${header}transfer-encoding: chunked\\r\\n`, 'latin1')\n      } else {\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n      }\n    }\n\n    if (contentLength === null) {\n      socket.write(`\\r\\n${len.toString(16)}\\r\\n`, 'latin1')\n    }\n\n    this.bytesWritten += len\n\n    const ret = socket.write(chunk)\n\n    socket.uncork()\n\n    request.onBodySent(chunk)\n\n    if (!ret) {\n      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n        // istanbul ignore else: only for jest\n        if (socket[kParser].timeout.refresh) {\n          socket[kParser].timeout.refresh()\n        }\n      }\n    }\n\n    return ret\n  }\n\n  end () {\n    const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this\n    request.onRequestSent()\n\n    socket[kWriting] = false\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return\n    }\n\n    if (bytesWritten === 0) {\n      if (expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD send a Content-Length in a request message when\n        // no Transfer-Encoding is sent and the request method defines a meaning\n        // for an enclosed payload body.\n\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1')\n      } else {\n        socket.write(`${header}\\r\\n`, 'latin1')\n      }\n    } else if (contentLength === null) {\n      socket.write('\\r\\n0\\r\\n\\r\\n', 'latin1')\n    }\n\n    if (contentLength !== null && bytesWritten !== contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      } else {\n        process.emitWarning(new RequestContentLengthMismatchError())\n      }\n    }\n\n    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n      // istanbul ignore else: only for jest\n      if (socket[kParser].timeout.refresh) {\n        socket[kParser].timeout.refresh()\n      }\n    }\n\n    client[kResume]()\n  }\n\n  destroy (err) {\n    const { socket, client, abort } = this\n\n    socket[kWriting] = false\n\n    if (err) {\n      assert(client[kRunning] <= 1, 'pipeline should only contain this request')\n      abort(err)\n    }\n  }\n}\n\nmodule.exports = connectH1\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
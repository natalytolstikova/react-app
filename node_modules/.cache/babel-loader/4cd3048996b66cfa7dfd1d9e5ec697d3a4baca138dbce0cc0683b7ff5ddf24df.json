{"ast":null,"code":"'use strict';\n\nconst assert = require('node:assert');\nconst {\n  finished,\n  PassThrough\n} = require('node:stream');\nconst {\n  InvalidArgumentError,\n  InvalidReturnValueError\n} = require('../core/errors');\nconst util = require('../core/util');\nconst {\n  getResolveErrorBodyCallback\n} = require('./util');\nconst {\n  AsyncResource\n} = require('node:async_hooks');\nconst {\n  addSignal,\n  removeSignal\n} = require('./abort-signal');\nclass StreamHandler extends AsyncResource {\n  constructor(opts, factory, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts');\n    }\n    const {\n      signal,\n      method,\n      opaque,\n      body,\n      onInfo,\n      responseHeaders,\n      throwOnError\n    } = opts;\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback');\n      }\n      if (typeof factory !== 'function') {\n        throw new InvalidArgumentError('invalid factory');\n      }\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');\n      }\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method');\n      }\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback');\n      }\n      super('UNDICI_STREAM');\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err);\n      }\n      throw err;\n    }\n    this.responseHeaders = responseHeaders || null;\n    this.opaque = opaque || null;\n    this.factory = factory;\n    this.callback = callback;\n    this.res = null;\n    this.abort = null;\n    this.context = null;\n    this.trailers = null;\n    this.body = body;\n    this.onInfo = onInfo || null;\n    this.throwOnError = throwOnError || false;\n    if (util.isStream(body)) {\n      body.on('error', err => {\n        this.onError(err);\n      });\n    }\n    addSignal(this, signal);\n  }\n  onConnect(abort, context) {\n    if (this.reason) {\n      abort(this.reason);\n      return;\n    }\n    assert(this.callback);\n    this.abort = abort;\n    this.context = context;\n  }\n  onHeaders(statusCode, rawHeaders, resume, statusMessage) {\n    const {\n      factory,\n      opaque,\n      context,\n      callback,\n      responseHeaders\n    } = this;\n    const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        this.onInfo({\n          statusCode,\n          headers\n        });\n      }\n      return;\n    }\n    this.factory = null;\n    let res;\n    if (this.throwOnError && statusCode >= 400) {\n      const parsedHeaders = responseHeaders === 'raw' ? util.parseHeaders(rawHeaders) : headers;\n      const contentType = parsedHeaders['content-type'];\n      res = new PassThrough();\n      this.callback = null;\n      this.runInAsyncScope(getResolveErrorBodyCallback, null, {\n        callback,\n        body: res,\n        contentType,\n        statusCode,\n        statusMessage,\n        headers\n      });\n    } else {\n      if (factory === null) {\n        return;\n      }\n      res = this.runInAsyncScope(factory, null, {\n        statusCode,\n        headers,\n        opaque,\n        context\n      });\n      if (!res || typeof res.write !== 'function' || typeof res.end !== 'function' || typeof res.on !== 'function') {\n        throw new InvalidReturnValueError('expected Writable');\n      }\n\n      // TODO: Avoid finished. It registers an unnecessary amount of listeners.\n      finished(res, {\n        readable: false\n      }, err => {\n        const {\n          callback,\n          res,\n          opaque,\n          trailers,\n          abort\n        } = this;\n        this.res = null;\n        if (err || !res.readable) {\n          util.destroy(res, err);\n        }\n        this.callback = null;\n        this.runInAsyncScope(callback, null, err || null, {\n          opaque,\n          trailers\n        });\n        if (err) {\n          abort();\n        }\n      });\n    }\n    res.on('drain', resume);\n    this.res = res;\n    const needDrain = res.writableNeedDrain !== undefined ? res.writableNeedDrain : res._writableState?.needDrain;\n    return needDrain !== true;\n  }\n  onData(chunk) {\n    const {\n      res\n    } = this;\n    return res ? res.write(chunk) : true;\n  }\n  onComplete(trailers) {\n    const {\n      res\n    } = this;\n    removeSignal(this);\n    if (!res) {\n      return;\n    }\n    this.trailers = util.parseHeaders(trailers);\n    res.end();\n  }\n  onError(err) {\n    const {\n      res,\n      callback,\n      opaque,\n      body\n    } = this;\n    removeSignal(this);\n    this.factory = null;\n    if (res) {\n      this.res = null;\n      util.destroy(res, err);\n    } else if (callback) {\n      this.callback = null;\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, {\n          opaque\n        });\n      });\n    }\n    if (body) {\n      this.body = null;\n      util.destroy(body, err);\n    }\n  }\n}\nfunction stream(opts, factory, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      stream.call(this, opts, factory, (err, data) => {\n        return err ? reject(err) : resolve(data);\n      });\n    });\n  }\n  try {\n    this.dispatch(opts, new StreamHandler(opts, factory, callback));\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err;\n    }\n    const opaque = opts?.opaque;\n    queueMicrotask(() => callback(err, {\n      opaque\n    }));\n  }\n}\nmodule.exports = stream;","map":{"version":3,"names":["assert","require","finished","PassThrough","InvalidArgumentError","InvalidReturnValueError","util","getResolveErrorBodyCallback","AsyncResource","addSignal","removeSignal","StreamHandler","constructor","opts","factory","callback","signal","method","opaque","body","onInfo","responseHeaders","throwOnError","on","addEventListener","err","isStream","destroy","nop","res","abort","context","trailers","onError","onConnect","reason","onHeaders","statusCode","rawHeaders","resume","statusMessage","headers","parseRawHeaders","parseHeaders","parsedHeaders","contentType","runInAsyncScope","write","end","readable","needDrain","writableNeedDrain","undefined","_writableState","onData","chunk","onComplete","queueMicrotask","stream","Promise","resolve","reject","call","data","dispatch","module","exports"],"sources":["/Users/nataliia/PussyProjects/react-app/node_modules/undici/lib/api/api-stream.js"],"sourcesContent":["'use strict'\n\nconst assert = require('node:assert')\nconst { finished, PassThrough } = require('node:stream')\nconst { InvalidArgumentError, InvalidReturnValueError } = require('../core/errors')\nconst util = require('../core/util')\nconst { getResolveErrorBodyCallback } = require('./util')\nconst { AsyncResource } = require('node:async_hooks')\nconst { addSignal, removeSignal } = require('./abort-signal')\n\nclass StreamHandler extends AsyncResource {\n  constructor (opts, factory, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (typeof factory !== 'function') {\n        throw new InvalidArgumentError('invalid factory')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback')\n      }\n\n      super('UNDICI_STREAM')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err)\n      }\n      throw err\n    }\n\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.factory = factory\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.context = null\n    this.trailers = null\n    this.body = body\n    this.onInfo = onInfo || null\n    this.throwOnError = throwOnError || false\n\n    if (util.isStream(body)) {\n      body.on('error', (err) => {\n        this.onError(err)\n      })\n    }\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(this.callback)\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    const { factory, opaque, context, callback, responseHeaders } = this\n\n    const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    this.factory = null\n\n    let res\n\n    if (this.throwOnError && statusCode >= 400) {\n      const parsedHeaders = responseHeaders === 'raw' ? util.parseHeaders(rawHeaders) : headers\n      const contentType = parsedHeaders['content-type']\n      res = new PassThrough()\n\n      this.callback = null\n      this.runInAsyncScope(getResolveErrorBodyCallback, null,\n        { callback, body: res, contentType, statusCode, statusMessage, headers }\n      )\n    } else {\n      if (factory === null) {\n        return\n      }\n\n      res = this.runInAsyncScope(factory, null, {\n        statusCode,\n        headers,\n        opaque,\n        context\n      })\n\n      if (\n        !res ||\n        typeof res.write !== 'function' ||\n        typeof res.end !== 'function' ||\n        typeof res.on !== 'function'\n      ) {\n        throw new InvalidReturnValueError('expected Writable')\n      }\n\n      // TODO: Avoid finished. It registers an unnecessary amount of listeners.\n      finished(res, { readable: false }, (err) => {\n        const { callback, res, opaque, trailers, abort } = this\n\n        this.res = null\n        if (err || !res.readable) {\n          util.destroy(res, err)\n        }\n\n        this.callback = null\n        this.runInAsyncScope(callback, null, err || null, { opaque, trailers })\n\n        if (err) {\n          abort()\n        }\n      })\n    }\n\n    res.on('drain', resume)\n\n    this.res = res\n\n    const needDrain = res.writableNeedDrain !== undefined\n      ? res.writableNeedDrain\n      : res._writableState?.needDrain\n\n    return needDrain !== true\n  }\n\n  onData (chunk) {\n    const { res } = this\n\n    return res ? res.write(chunk) : true\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n\n    removeSignal(this)\n\n    if (!res) {\n      return\n    }\n\n    this.trailers = util.parseHeaders(trailers)\n\n    res.end()\n  }\n\n  onError (err) {\n    const { res, callback, opaque, body } = this\n\n    removeSignal(this)\n\n    this.factory = null\n\n    if (res) {\n      this.res = null\n      util.destroy(res, err)\n    } else if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n\n    if (body) {\n      this.body = null\n      util.destroy(body, err)\n    }\n  }\n}\n\nfunction stream (opts, factory, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      stream.call(this, opts, factory, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    this.dispatch(opts, new StreamHandler(opts, factory, callback))\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts?.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = stream\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
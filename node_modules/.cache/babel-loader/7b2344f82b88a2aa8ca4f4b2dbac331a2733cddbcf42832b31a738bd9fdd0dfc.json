{"ast":null,"code":"// https://github.com/Ethan-Arrowood/undici-fetch\n\n'use strict';\n\nconst {\n  makeNetworkError,\n  makeAppropriateNetworkError,\n  filterResponse,\n  makeResponse,\n  fromInnerResponse\n} = require('./response');\nconst {\n  HeadersList\n} = require('./headers');\nconst {\n  Request,\n  cloneRequest\n} = require('./request');\nconst zlib = require('node:zlib');\nconst {\n  bytesMatch,\n  makePolicyContainer,\n  clonePolicyContainer,\n  requestBadPort,\n  TAOCheck,\n  appendRequestOriginHeader,\n  responseLocationURL,\n  requestCurrentURL,\n  setRequestReferrerPolicyOnRedirect,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  createOpaqueTimingInfo,\n  appendFetchMetadata,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  determineRequestsReferrer,\n  coarsenedSharedCurrentTime,\n  createDeferredPromise,\n  isBlobLike,\n  sameOrigin,\n  isCancelled,\n  isAborted,\n  isErrorLike,\n  fullyReadBody,\n  readableStreamClose,\n  isomorphicEncode,\n  urlIsLocal,\n  urlIsHttpHttpsScheme,\n  urlHasHttpsScheme,\n  clampAndCoarsenConnectionTimingInfo,\n  simpleRangeHeaderValue,\n  buildContentRange,\n  createInflate,\n  extractMimeType\n} = require('./util');\nconst {\n  kState,\n  kDispatcher\n} = require('./symbols');\nconst assert = require('node:assert');\nconst {\n  safelyExtractBody,\n  extractBody\n} = require('./body');\nconst {\n  redirectStatusSet,\n  nullBodyStatus,\n  safeMethodsSet,\n  requestBodyHeader,\n  subresourceSet\n} = require('./constants');\nconst EE = require('node:events');\nconst {\n  Readable,\n  pipeline,\n  finished\n} = require('node:stream');\nconst {\n  addAbortListener,\n  isErrored,\n  isReadable,\n  bufferToLowerCasedHeaderName\n} = require('../../core/util');\nconst {\n  dataURLProcessor,\n  serializeAMimeType,\n  minimizeSupportedMimeType\n} = require('./data-url');\nconst {\n  getGlobalDispatcher\n} = require('../../global');\nconst {\n  webidl\n} = require('./webidl');\nconst {\n  STATUS_CODES\n} = require('node:http');\nconst GET_OR_HEAD = ['GET', 'HEAD'];\nconst defaultUserAgent = typeof __UNDICI_IS_NODE__ !== 'undefined' || typeof esbuildDetection !== 'undefined' ? 'node' : 'undici';\n\n/** @type {import('buffer').resolveObjectURL} */\nlet resolveObjectURL;\nclass Fetch extends EE {\n  constructor(dispatcher) {\n    super();\n    this.dispatcher = dispatcher;\n    this.connection = null;\n    this.dump = false;\n    this.state = 'ongoing';\n  }\n  terminate(reason) {\n    if (this.state !== 'ongoing') {\n      return;\n    }\n    this.state = 'terminated';\n    this.connection?.destroy(reason);\n    this.emit('terminated', reason);\n  }\n\n  // https://fetch.spec.whatwg.org/#fetch-controller-abort\n  abort(error) {\n    if (this.state !== 'ongoing') {\n      return;\n    }\n\n    // 1. Set controller’s state to \"aborted\".\n    this.state = 'aborted';\n\n    // 2. Let fallbackError be an \"AbortError\" DOMException.\n    // 3. Set error to fallbackError if it is not given.\n    if (!error) {\n      error = new DOMException('The operation was aborted.', 'AbortError');\n    }\n\n    // 4. Let serializedError be StructuredSerialize(error).\n    //    If that threw an exception, catch it, and let\n    //    serializedError be StructuredSerialize(fallbackError).\n\n    // 5. Set controller’s serialized abort reason to serializedError.\n    this.serializedAbortReason = error;\n    this.connection?.destroy(error);\n    this.emit('terminated', error);\n  }\n}\nfunction handleFetchDone(response) {\n  finalizeAndReportTiming(response, 'fetch');\n}\n\n// https://fetch.spec.whatwg.org/#fetch-method\nfunction fetch(input, init = undefined) {\n  webidl.argumentLengthCheck(arguments, 1, 'globalThis.fetch');\n\n  // 1. Let p be a new promise.\n  let p = createDeferredPromise();\n\n  // 2. Let requestObject be the result of invoking the initial value of\n  // Request as constructor with input and init as arguments. If this throws\n  // an exception, reject p with it and return p.\n  let requestObject;\n  try {\n    requestObject = new Request(input, init);\n  } catch (e) {\n    p.reject(e);\n    return p.promise;\n  }\n\n  // 3. Let request be requestObject’s request.\n  const request = requestObject[kState];\n\n  // 4. If requestObject’s signal’s aborted flag is set, then:\n  if (requestObject.signal.aborted) {\n    // 1. Abort the fetch() call with p, request, null, and\n    //    requestObject’s signal’s abort reason.\n    abortFetch(p, request, null, requestObject.signal.reason);\n\n    // 2. Return p.\n    return p.promise;\n  }\n\n  // 5. Let globalObject be request’s client’s global object.\n  const globalObject = request.client.globalObject;\n\n  // 6. If globalObject is a ServiceWorkerGlobalScope object, then set\n  // request’s service-workers mode to \"none\".\n  if (globalObject?.constructor?.name === 'ServiceWorkerGlobalScope') {\n    request.serviceWorkers = 'none';\n  }\n\n  // 7. Let responseObject be null.\n  let responseObject = null;\n\n  // 8. Let relevantRealm be this’s relevant Realm.\n\n  // 9. Let locallyAborted be false.\n  let locallyAborted = false;\n\n  // 10. Let controller be null.\n  let controller = null;\n\n  // 11. Add the following abort steps to requestObject’s signal:\n  addAbortListener(requestObject.signal, () => {\n    // 1. Set locallyAborted to true.\n    locallyAborted = true;\n\n    // 2. Assert: controller is non-null.\n    assert(controller != null);\n\n    // 3. Abort controller with requestObject’s signal’s abort reason.\n    controller.abort(requestObject.signal.reason);\n    const realResponse = responseObject?.deref();\n\n    // 4. Abort the fetch() call with p, request, responseObject,\n    //    and requestObject’s signal’s abort reason.\n    abortFetch(p, request, realResponse, requestObject.signal.reason);\n  });\n\n  // 12. Let handleFetchDone given response response be to finalize and\n  // report timing with response, globalObject, and \"fetch\".\n  // see function handleFetchDone\n\n  // 13. Set controller to the result of calling fetch given request,\n  // with processResponseEndOfBody set to handleFetchDone, and processResponse\n  // given response being these substeps:\n\n  const processResponse = response => {\n    // 1. If locallyAborted is true, terminate these substeps.\n    if (locallyAborted) {\n      return;\n    }\n\n    // 2. If response’s aborted flag is set, then:\n    if (response.aborted) {\n      // 1. Let deserializedError be the result of deserialize a serialized\n      //    abort reason given controller’s serialized abort reason and\n      //    relevantRealm.\n\n      // 2. Abort the fetch() call with p, request, responseObject, and\n      //    deserializedError.\n\n      abortFetch(p, request, responseObject, controller.serializedAbortReason);\n      return;\n    }\n\n    // 3. If response is a network error, then reject p with a TypeError\n    // and terminate these substeps.\n    if (response.type === 'error') {\n      p.reject(new TypeError('fetch failed', {\n        cause: response.error\n      }));\n      return;\n    }\n\n    // 4. Set responseObject to the result of creating a Response object,\n    // given response, \"immutable\", and relevantRealm.\n    responseObject = new WeakRef(fromInnerResponse(response, 'immutable'));\n\n    // 5. Resolve p with responseObject.\n    p.resolve(responseObject.deref());\n    p = null;\n  };\n  controller = fetching({\n    request,\n    processResponseEndOfBody: handleFetchDone,\n    processResponse,\n    dispatcher: requestObject[kDispatcher] // undici\n  });\n\n  // 14. Return p.\n  return p.promise;\n}\n\n// https://fetch.spec.whatwg.org/#finalize-and-report-timing\nfunction finalizeAndReportTiming(response, initiatorType = 'other') {\n  // 1. If response is an aborted network error, then return.\n  if (response.type === 'error' && response.aborted) {\n    return;\n  }\n\n  // 2. If response’s URL list is null or empty, then return.\n  if (!response.urlList?.length) {\n    return;\n  }\n\n  // 3. Let originalURL be response’s URL list[0].\n  const originalURL = response.urlList[0];\n\n  // 4. Let timingInfo be response’s timing info.\n  let timingInfo = response.timingInfo;\n\n  // 5. Let cacheState be response’s cache state.\n  let cacheState = response.cacheState;\n\n  // 6. If originalURL’s scheme is not an HTTP(S) scheme, then return.\n  if (!urlIsHttpHttpsScheme(originalURL)) {\n    return;\n  }\n\n  // 7. If timingInfo is null, then return.\n  if (timingInfo === null) {\n    return;\n  }\n\n  // 8. If response’s timing allow passed flag is not set, then:\n  if (!response.timingAllowPassed) {\n    //  1. Set timingInfo to a the result of creating an opaque timing info for timingInfo.\n    timingInfo = createOpaqueTimingInfo({\n      startTime: timingInfo.startTime\n    });\n\n    //  2. Set cacheState to the empty string.\n    cacheState = '';\n  }\n\n  // 9. Set timingInfo’s end time to the coarsened shared current time\n  // given global’s relevant settings object’s cross-origin isolated\n  // capability.\n  // TODO: given global’s relevant settings object’s cross-origin isolated\n  // capability?\n  timingInfo.endTime = coarsenedSharedCurrentTime();\n\n  // 10. Set response’s timing info to timingInfo.\n  response.timingInfo = timingInfo;\n\n  // 11. Mark resource timing for timingInfo, originalURL, initiatorType,\n  // global, and cacheState.\n  markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis, cacheState);\n}\n\n// https://w3c.github.io/resource-timing/#dfn-mark-resource-timing\nconst markResourceTiming = performance.markResourceTiming;\n\n// https://fetch.spec.whatwg.org/#abort-fetch\nfunction abortFetch(p, request, responseObject, error) {\n  // 1. Reject promise with error.\n  if (p) {\n    // We might have already resolved the promise at this stage\n    p.reject(error);\n  }\n\n  // 2. If request’s body is not null and is readable, then cancel request’s\n  // body with error.\n  if (request.body != null && isReadable(request.body?.stream)) {\n    request.body.stream.cancel(error).catch(err => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return;\n      }\n      throw err;\n    });\n  }\n\n  // 3. If responseObject is null, then return.\n  if (responseObject == null) {\n    return;\n  }\n\n  // 4. Let response be responseObject’s response.\n  const response = responseObject[kState];\n\n  // 5. If response’s body is not null and is readable, then error response’s\n  // body with error.\n  if (response.body != null && isReadable(response.body?.stream)) {\n    response.body.stream.cancel(error).catch(err => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return;\n      }\n      throw err;\n    });\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetching\nfunction fetching({\n  request,\n  processRequestBodyChunkLength,\n  processRequestEndOfBody,\n  processResponse,\n  processResponseEndOfBody,\n  processResponseConsumeBody,\n  useParallelQueue = false,\n  dispatcher = getGlobalDispatcher() // undici\n}) {\n  // Ensure that the dispatcher is set accordingly\n  assert(dispatcher);\n\n  // 1. Let taskDestination be null.\n  let taskDestination = null;\n\n  // 2. Let crossOriginIsolatedCapability be false.\n  let crossOriginIsolatedCapability = false;\n\n  // 3. If request’s client is non-null, then:\n  if (request.client != null) {\n    // 1. Set taskDestination to request’s client’s global object.\n    taskDestination = request.client.globalObject;\n\n    // 2. Set crossOriginIsolatedCapability to request’s client’s cross-origin\n    // isolated capability.\n    crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;\n  }\n\n  // 4. If useParallelQueue is true, then set taskDestination to the result of\n  // starting a new parallel queue.\n  // TODO\n\n  // 5. Let timingInfo be a new fetch timing info whose start time and\n  // post-redirect start time are the coarsened shared current time given\n  // crossOriginIsolatedCapability.\n  const currentTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);\n  const timingInfo = createOpaqueTimingInfo({\n    startTime: currentTime\n  });\n\n  // 6. Let fetchParams be a new fetch params whose\n  // request is request,\n  // timing info is timingInfo,\n  // process request body chunk length is processRequestBodyChunkLength,\n  // process request end-of-body is processRequestEndOfBody,\n  // process response is processResponse,\n  // process response consume body is processResponseConsumeBody,\n  // process response end-of-body is processResponseEndOfBody,\n  // task destination is taskDestination,\n  // and cross-origin isolated capability is crossOriginIsolatedCapability.\n  const fetchParams = {\n    controller: new Fetch(dispatcher),\n    request,\n    timingInfo,\n    processRequestBodyChunkLength,\n    processRequestEndOfBody,\n    processResponse,\n    processResponseConsumeBody,\n    processResponseEndOfBody,\n    taskDestination,\n    crossOriginIsolatedCapability\n  };\n\n  // 7. If request’s body is a byte sequence, then set request’s body to\n  //    request’s body as a body.\n  // NOTE: Since fetching is only called from fetch, body should already be\n  // extracted.\n  assert(!request.body || request.body.stream);\n\n  // 8. If request’s window is \"client\", then set request’s window to request’s\n  // client, if request’s client’s global object is a Window object; otherwise\n  // \"no-window\".\n  if (request.window === 'client') {\n    // TODO: What if request.client is null?\n    request.window = request.client?.globalObject?.constructor?.name === 'Window' ? request.client : 'no-window';\n  }\n\n  // 9. If request’s origin is \"client\", then set request’s origin to request’s\n  // client’s origin.\n  if (request.origin === 'client') {\n    request.origin = request.client.origin;\n  }\n\n  // 10. If all of the following conditions are true:\n  // TODO\n\n  // 11. If request’s policy container is \"client\", then:\n  if (request.policyContainer === 'client') {\n    // 1. If request’s client is non-null, then set request’s policy\n    // container to a clone of request’s client’s policy container. [HTML]\n    if (request.client != null) {\n      request.policyContainer = clonePolicyContainer(request.client.policyContainer);\n    } else {\n      // 2. Otherwise, set request’s policy container to a new policy\n      // container.\n      request.policyContainer = makePolicyContainer();\n    }\n  }\n\n  // 12. If request’s header list does not contain `Accept`, then:\n  if (!request.headersList.contains('accept', true)) {\n    // 1. Let value be `*/*`.\n    const value = '*/*';\n\n    // 2. A user agent should set value to the first matching statement, if\n    // any, switching on request’s destination:\n    // \"document\"\n    // \"frame\"\n    // \"iframe\"\n    // `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`\n    // \"image\"\n    // `image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5`\n    // \"style\"\n    // `text/css,*/*;q=0.1`\n    // TODO\n\n    // 3. Append `Accept`/value to request’s header list.\n    request.headersList.append('accept', value, true);\n  }\n\n  // 13. If request’s header list does not contain `Accept-Language`, then\n  // user agents should append `Accept-Language`/an appropriate value to\n  // request’s header list.\n  if (!request.headersList.contains('accept-language', true)) {\n    request.headersList.append('accept-language', '*', true);\n  }\n\n  // 14. If request’s priority is null, then use request’s initiator and\n  // destination appropriately in setting request’s priority to a\n  // user-agent-defined object.\n  if (request.priority === null) {\n    // TODO\n  }\n\n  // 15. If request is a subresource request, then:\n  if (subresourceSet.has(request.destination)) {\n    // TODO\n  }\n\n  // 16. Run main fetch given fetchParams.\n  mainFetch(fetchParams).catch(err => {\n    fetchParams.controller.terminate(err);\n  });\n\n  // 17. Return fetchParam's controller\n  return fetchParams.controller;\n}\n\n// https://fetch.spec.whatwg.org/#concept-main-fetch\nasync function mainFetch(fetchParams, recursive = false) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request;\n\n  // 2. Let response be null.\n  let response = null;\n\n  // 3. If request’s local-URLs-only flag is set and request’s current URL is\n  // not local, then set response to a network error.\n  if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {\n    response = makeNetworkError('local URLs only');\n  }\n\n  // 4. Run report Content Security Policy violations for request.\n  // TODO\n\n  // 5. Upgrade request to a potentially trustworthy URL, if appropriate.\n  tryUpgradeRequestToAPotentiallyTrustworthyURL(request);\n\n  // 6. If should request be blocked due to a bad port, should fetching request\n  // be blocked as mixed content, or should request be blocked by Content\n  // Security Policy returns blocked, then set response to a network error.\n  if (requestBadPort(request) === 'blocked') {\n    response = makeNetworkError('bad port');\n  }\n  // TODO: should fetching request be blocked as mixed content?\n  // TODO: should request be blocked by Content Security Policy?\n\n  // 7. If request’s referrer policy is the empty string, then set request’s\n  // referrer policy to request’s policy container’s referrer policy.\n  if (request.referrerPolicy === '') {\n    request.referrerPolicy = request.policyContainer.referrerPolicy;\n  }\n\n  // 8. If request’s referrer is not \"no-referrer\", then set request’s\n  // referrer to the result of invoking determine request’s referrer.\n  if (request.referrer !== 'no-referrer') {\n    request.referrer = determineRequestsReferrer(request);\n  }\n\n  // 9. Set request’s current URL’s scheme to \"https\" if all of the following\n  // conditions are true:\n  // - request’s current URL’s scheme is \"http\"\n  // - request’s current URL’s host is a domain\n  // - Matching request’s current URL’s host per Known HSTS Host Domain Name\n  //   Matching results in either a superdomain match with an asserted\n  //   includeSubDomains directive or a congruent match (with or without an\n  //   asserted includeSubDomains directive). [HSTS]\n  // TODO\n\n  // 10. If recursive is false, then run the remaining steps in parallel.\n  // TODO\n\n  // 11. If response is null, then set response to the result of running\n  // the steps corresponding to the first matching statement:\n  if (response === null) {\n    response = await (async () => {\n      const currentURL = requestCurrentURL(request);\n      if (\n      // - request’s current URL’s origin is same origin with request’s origin,\n      //   and request’s response tainting is \"basic\"\n      sameOrigin(currentURL, request.url) && request.responseTainting === 'basic' ||\n      // request’s current URL’s scheme is \"data\"\n      currentURL.protocol === 'data:' ||\n      // - request’s mode is \"navigate\" or \"websocket\"\n      request.mode === 'navigate' || request.mode === 'websocket') {\n        // 1. Set request’s response tainting to \"basic\".\n        request.responseTainting = 'basic';\n\n        // 2. Return the result of running scheme fetch given fetchParams.\n        return await schemeFetch(fetchParams);\n      }\n\n      // request’s mode is \"same-origin\"\n      if (request.mode === 'same-origin') {\n        // 1. Return a network error.\n        return makeNetworkError('request mode cannot be \"same-origin\"');\n      }\n\n      // request’s mode is \"no-cors\"\n      if (request.mode === 'no-cors') {\n        // 1. If request’s redirect mode is not \"follow\", then return a network\n        // error.\n        if (request.redirect !== 'follow') {\n          return makeNetworkError('redirect mode cannot be \"follow\" for \"no-cors\" request');\n        }\n\n        // 2. Set request’s response tainting to \"opaque\".\n        request.responseTainting = 'opaque';\n\n        // 3. Return the result of running scheme fetch given fetchParams.\n        return await schemeFetch(fetchParams);\n      }\n\n      // request’s current URL’s scheme is not an HTTP(S) scheme\n      if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {\n        // Return a network error.\n        return makeNetworkError('URL scheme must be a HTTP(S) scheme');\n      }\n\n      // - request’s use-CORS-preflight flag is set\n      // - request’s unsafe-request flag is set and either request’s method is\n      //   not a CORS-safelisted method or CORS-unsafe request-header names with\n      //   request’s header list is not empty\n      //    1. Set request’s response tainting to \"cors\".\n      //    2. Let corsWithPreflightResponse be the result of running HTTP fetch\n      //    given fetchParams and true.\n      //    3. If corsWithPreflightResponse is a network error, then clear cache\n      //    entries using request.\n      //    4. Return corsWithPreflightResponse.\n      // TODO\n\n      // Otherwise\n      //    1. Set request’s response tainting to \"cors\".\n      request.responseTainting = 'cors';\n\n      //    2. Return the result of running HTTP fetch given fetchParams.\n      return await httpFetch(fetchParams);\n    })();\n  }\n\n  // 12. If recursive is true, then return response.\n  if (recursive) {\n    return response;\n  }\n\n  // 13. If response is not a network error and response is not a filtered\n  // response, then:\n  if (response.status !== 0 && !response.internalResponse) {\n    // If request’s response tainting is \"cors\", then:\n    if (request.responseTainting === 'cors') {\n      // 1. Let headerNames be the result of extracting header list values\n      // given `Access-Control-Expose-Headers` and response’s header list.\n      // TODO\n      // 2. If request’s credentials mode is not \"include\" and headerNames\n      // contains `*`, then set response’s CORS-exposed header-name list to\n      // all unique header names in response’s header list.\n      // TODO\n      // 3. Otherwise, if headerNames is not null or failure, then set\n      // response’s CORS-exposed header-name list to headerNames.\n      // TODO\n    }\n\n    // Set response to the following filtered response with response as its\n    // internal response, depending on request’s response tainting:\n    if (request.responseTainting === 'basic') {\n      response = filterResponse(response, 'basic');\n    } else if (request.responseTainting === 'cors') {\n      response = filterResponse(response, 'cors');\n    } else if (request.responseTainting === 'opaque') {\n      response = filterResponse(response, 'opaque');\n    } else {\n      assert(false);\n    }\n  }\n\n  // 14. Let internalResponse be response, if response is a network error,\n  // and response’s internal response otherwise.\n  let internalResponse = response.status === 0 ? response : response.internalResponse;\n\n  // 15. If internalResponse’s URL list is empty, then set it to a clone of\n  // request’s URL list.\n  if (internalResponse.urlList.length === 0) {\n    internalResponse.urlList.push(...request.urlList);\n  }\n\n  // 16. If request’s timing allow failed flag is unset, then set\n  // internalResponse’s timing allow passed flag.\n  if (!request.timingAllowFailed) {\n    response.timingAllowPassed = true;\n  }\n\n  // 17. If response is not a network error and any of the following returns\n  // blocked\n  // - should internalResponse to request be blocked as mixed content\n  // - should internalResponse to request be blocked by Content Security Policy\n  // - should internalResponse to request be blocked due to its MIME type\n  // - should internalResponse to request be blocked due to nosniff\n  // TODO\n\n  // 18. If response’s type is \"opaque\", internalResponse’s status is 206,\n  // internalResponse’s range-requested flag is set, and request’s header\n  // list does not contain `Range`, then set response and internalResponse\n  // to a network error.\n  if (response.type === 'opaque' && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains('range', true)) {\n    response = internalResponse = makeNetworkError();\n  }\n\n  // 19. If response is not a network error and either request’s method is\n  // `HEAD` or `CONNECT`, or internalResponse’s status is a null body status,\n  // set internalResponse’s body to null and disregard any enqueuing toward\n  // it (if any).\n  if (response.status !== 0 && (request.method === 'HEAD' || request.method === 'CONNECT' || nullBodyStatus.includes(internalResponse.status))) {\n    internalResponse.body = null;\n    fetchParams.controller.dump = true;\n  }\n\n  // 20. If request’s integrity metadata is not the empty string, then:\n  if (request.integrity) {\n    // 1. Let processBodyError be this step: run fetch finale given fetchParams\n    // and a network error.\n    const processBodyError = reason => fetchFinale(fetchParams, makeNetworkError(reason));\n\n    // 2. If request’s response tainting is \"opaque\", or response’s body is null,\n    // then run processBodyError and abort these steps.\n    if (request.responseTainting === 'opaque' || response.body == null) {\n      processBodyError(response.error);\n      return;\n    }\n\n    // 3. Let processBody given bytes be these steps:\n    const processBody = bytes => {\n      // 1. If bytes do not match request’s integrity metadata,\n      // then run processBodyError and abort these steps. [SRI]\n      if (!bytesMatch(bytes, request.integrity)) {\n        processBodyError('integrity mismatch');\n        return;\n      }\n\n      // 2. Set response’s body to bytes as a body.\n      response.body = safelyExtractBody(bytes)[0];\n\n      // 3. Run fetch finale given fetchParams and response.\n      fetchFinale(fetchParams, response);\n    };\n\n    // 4. Fully read response’s body given processBody and processBodyError.\n    await fullyReadBody(response.body, processBody, processBodyError);\n  } else {\n    // 21. Otherwise, run fetch finale given fetchParams and response.\n    fetchFinale(fetchParams, response);\n  }\n}\n\n// https://fetch.spec.whatwg.org/#concept-scheme-fetch\n// given a fetch params fetchParams\nfunction schemeFetch(fetchParams) {\n  // Note: since the connection is destroyed on redirect, which sets fetchParams to a\n  // cancelled state, we do not want this condition to trigger *unless* there have been\n  // no redirects. See https://github.com/nodejs/undici/issues/1776\n  // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n  if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {\n    return Promise.resolve(makeAppropriateNetworkError(fetchParams));\n  }\n\n  // 2. Let request be fetchParams’s request.\n  const {\n    request\n  } = fetchParams;\n  const {\n    protocol: scheme\n  } = requestCurrentURL(request);\n\n  // 3. Switch on request’s current URL’s scheme and run the associated steps:\n  switch (scheme) {\n    case 'about:':\n      {\n        // If request’s current URL’s path is the string \"blank\", then return a new response\n        // whose status message is `OK`, header list is « (`Content-Type`, `text/html;charset=utf-8`) »,\n        // and body is the empty byte sequence as a body.\n\n        // Otherwise, return a network error.\n        return Promise.resolve(makeNetworkError('about scheme is not supported'));\n      }\n    case 'blob:':\n      {\n        if (!resolveObjectURL) {\n          resolveObjectURL = require('node:buffer').resolveObjectURL;\n        }\n\n        // 1. Let blobURLEntry be request’s current URL’s blob URL entry.\n        const blobURLEntry = requestCurrentURL(request);\n\n        // https://github.com/web-platform-tests/wpt/blob/7b0ebaccc62b566a1965396e5be7bb2bc06f841f/FileAPI/url/resources/fetch-tests.js#L52-L56\n        // Buffer.resolveObjectURL does not ignore URL queries.\n        if (blobURLEntry.search.length !== 0) {\n          return Promise.resolve(makeNetworkError('NetworkError when attempting to fetch resource.'));\n        }\n        const blob = resolveObjectURL(blobURLEntry.toString());\n\n        // 2. If request’s method is not `GET`, blobURLEntry is null, or blobURLEntry’s\n        //    object is not a Blob object, then return a network error.\n        if (request.method !== 'GET' || !isBlobLike(blob)) {\n          return Promise.resolve(makeNetworkError('invalid method'));\n        }\n\n        // 3. Let blob be blobURLEntry’s object.\n        // Note: done above\n\n        // 4. Let response be a new response.\n        const response = makeResponse();\n\n        // 5. Let fullLength be blob’s size.\n        const fullLength = blob.size;\n\n        // 6. Let serializedFullLength be fullLength, serialized and isomorphic encoded.\n        const serializedFullLength = isomorphicEncode(`${fullLength}`);\n\n        // 7. Let type be blob’s type.\n        const type = blob.type;\n\n        // 8. If request’s header list does not contain `Range`:\n        // 9. Otherwise:\n        if (!request.headersList.contains('range', true)) {\n          // 1. Let bodyWithType be the result of safely extracting blob.\n          // Note: in the FileAPI a blob \"object\" is a Blob *or* a MediaSource.\n          // In node, this can only ever be a Blob. Therefore we can safely\n          // use extractBody directly.\n          const bodyWithType = extractBody(blob);\n\n          // 2. Set response’s status message to `OK`.\n          response.statusText = 'OK';\n\n          // 3. Set response’s body to bodyWithType’s body.\n          response.body = bodyWithType[0];\n\n          // 4. Set response’s header list to « (`Content-Length`, serializedFullLength), (`Content-Type`, type) ».\n          response.headersList.set('content-length', serializedFullLength, true);\n          response.headersList.set('content-type', type, true);\n        } else {\n          // 1. Set response’s range-requested flag.\n          response.rangeRequested = true;\n\n          // 2. Let rangeHeader be the result of getting `Range` from request’s header list.\n          const rangeHeader = request.headersList.get('range', true);\n\n          // 3. Let rangeValue be the result of parsing a single range header value given rangeHeader and true.\n          const rangeValue = simpleRangeHeaderValue(rangeHeader, true);\n\n          // 4. If rangeValue is failure, then return a network error.\n          if (rangeValue === 'failure') {\n            return Promise.resolve(makeNetworkError('failed to fetch the data URL'));\n          }\n\n          // 5. Let (rangeStart, rangeEnd) be rangeValue.\n          let {\n            rangeStartValue: rangeStart,\n            rangeEndValue: rangeEnd\n          } = rangeValue;\n\n          // 6. If rangeStart is null:\n          // 7. Otherwise:\n          if (rangeStart === null) {\n            // 1. Set rangeStart to fullLength − rangeEnd.\n            rangeStart = fullLength - rangeEnd;\n\n            // 2. Set rangeEnd to rangeStart + rangeEnd − 1.\n            rangeEnd = rangeStart + rangeEnd - 1;\n          } else {\n            // 1. If rangeStart is greater than or equal to fullLength, then return a network error.\n            if (rangeStart >= fullLength) {\n              return Promise.resolve(makeNetworkError('Range start is greater than the blob\\'s size.'));\n            }\n\n            // 2. If rangeEnd is null or rangeEnd is greater than or equal to fullLength, then set\n            //    rangeEnd to fullLength − 1.\n            if (rangeEnd === null || rangeEnd >= fullLength) {\n              rangeEnd = fullLength - 1;\n            }\n          }\n\n          // 8. Let slicedBlob be the result of invoking slice blob given blob, rangeStart,\n          //    rangeEnd + 1, and type.\n          const slicedBlob = blob.slice(rangeStart, rangeEnd, type);\n\n          // 9. Let slicedBodyWithType be the result of safely extracting slicedBlob.\n          // Note: same reason as mentioned above as to why we use extractBody\n          const slicedBodyWithType = extractBody(slicedBlob);\n\n          // 10. Set response’s body to slicedBodyWithType’s body.\n          response.body = slicedBodyWithType[0];\n\n          // 11. Let serializedSlicedLength be slicedBlob’s size, serialized and isomorphic encoded.\n          const serializedSlicedLength = isomorphicEncode(`${slicedBlob.size}`);\n\n          // 12. Let contentRange be the result of invoking build a content range given rangeStart,\n          //     rangeEnd, and fullLength.\n          const contentRange = buildContentRange(rangeStart, rangeEnd, fullLength);\n\n          // 13. Set response’s status to 206.\n          response.status = 206;\n\n          // 14. Set response’s status message to `Partial Content`.\n          response.statusText = 'Partial Content';\n\n          // 15. Set response’s header list to « (`Content-Length`, serializedSlicedLength),\n          //     (`Content-Type`, type), (`Content-Range`, contentRange) ».\n          response.headersList.set('content-length', serializedSlicedLength, true);\n          response.headersList.set('content-type', type, true);\n          response.headersList.set('content-range', contentRange, true);\n        }\n\n        // 10. Return response.\n        return Promise.resolve(response);\n      }\n    case 'data:':\n      {\n        // 1. Let dataURLStruct be the result of running the\n        //    data: URL processor on request’s current URL.\n        const currentURL = requestCurrentURL(request);\n        const dataURLStruct = dataURLProcessor(currentURL);\n\n        // 2. If dataURLStruct is failure, then return a\n        //    network error.\n        if (dataURLStruct === 'failure') {\n          return Promise.resolve(makeNetworkError('failed to fetch the data URL'));\n        }\n\n        // 3. Let mimeType be dataURLStruct’s MIME type, serialized.\n        const mimeType = serializeAMimeType(dataURLStruct.mimeType);\n\n        // 4. Return a response whose status message is `OK`,\n        //    header list is « (`Content-Type`, mimeType) »,\n        //    and body is dataURLStruct’s body as a body.\n        return Promise.resolve(makeResponse({\n          statusText: 'OK',\n          headersList: [['content-type', {\n            name: 'Content-Type',\n            value: mimeType\n          }]],\n          body: safelyExtractBody(dataURLStruct.body)[0]\n        }));\n      }\n    case 'file:':\n      {\n        // For now, unfortunate as it is, file URLs are left as an exercise for the reader.\n        // When in doubt, return a network error.\n        return Promise.resolve(makeNetworkError('not implemented... yet...'));\n      }\n    case 'http:':\n    case 'https:':\n      {\n        // Return the result of running HTTP fetch given fetchParams.\n\n        return httpFetch(fetchParams).catch(err => makeNetworkError(err));\n      }\n    default:\n      {\n        return Promise.resolve(makeNetworkError('unknown scheme'));\n      }\n  }\n}\n\n// https://fetch.spec.whatwg.org/#finalize-response\nfunction finalizeResponse(fetchParams, response) {\n  // 1. Set fetchParams’s request’s done flag.\n  fetchParams.request.done = true;\n\n  // 2, If fetchParams’s process response done is not null, then queue a fetch\n  // task to run fetchParams’s process response done given response, with\n  // fetchParams’s task destination.\n  if (fetchParams.processResponseDone != null) {\n    queueMicrotask(() => fetchParams.processResponseDone(response));\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetch-finale\nfunction fetchFinale(fetchParams, response) {\n  // 1. Let timingInfo be fetchParams’s timing info.\n  let timingInfo = fetchParams.timingInfo;\n\n  // 2. If response is not a network error and fetchParams’s request’s client is a secure context,\n  //    then set timingInfo’s server-timing headers to the result of getting, decoding, and splitting\n  //    `Server-Timing` from response’s internal response’s header list.\n  // TODO\n\n  // 3. Let processResponseEndOfBody be the following steps:\n  const processResponseEndOfBody = () => {\n    // 1. Let unsafeEndTime be the unsafe shared current time.\n    const unsafeEndTime = Date.now(); // ?\n\n    // 2. If fetchParams’s request’s destination is \"document\", then set fetchParams’s controller’s\n    //    full timing info to fetchParams’s timing info.\n    if (fetchParams.request.destination === 'document') {\n      fetchParams.controller.fullTimingInfo = timingInfo;\n    }\n\n    // 3. Set fetchParams’s controller’s report timing steps to the following steps given a global object global:\n    fetchParams.controller.reportTimingSteps = () => {\n      // 1. If fetchParams’s request’s URL’s scheme is not an HTTP(S) scheme, then return.\n      if (fetchParams.request.url.protocol !== 'https:') {\n        return;\n      }\n\n      // 2. Set timingInfo’s end time to the relative high resolution time given unsafeEndTime and global.\n      timingInfo.endTime = unsafeEndTime;\n\n      // 3. Let cacheState be response’s cache state.\n      let cacheState = response.cacheState;\n\n      // 4. Let bodyInfo be response’s body info.\n      const bodyInfo = response.bodyInfo;\n\n      // 5. If response’s timing allow passed flag is not set, then set timingInfo to the result of creating an\n      //    opaque timing info for timingInfo and set cacheState to the empty string.\n      if (!response.timingAllowPassed) {\n        timingInfo = createOpaqueTimingInfo(timingInfo);\n        cacheState = '';\n      }\n\n      // 6. Let responseStatus be 0.\n      let responseStatus = 0;\n\n      // 7. If fetchParams’s request’s mode is not \"navigate\" or response’s has-cross-origin-redirects is false:\n      if (fetchParams.request.mode !== 'navigator' || !response.hasCrossOriginRedirects) {\n        // 1. Set responseStatus to response’s status.\n        responseStatus = response.status;\n\n        // 2. Let mimeType be the result of extracting a MIME type from response’s header list.\n        const mimeType = extractMimeType(response.headersList);\n\n        // 3. If mimeType is not failure, then set bodyInfo’s content type to the result of minimizing a supported MIME type given mimeType.\n        if (mimeType !== 'failure') {\n          bodyInfo.contentType = minimizeSupportedMimeType(mimeType);\n        }\n      }\n\n      // 8. If fetchParams’s request’s initiator type is non-null, then mark resource timing given timingInfo,\n      //    fetchParams’s request’s URL, fetchParams’s request’s initiator type, global, cacheState, bodyInfo,\n      //    and responseStatus.\n      if (fetchParams.request.initiatorType != null) {\n        // TODO: update markresourcetiming\n        markResourceTiming(timingInfo, fetchParams.request.url.href, fetchParams.request.initiatorType, globalThis, cacheState, bodyInfo, responseStatus);\n      }\n    };\n\n    // 4. Let processResponseEndOfBodyTask be the following steps:\n    const processResponseEndOfBodyTask = () => {\n      // 1. Set fetchParams’s request’s done flag.\n      fetchParams.request.done = true;\n\n      // 2. If fetchParams’s process response end-of-body is non-null, then run fetchParams’s process\n      //    response end-of-body given response.\n      if (fetchParams.processResponseEndOfBody != null) {\n        queueMicrotask(() => fetchParams.processResponseEndOfBody(response));\n      }\n\n      // 3. If fetchParams’s request’s initiator type is non-null and fetchParams’s request’s client’s\n      //    global object is fetchParams’s task destination, then run fetchParams’s controller’s report\n      //    timing steps given fetchParams’s request’s client’s global object.\n      if (fetchParams.request.initiatorType != null) {\n        fetchParams.controller.reportTimingSteps();\n      }\n    };\n\n    // 5. Queue a fetch task to run processResponseEndOfBodyTask with fetchParams’s task destination\n    queueMicrotask(() => processResponseEndOfBodyTask());\n  };\n\n  // 4. If fetchParams’s process response is non-null, then queue a fetch task to run fetchParams’s\n  //    process response given response, with fetchParams’s task destination.\n  if (fetchParams.processResponse != null) {\n    queueMicrotask(() => {\n      fetchParams.processResponse(response);\n      fetchParams.processResponse = null;\n    });\n  }\n\n  // 5. Let internalResponse be response, if response is a network error; otherwise response’s internal response.\n  const internalResponse = response.type === 'error' ? response : response.internalResponse ?? response;\n\n  // 6. If internalResponse’s body is null, then run processResponseEndOfBody.\n  // 7. Otherwise:\n  if (internalResponse.body == null) {\n    processResponseEndOfBody();\n  } else {\n    // mcollina: all the following steps of the specs are skipped.\n    // The internal transform stream is not needed.\n    // See https://github.com/nodejs/undici/pull/3093#issuecomment-2050198541\n\n    // 1. Let transformStream be a new TransformStream.\n    // 2. Let identityTransformAlgorithm be an algorithm which, given chunk, enqueues chunk in transformStream.\n    // 3. Set up transformStream with transformAlgorithm set to identityTransformAlgorithm and flushAlgorithm\n    //    set to processResponseEndOfBody.\n    // 4. Set internalResponse’s body’s stream to the result of internalResponse’s body’s stream piped through transformStream.\n\n    finished(internalResponse.body.stream, () => {\n      processResponseEndOfBody();\n    });\n  }\n}\n\n// https://fetch.spec.whatwg.org/#http-fetch\nasync function httpFetch(fetchParams) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request;\n\n  // 2. Let response be null.\n  let response = null;\n\n  // 3. Let actualResponse be null.\n  let actualResponse = null;\n\n  // 4. Let timingInfo be fetchParams’s timing info.\n  const timingInfo = fetchParams.timingInfo;\n\n  // 5. If request’s service-workers mode is \"all\", then:\n  if (request.serviceWorkers === 'all') {\n    // TODO\n  }\n\n  // 6. If response is null, then:\n  if (response === null) {\n    // 1. If makeCORSPreflight is true and one of these conditions is true:\n    // TODO\n\n    // 2. If request’s redirect mode is \"follow\", then set request’s\n    // service-workers mode to \"none\".\n    if (request.redirect === 'follow') {\n      request.serviceWorkers = 'none';\n    }\n\n    // 3. Set response and actualResponse to the result of running\n    // HTTP-network-or-cache fetch given fetchParams.\n    actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);\n\n    // 4. If request’s response tainting is \"cors\" and a CORS check\n    // for request and response returns failure, then return a network error.\n    if (request.responseTainting === 'cors' && corsCheck(request, response) === 'failure') {\n      return makeNetworkError('cors failure');\n    }\n\n    // 5. If the TAO check for request and response returns failure, then set\n    // request’s timing allow failed flag.\n    if (TAOCheck(request, response) === 'failure') {\n      request.timingAllowFailed = true;\n    }\n  }\n\n  // 7. If either request’s response tainting or response’s type\n  // is \"opaque\", and the cross-origin resource policy check with\n  // request’s origin, request’s client, request’s destination,\n  // and actualResponse returns blocked, then return a network error.\n  if ((request.responseTainting === 'opaque' || response.type === 'opaque') && crossOriginResourcePolicyCheck(request.origin, request.client, request.destination, actualResponse) === 'blocked') {\n    return makeNetworkError('blocked');\n  }\n\n  // 8. If actualResponse’s status is a redirect status, then:\n  if (redirectStatusSet.has(actualResponse.status)) {\n    // 1. If actualResponse’s status is not 303, request’s body is not null,\n    // and the connection uses HTTP/2, then user agents may, and are even\n    // encouraged to, transmit an RST_STREAM frame.\n    // See, https://github.com/whatwg/fetch/issues/1288\n    if (request.redirect !== 'manual') {\n      fetchParams.controller.connection.destroy(undefined, false);\n    }\n\n    // 2. Switch on request’s redirect mode:\n    if (request.redirect === 'error') {\n      // Set response to a network error.\n      response = makeNetworkError('unexpected redirect');\n    } else if (request.redirect === 'manual') {\n      // Set response to an opaque-redirect filtered response whose internal\n      // response is actualResponse.\n      // NOTE(spec): On the web this would return an `opaqueredirect` response,\n      // but that doesn't make sense server side.\n      // See https://github.com/nodejs/undici/issues/1193.\n      response = actualResponse;\n    } else if (request.redirect === 'follow') {\n      // Set response to the result of running HTTP-redirect fetch given\n      // fetchParams and response.\n      response = await httpRedirectFetch(fetchParams, response);\n    } else {\n      assert(false);\n    }\n  }\n\n  // 9. Set response’s timing info to timingInfo.\n  response.timingInfo = timingInfo;\n\n  // 10. Return response.\n  return response;\n}\n\n// https://fetch.spec.whatwg.org/#http-redirect-fetch\nfunction httpRedirectFetch(fetchParams, response) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request;\n\n  // 2. Let actualResponse be response, if response is not a filtered response,\n  // and response’s internal response otherwise.\n  const actualResponse = response.internalResponse ? response.internalResponse : response;\n\n  // 3. Let locationURL be actualResponse’s location URL given request’s current\n  // URL’s fragment.\n  let locationURL;\n  try {\n    locationURL = responseLocationURL(actualResponse, requestCurrentURL(request).hash);\n\n    // 4. If locationURL is null, then return response.\n    if (locationURL == null) {\n      return response;\n    }\n  } catch (err) {\n    // 5. If locationURL is failure, then return a network error.\n    return Promise.resolve(makeNetworkError(err));\n  }\n\n  // 6. If locationURL’s scheme is not an HTTP(S) scheme, then return a network\n  // error.\n  if (!urlIsHttpHttpsScheme(locationURL)) {\n    return Promise.resolve(makeNetworkError('URL scheme must be a HTTP(S) scheme'));\n  }\n\n  // 7. If request’s redirect count is 20, then return a network error.\n  if (request.redirectCount === 20) {\n    return Promise.resolve(makeNetworkError('redirect count exceeded'));\n  }\n\n  // 8. Increase request’s redirect count by 1.\n  request.redirectCount += 1;\n\n  // 9. If request’s mode is \"cors\", locationURL includes credentials, and\n  // request’s origin is not same origin with locationURL’s origin, then return\n  //  a network error.\n  if (request.mode === 'cors' && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) {\n    return Promise.resolve(makeNetworkError('cross origin not allowed for request mode \"cors\"'));\n  }\n\n  // 10. If request’s response tainting is \"cors\" and locationURL includes\n  // credentials, then return a network error.\n  if (request.responseTainting === 'cors' && (locationURL.username || locationURL.password)) {\n    return Promise.resolve(makeNetworkError('URL cannot contain credentials for request mode \"cors\"'));\n  }\n\n  // 11. If actualResponse’s status is not 303, request’s body is non-null,\n  // and request’s body’s source is null, then return a network error.\n  if (actualResponse.status !== 303 && request.body != null && request.body.source == null) {\n    return Promise.resolve(makeNetworkError());\n  }\n\n  // 12. If one of the following is true\n  // - actualResponse’s status is 301 or 302 and request’s method is `POST`\n  // - actualResponse’s status is 303 and request’s method is not `GET` or `HEAD`\n  if ([301, 302].includes(actualResponse.status) && request.method === 'POST' || actualResponse.status === 303 && !GET_OR_HEAD.includes(request.method)) {\n    // then:\n    // 1. Set request’s method to `GET` and request’s body to null.\n    request.method = 'GET';\n    request.body = null;\n\n    // 2. For each headerName of request-body-header name, delete headerName from\n    // request’s header list.\n    for (const headerName of requestBodyHeader) {\n      request.headersList.delete(headerName);\n    }\n  }\n\n  // 13. If request’s current URL’s origin is not same origin with locationURL’s\n  //     origin, then for each headerName of CORS non-wildcard request-header name,\n  //     delete headerName from request’s header list.\n  if (!sameOrigin(requestCurrentURL(request), locationURL)) {\n    // https://fetch.spec.whatwg.org/#cors-non-wildcard-request-header-name\n    request.headersList.delete('authorization', true);\n\n    // https://fetch.spec.whatwg.org/#authentication-entries\n    request.headersList.delete('proxy-authorization', true);\n\n    // \"Cookie\" and \"Host\" are forbidden request-headers, which undici doesn't implement.\n    request.headersList.delete('cookie', true);\n    request.headersList.delete('host', true);\n  }\n\n  // 14. If request’s body is non-null, then set request’s body to the first return\n  // value of safely extracting request’s body’s source.\n  if (request.body != null) {\n    assert(request.body.source != null);\n    request.body = safelyExtractBody(request.body.source)[0];\n  }\n\n  // 15. Let timingInfo be fetchParams’s timing info.\n  const timingInfo = fetchParams.timingInfo;\n\n  // 16. Set timingInfo’s redirect end time and post-redirect start time to the\n  // coarsened shared current time given fetchParams’s cross-origin isolated\n  // capability.\n  timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);\n\n  // 17. If timingInfo’s redirect start time is 0, then set timingInfo’s\n  //  redirect start time to timingInfo’s start time.\n  if (timingInfo.redirectStartTime === 0) {\n    timingInfo.redirectStartTime = timingInfo.startTime;\n  }\n\n  // 18. Append locationURL to request’s URL list.\n  request.urlList.push(locationURL);\n\n  // 19. Invoke set request’s referrer policy on redirect on request and\n  // actualResponse.\n  setRequestReferrerPolicyOnRedirect(request, actualResponse);\n\n  // 20. Return the result of running main fetch given fetchParams and true.\n  return mainFetch(fetchParams, true);\n}\n\n// https://fetch.spec.whatwg.org/#http-network-or-cache-fetch\nasync function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request;\n\n  // 2. Let httpFetchParams be null.\n  let httpFetchParams = null;\n\n  // 3. Let httpRequest be null.\n  let httpRequest = null;\n\n  // 4. Let response be null.\n  let response = null;\n\n  // 5. Let storedResponse be null.\n  // TODO: cache\n\n  // 6. Let httpCache be null.\n  const httpCache = null;\n\n  // 7. Let the revalidatingFlag be unset.\n  const revalidatingFlag = false;\n\n  // 8. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. If request’s window is \"no-window\" and request’s redirect mode is\n  //    \"error\", then set httpFetchParams to fetchParams and httpRequest to\n  //    request.\n  if (request.window === 'no-window' && request.redirect === 'error') {\n    httpFetchParams = fetchParams;\n    httpRequest = request;\n  } else {\n    // Otherwise:\n\n    // 1. Set httpRequest to a clone of request.\n    httpRequest = cloneRequest(request);\n\n    // 2. Set httpFetchParams to a copy of fetchParams.\n    httpFetchParams = {\n      ...fetchParams\n    };\n\n    // 3. Set httpFetchParams’s request to httpRequest.\n    httpFetchParams.request = httpRequest;\n  }\n\n  //    3. Let includeCredentials be true if one of\n  const includeCredentials = request.credentials === 'include' || request.credentials === 'same-origin' && request.responseTainting === 'basic';\n\n  //    4. Let contentLength be httpRequest’s body’s length, if httpRequest’s\n  //    body is non-null; otherwise null.\n  const contentLength = httpRequest.body ? httpRequest.body.length : null;\n\n  //    5. Let contentLengthHeaderValue be null.\n  let contentLengthHeaderValue = null;\n\n  //    6. If httpRequest’s body is null and httpRequest’s method is `POST` or\n  //    `PUT`, then set contentLengthHeaderValue to `0`.\n  if (httpRequest.body == null && ['POST', 'PUT'].includes(httpRequest.method)) {\n    contentLengthHeaderValue = '0';\n  }\n\n  //    7. If contentLength is non-null, then set contentLengthHeaderValue to\n  //    contentLength, serialized and isomorphic encoded.\n  if (contentLength != null) {\n    contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);\n  }\n\n  //    8. If contentLengthHeaderValue is non-null, then append\n  //    `Content-Length`/contentLengthHeaderValue to httpRequest’s header\n  //    list.\n  if (contentLengthHeaderValue != null) {\n    httpRequest.headersList.append('content-length', contentLengthHeaderValue, true);\n  }\n\n  //    9. If contentLengthHeaderValue is non-null, then append (`Content-Length`,\n  //    contentLengthHeaderValue) to httpRequest’s header list.\n\n  //    10. If contentLength is non-null and httpRequest’s keepalive is true,\n  //    then:\n  if (contentLength != null && httpRequest.keepalive) {\n    // NOTE: keepalive is a noop outside of browser context.\n  }\n\n  //    11. If httpRequest’s referrer is a URL, then append\n  //    `Referer`/httpRequest’s referrer, serialized and isomorphic encoded,\n  //     to httpRequest’s header list.\n  if (httpRequest.referrer instanceof URL) {\n    httpRequest.headersList.append('referer', isomorphicEncode(httpRequest.referrer.href), true);\n  }\n\n  //    12. Append a request `Origin` header for httpRequest.\n  appendRequestOriginHeader(httpRequest);\n\n  //    13. Append the Fetch metadata headers for httpRequest. [FETCH-METADATA]\n  appendFetchMetadata(httpRequest);\n\n  //    14. If httpRequest’s header list does not contain `User-Agent`, then\n  //    user agents should append `User-Agent`/default `User-Agent` value to\n  //    httpRequest’s header list.\n  if (!httpRequest.headersList.contains('user-agent', true)) {\n    httpRequest.headersList.append('user-agent', defaultUserAgent);\n  }\n\n  //    15. If httpRequest’s cache mode is \"default\" and httpRequest’s header\n  //    list contains `If-Modified-Since`, `If-None-Match`,\n  //    `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set\n  //    httpRequest’s cache mode to \"no-store\".\n  if (httpRequest.cache === 'default' && (httpRequest.headersList.contains('if-modified-since', true) || httpRequest.headersList.contains('if-none-match', true) || httpRequest.headersList.contains('if-unmodified-since', true) || httpRequest.headersList.contains('if-match', true) || httpRequest.headersList.contains('if-range', true))) {\n    httpRequest.cache = 'no-store';\n  }\n\n  //    16. If httpRequest’s cache mode is \"no-cache\", httpRequest’s prevent\n  //    no-cache cache-control header modification flag is unset, and\n  //    httpRequest’s header list does not contain `Cache-Control`, then append\n  //    `Cache-Control`/`max-age=0` to httpRequest’s header list.\n  if (httpRequest.cache === 'no-cache' && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains('cache-control', true)) {\n    httpRequest.headersList.append('cache-control', 'max-age=0', true);\n  }\n\n  //    17. If httpRequest’s cache mode is \"no-store\" or \"reload\", then:\n  if (httpRequest.cache === 'no-store' || httpRequest.cache === 'reload') {\n    // 1. If httpRequest’s header list does not contain `Pragma`, then append\n    // `Pragma`/`no-cache` to httpRequest’s header list.\n    if (!httpRequest.headersList.contains('pragma', true)) {\n      httpRequest.headersList.append('pragma', 'no-cache', true);\n    }\n\n    // 2. If httpRequest’s header list does not contain `Cache-Control`,\n    // then append `Cache-Control`/`no-cache` to httpRequest’s header list.\n    if (!httpRequest.headersList.contains('cache-control', true)) {\n      httpRequest.headersList.append('cache-control', 'no-cache', true);\n    }\n  }\n\n  //    18. If httpRequest’s header list contains `Range`, then append\n  //    `Accept-Encoding`/`identity` to httpRequest’s header list.\n  if (httpRequest.headersList.contains('range', true)) {\n    httpRequest.headersList.append('accept-encoding', 'identity', true);\n  }\n\n  //    19. Modify httpRequest’s header list per HTTP. Do not append a given\n  //    header if httpRequest’s header list contains that header’s name.\n  //    TODO: https://github.com/whatwg/fetch/issues/1285#issuecomment-896560129\n  if (!httpRequest.headersList.contains('accept-encoding', true)) {\n    if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {\n      httpRequest.headersList.append('accept-encoding', 'br, gzip, deflate', true);\n    } else {\n      httpRequest.headersList.append('accept-encoding', 'gzip, deflate', true);\n    }\n  }\n  httpRequest.headersList.delete('host', true);\n\n  //    20. If includeCredentials is true, then:\n  if (includeCredentials) {\n    // 1. If the user agent is not configured to block cookies for httpRequest\n    // (see section 7 of [COOKIES]), then:\n    // TODO: credentials\n    // 2. If httpRequest’s header list does not contain `Authorization`, then:\n    // TODO: credentials\n  }\n\n  //    21. If there’s a proxy-authentication entry, use it as appropriate.\n  //    TODO: proxy-authentication\n\n  //    22. Set httpCache to the result of determining the HTTP cache\n  //    partition, given httpRequest.\n  //    TODO: cache\n\n  //    23. If httpCache is null, then set httpRequest’s cache mode to\n  //    \"no-store\".\n  if (httpCache == null) {\n    httpRequest.cache = 'no-store';\n  }\n\n  //    24. If httpRequest’s cache mode is neither \"no-store\" nor \"reload\",\n  //    then:\n  if (httpRequest.cache !== 'no-store' && httpRequest.cache !== 'reload') {\n    // TODO: cache\n  }\n\n  // 9. If aborted, then return the appropriate network error for fetchParams.\n  // TODO\n\n  // 10. If response is null, then:\n  if (response == null) {\n    // 1. If httpRequest’s cache mode is \"only-if-cached\", then return a\n    // network error.\n    if (httpRequest.cache === 'only-if-cached') {\n      return makeNetworkError('only if cached');\n    }\n\n    // 2. Let forwardResponse be the result of running HTTP-network fetch\n    // given httpFetchParams, includeCredentials, and isNewConnectionFetch.\n    const forwardResponse = await httpNetworkFetch(httpFetchParams, includeCredentials, isNewConnectionFetch);\n\n    // 3. If httpRequest’s method is unsafe and forwardResponse’s status is\n    // in the range 200 to 399, inclusive, invalidate appropriate stored\n    // responses in httpCache, as per the \"Invalidation\" chapter of HTTP\n    // Caching, and set storedResponse to null. [HTTP-CACHING]\n    if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {\n      // TODO: cache\n    }\n\n    // 4. If the revalidatingFlag is set and forwardResponse’s status is 304,\n    // then:\n    if (revalidatingFlag && forwardResponse.status === 304) {\n      // TODO: cache\n    }\n\n    // 5. If response is null, then:\n    if (response == null) {\n      // 1. Set response to forwardResponse.\n      response = forwardResponse;\n\n      // 2. Store httpRequest and forwardResponse in httpCache, as per the\n      // \"Storing Responses in Caches\" chapter of HTTP Caching. [HTTP-CACHING]\n      // TODO: cache\n    }\n  }\n\n  // 11. Set response’s URL list to a clone of httpRequest’s URL list.\n  response.urlList = [...httpRequest.urlList];\n\n  // 12. If httpRequest’s header list contains `Range`, then set response’s\n  // range-requested flag.\n  if (httpRequest.headersList.contains('range', true)) {\n    response.rangeRequested = true;\n  }\n\n  // 13. Set response’s request-includes-credentials to includeCredentials.\n  response.requestIncludesCredentials = includeCredentials;\n\n  // 14. If response’s status is 401, httpRequest’s response tainting is not\n  // \"cors\", includeCredentials is true, and request’s window is an environment\n  // settings object, then:\n  // TODO\n\n  // 15. If response’s status is 407, then:\n  if (response.status === 407) {\n    // 1. If request’s window is \"no-window\", then return a network error.\n    if (request.window === 'no-window') {\n      return makeNetworkError();\n    }\n\n    // 2. ???\n\n    // 3. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n    if (isCancelled(fetchParams)) {\n      return makeAppropriateNetworkError(fetchParams);\n    }\n\n    // 4. Prompt the end user as appropriate in request’s window and store\n    // the result as a proxy-authentication entry. [HTTP-AUTH]\n    // TODO: Invoke some kind of callback?\n\n    // 5. Set response to the result of running HTTP-network-or-cache fetch given\n    // fetchParams.\n    // TODO\n    return makeNetworkError('proxy authentication required');\n  }\n\n  // 16. If all of the following are true\n  if (\n  // response’s status is 421\n  response.status === 421 &&\n  // isNewConnectionFetch is false\n  !isNewConnectionFetch && (\n  // request’s body is null, or request’s body is non-null and request’s body’s source is non-null\n  request.body == null || request.body.source != null)) {\n    // then:\n\n    // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n    if (isCancelled(fetchParams)) {\n      return makeAppropriateNetworkError(fetchParams);\n    }\n\n    // 2. Set response to the result of running HTTP-network-or-cache\n    // fetch given fetchParams, isAuthenticationFetch, and true.\n\n    // TODO (spec): The spec doesn't specify this but we need to cancel\n    // the active response before we can start a new one.\n    // https://github.com/whatwg/fetch/issues/1293\n    fetchParams.controller.connection.destroy();\n    response = await httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, true);\n  }\n\n  // 17. If isAuthenticationFetch is true, then create an authentication entry\n  if (isAuthenticationFetch) {\n    // TODO\n  }\n\n  // 18. Return response.\n  return response;\n}\n\n// https://fetch.spec.whatwg.org/#http-network-fetch\nasync function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {\n  assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);\n  fetchParams.controller.connection = {\n    abort: null,\n    destroyed: false,\n    destroy(err, abort = true) {\n      if (!this.destroyed) {\n        this.destroyed = true;\n        if (abort) {\n          this.abort?.(err ?? new DOMException('The operation was aborted.', 'AbortError'));\n        }\n      }\n    }\n  };\n\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request;\n\n  // 2. Let response be null.\n  let response = null;\n\n  // 3. Let timingInfo be fetchParams’s timing info.\n  const timingInfo = fetchParams.timingInfo;\n\n  // 4. Let httpCache be the result of determining the HTTP cache partition,\n  // given request.\n  // TODO: cache\n  const httpCache = null;\n\n  // 5. If httpCache is null, then set request’s cache mode to \"no-store\".\n  if (httpCache == null) {\n    request.cache = 'no-store';\n  }\n\n  // 6. Let networkPartitionKey be the result of determining the network\n  // partition key given request.\n  // TODO\n\n  // 7. Let newConnection be \"yes\" if forceNewConnection is true; otherwise\n  // \"no\".\n  const newConnection = forceNewConnection ? 'yes' : 'no'; // eslint-disable-line no-unused-vars\n\n  // 8. Switch on request’s mode:\n  if (request.mode === 'websocket') {\n    // Let connection be the result of obtaining a WebSocket connection,\n    // given request’s current URL.\n    // TODO\n  } else {\n    // Let connection be the result of obtaining a connection, given\n    // networkPartitionKey, request’s current URL’s origin,\n    // includeCredentials, and forceNewConnection.\n    // TODO\n  }\n\n  // 9. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. If connection is failure, then return a network error.\n\n  //    2. Set timingInfo’s final connection timing info to the result of\n  //    calling clamp and coarsen connection timing info with connection’s\n  //    timing info, timingInfo’s post-redirect start time, and fetchParams’s\n  //    cross-origin isolated capability.\n\n  //    3. If connection is not an HTTP/2 connection, request’s body is non-null,\n  //    and request’s body’s source is null, then append (`Transfer-Encoding`,\n  //    `chunked`) to request’s header list.\n\n  //    4. Set timingInfo’s final network-request start time to the coarsened\n  //    shared current time given fetchParams’s cross-origin isolated\n  //    capability.\n\n  //    5. Set response to the result of making an HTTP request over connection\n  //    using request with the following caveats:\n\n  //        - Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS]\n  //        [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]\n\n  //        - If request’s body is non-null, and request’s body’s source is null,\n  //        then the user agent may have a buffer of up to 64 kibibytes and store\n  //        a part of request’s body in that buffer. If the user agent reads from\n  //        request’s body beyond that buffer’s size and the user agent needs to\n  //        resend request, then instead return a network error.\n\n  //        - Set timingInfo’s final network-response start time to the coarsened\n  //        shared current time given fetchParams’s cross-origin isolated capability,\n  //        immediately after the user agent’s HTTP parser receives the first byte\n  //        of the response (e.g., frame header bytes for HTTP/2 or response status\n  //        line for HTTP/1.x).\n\n  //        - Wait until all the headers are transmitted.\n\n  //        - Any responses whose status is in the range 100 to 199, inclusive,\n  //        and is not 101, are to be ignored, except for the purposes of setting\n  //        timingInfo’s final network-response start time above.\n\n  //    - If request’s header list contains `Transfer-Encoding`/`chunked` and\n  //    response is transferred via HTTP/1.0 or older, then return a network\n  //    error.\n\n  //    - If the HTTP request results in a TLS client certificate dialog, then:\n\n  //        1. If request’s window is an environment settings object, make the\n  //        dialog available in request’s window.\n\n  //        2. Otherwise, return a network error.\n\n  // To transmit request’s body body, run these steps:\n  let requestBody = null;\n  // 1. If body is null and fetchParams’s process request end-of-body is\n  // non-null, then queue a fetch task given fetchParams’s process request\n  // end-of-body and fetchParams’s task destination.\n  if (request.body == null && fetchParams.processRequestEndOfBody) {\n    queueMicrotask(() => fetchParams.processRequestEndOfBody());\n  } else if (request.body != null) {\n    // 2. Otherwise, if body is non-null:\n\n    //    1. Let processBodyChunk given bytes be these steps:\n    const processBodyChunk = async function* (bytes) {\n      // 1. If the ongoing fetch is terminated, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return;\n      }\n\n      // 2. Run this step in parallel: transmit bytes.\n      yield bytes;\n\n      // 3. If fetchParams’s process request body is non-null, then run\n      // fetchParams’s process request body given bytes’s length.\n      fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);\n    };\n\n    // 2. Let processEndOfBody be these steps:\n    const processEndOfBody = () => {\n      // 1. If fetchParams is canceled, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return;\n      }\n\n      // 2. If fetchParams’s process request end-of-body is non-null,\n      // then run fetchParams’s process request end-of-body.\n      if (fetchParams.processRequestEndOfBody) {\n        fetchParams.processRequestEndOfBody();\n      }\n    };\n\n    // 3. Let processBodyError given e be these steps:\n    const processBodyError = e => {\n      // 1. If fetchParams is canceled, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return;\n      }\n\n      // 2. If e is an \"AbortError\" DOMException, then abort fetchParams’s controller.\n      if (e.name === 'AbortError') {\n        fetchParams.controller.abort();\n      } else {\n        fetchParams.controller.terminate(e);\n      }\n    };\n\n    // 4. Incrementally read request’s body given processBodyChunk, processEndOfBody,\n    // processBodyError, and fetchParams’s task destination.\n    requestBody = async function* () {\n      try {\n        for await (const bytes of request.body.stream) {\n          yield* processBodyChunk(bytes);\n        }\n        processEndOfBody();\n      } catch (err) {\n        processBodyError(err);\n      }\n    }();\n  }\n  try {\n    // socket is only provided for websockets\n    const {\n      body,\n      status,\n      statusText,\n      headersList,\n      socket\n    } = await dispatch({\n      body: requestBody\n    });\n    if (socket) {\n      response = makeResponse({\n        status,\n        statusText,\n        headersList,\n        socket\n      });\n    } else {\n      const iterator = body[Symbol.asyncIterator]();\n      fetchParams.controller.next = () => iterator.next();\n      response = makeResponse({\n        status,\n        statusText,\n        headersList\n      });\n    }\n  } catch (err) {\n    // 10. If aborted, then:\n    if (err.name === 'AbortError') {\n      // 1. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n      fetchParams.controller.connection.destroy();\n\n      // 2. Return the appropriate network error for fetchParams.\n      return makeAppropriateNetworkError(fetchParams, err);\n    }\n    return makeNetworkError(err);\n  }\n\n  // 11. Let pullAlgorithm be an action that resumes the ongoing fetch\n  // if it is suspended.\n  const pullAlgorithm = async () => {\n    await fetchParams.controller.resume();\n  };\n\n  // 12. Let cancelAlgorithm be an algorithm that aborts fetchParams’s\n  // controller with reason, given reason.\n  const cancelAlgorithm = reason => {\n    // If the aborted fetch was already terminated, then we do not\n    // need to do anything.\n    if (!isCancelled(fetchParams)) {\n      fetchParams.controller.abort(reason);\n    }\n  };\n\n  // 13. Let highWaterMark be a non-negative, non-NaN number, chosen by\n  // the user agent.\n  // TODO\n\n  // 14. Let sizeAlgorithm be an algorithm that accepts a chunk object\n  // and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.\n  // TODO\n\n  // 15. Let stream be a new ReadableStream.\n  // 16. Set up stream with byte reading support with pullAlgorithm set to pullAlgorithm,\n  //     cancelAlgorithm set to cancelAlgorithm.\n  const stream = new ReadableStream({\n    async start(controller) {\n      fetchParams.controller.controller = controller;\n    },\n    async pull(controller) {\n      await pullAlgorithm(controller);\n    },\n    async cancel(reason) {\n      await cancelAlgorithm(reason);\n    },\n    type: 'bytes'\n  });\n\n  // 17. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. Set response’s body to a new body whose stream is stream.\n  response.body = {\n    stream,\n    source: null,\n    length: null\n  };\n\n  //    2. If response is not a network error and request’s cache mode is\n  //    not \"no-store\", then update response in httpCache for request.\n  //    TODO\n\n  //    3. If includeCredentials is true and the user agent is not configured\n  //    to block cookies for request (see section 7 of [COOKIES]), then run the\n  //    \"set-cookie-string\" parsing algorithm (see section 5.2 of [COOKIES]) on\n  //    the value of each header whose name is a byte-case-insensitive match for\n  //    `Set-Cookie` in response’s header list, if any, and request’s current URL.\n  //    TODO\n\n  // 18. If aborted, then:\n  // TODO\n\n  // 19. Run these steps in parallel:\n\n  //    1. Run these steps, but abort when fetchParams is canceled:\n  fetchParams.controller.onAborted = onAborted;\n  fetchParams.controller.on('terminated', onAborted);\n  fetchParams.controller.resume = async () => {\n    // 1. While true\n    while (true) {\n      // 1-3. See onData...\n\n      // 4. Set bytes to the result of handling content codings given\n      // codings and bytes.\n      let bytes;\n      let isFailure;\n      try {\n        const {\n          done,\n          value\n        } = await fetchParams.controller.next();\n        if (isAborted(fetchParams)) {\n          break;\n        }\n        bytes = done ? undefined : value;\n      } catch (err) {\n        if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {\n          // zlib doesn't like empty streams.\n          bytes = undefined;\n        } else {\n          bytes = err;\n\n          // err may be propagated from the result of calling readablestream.cancel,\n          // which might not be an error. https://github.com/nodejs/undici/issues/2009\n          isFailure = true;\n        }\n      }\n      if (bytes === undefined) {\n        // 2. Otherwise, if the bytes transmission for response’s message\n        // body is done normally and stream is readable, then close\n        // stream, finalize response for fetchParams and response, and\n        // abort these in-parallel steps.\n        readableStreamClose(fetchParams.controller.controller);\n        finalizeResponse(fetchParams, response);\n        return;\n      }\n\n      // 5. Increase timingInfo’s decoded body size by bytes’s length.\n      timingInfo.decodedBodySize += bytes?.byteLength ?? 0;\n\n      // 6. If bytes is failure, then terminate fetchParams’s controller.\n      if (isFailure) {\n        fetchParams.controller.terminate(bytes);\n        return;\n      }\n\n      // 7. Enqueue a Uint8Array wrapping an ArrayBuffer containing bytes\n      // into stream.\n      const buffer = new Uint8Array(bytes);\n      if (buffer.byteLength) {\n        fetchParams.controller.controller.enqueue(buffer);\n      }\n\n      // 8. If stream is errored, then terminate the ongoing fetch.\n      if (isErrored(stream)) {\n        fetchParams.controller.terminate();\n        return;\n      }\n\n      // 9. If stream doesn’t need more data ask the user agent to suspend\n      // the ongoing fetch.\n      if (fetchParams.controller.controller.desiredSize <= 0) {\n        return;\n      }\n    }\n  };\n\n  //    2. If aborted, then:\n  function onAborted(reason) {\n    // 2. If fetchParams is aborted, then:\n    if (isAborted(fetchParams)) {\n      // 1. Set response’s aborted flag.\n      response.aborted = true;\n\n      // 2. If stream is readable, then error stream with the result of\n      //    deserialize a serialized abort reason given fetchParams’s\n      //    controller’s serialized abort reason and an\n      //    implementation-defined realm.\n      if (isReadable(stream)) {\n        fetchParams.controller.controller.error(fetchParams.controller.serializedAbortReason);\n      }\n    } else {\n      // 3. Otherwise, if stream is readable, error stream with a TypeError.\n      if (isReadable(stream)) {\n        fetchParams.controller.controller.error(new TypeError('terminated', {\n          cause: isErrorLike(reason) ? reason : undefined\n        }));\n      }\n    }\n\n    // 4. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n    // 5. Otherwise, the user agent should close connection unless it would be bad for performance to do so.\n    fetchParams.controller.connection.destroy();\n  }\n\n  // 20. Return response.\n  return response;\n  function dispatch({\n    body\n  }) {\n    const url = requestCurrentURL(request);\n    /** @type {import('../..').Agent} */\n    const agent = fetchParams.controller.dispatcher;\n    return new Promise((resolve, reject) => agent.dispatch({\n      path: url.pathname + url.search,\n      origin: url.origin,\n      method: request.method,\n      body: agent.isMockActive ? request.body && (request.body.source || request.body.stream) : body,\n      headers: request.headersList.entries,\n      maxRedirections: 0,\n      upgrade: request.mode === 'websocket' ? 'websocket' : undefined\n    }, {\n      body: null,\n      abort: null,\n      onConnect(abort) {\n        // TODO (fix): Do we need connection here?\n        const {\n          connection\n        } = fetchParams.controller;\n\n        // Set timingInfo’s final connection timing info to the result of calling clamp and coarsen\n        // connection timing info with connection’s timing info, timingInfo’s post-redirect start\n        // time, and fetchParams’s cross-origin isolated capability.\n        // TODO: implement connection timing\n        timingInfo.finalConnectionTimingInfo = clampAndCoarsenConnectionTimingInfo(undefined, timingInfo.postRedirectStartTime, fetchParams.crossOriginIsolatedCapability);\n        if (connection.destroyed) {\n          abort(new DOMException('The operation was aborted.', 'AbortError'));\n        } else {\n          fetchParams.controller.on('terminated', abort);\n          this.abort = connection.abort = abort;\n        }\n\n        // Set timingInfo’s final network-request start time to the coarsened shared current time given\n        // fetchParams’s cross-origin isolated capability.\n        timingInfo.finalNetworkRequestStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);\n      },\n      onResponseStarted() {\n        // Set timingInfo’s final network-response start time to the coarsened shared current\n        // time given fetchParams’s cross-origin isolated capability, immediately after the\n        // user agent’s HTTP parser receives the first byte of the response (e.g., frame header\n        // bytes for HTTP/2 or response status line for HTTP/1.x).\n        timingInfo.finalNetworkResponseStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);\n      },\n      onHeaders(status, rawHeaders, resume, statusText) {\n        if (status < 200) {\n          return;\n        }\n\n        /** @type {string[]} */\n        let codings = [];\n        let location = '';\n        const headersList = new HeadersList();\n        for (let i = 0; i < rawHeaders.length; i += 2) {\n          headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString('latin1'), true);\n        }\n        const contentEncoding = headersList.get('content-encoding', true);\n        if (contentEncoding) {\n          // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1\n          // \"All content-coding values are case-insensitive...\"\n          codings = contentEncoding.toLowerCase().split(',').map(x => x.trim());\n        }\n        location = headersList.get('location', true);\n        this.body = new Readable({\n          read: resume\n        });\n        const decoders = [];\n        const willFollow = location && request.redirect === 'follow' && redirectStatusSet.has(status);\n\n        // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding\n        if (codings.length !== 0 && request.method !== 'HEAD' && request.method !== 'CONNECT' && !nullBodyStatus.includes(status) && !willFollow) {\n          for (let i = 0; i < codings.length; ++i) {\n            const coding = codings[i];\n            // https://www.rfc-editor.org/rfc/rfc9112.html#section-7.2\n            if (coding === 'x-gzip' || coding === 'gzip') {\n              decoders.push(zlib.createGunzip({\n                // Be less strict when decoding compressed responses, since sometimes\n                // servers send slightly invalid responses that are still accepted\n                // by common browsers.\n                // Always using Z_SYNC_FLUSH is what cURL does.\n                flush: zlib.constants.Z_SYNC_FLUSH,\n                finishFlush: zlib.constants.Z_SYNC_FLUSH\n              }));\n            } else if (coding === 'deflate') {\n              decoders.push(createInflate());\n            } else if (coding === 'br') {\n              decoders.push(zlib.createBrotliDecompress());\n            } else {\n              decoders.length = 0;\n              break;\n            }\n          }\n        }\n        resolve({\n          status,\n          statusText,\n          headersList,\n          body: decoders.length ? pipeline(this.body, ...decoders, () => {}) : this.body.on('error', () => {})\n        });\n        return true;\n      },\n      onData(chunk) {\n        if (fetchParams.controller.dump) {\n          return;\n        }\n\n        // 1. If one or more bytes have been transmitted from response’s\n        // message body, then:\n\n        //  1. Let bytes be the transmitted bytes.\n        const bytes = chunk;\n\n        //  2. Let codings be the result of extracting header list values\n        //  given `Content-Encoding` and response’s header list.\n        //  See pullAlgorithm.\n\n        //  3. Increase timingInfo’s encoded body size by bytes’s length.\n        timingInfo.encodedBodySize += bytes.byteLength;\n\n        //  4. See pullAlgorithm...\n\n        return this.body.push(bytes);\n      },\n      onComplete() {\n        if (this.abort) {\n          fetchParams.controller.off('terminated', this.abort);\n        }\n        if (fetchParams.controller.onAborted) {\n          fetchParams.controller.off('terminated', fetchParams.controller.onAborted);\n        }\n        fetchParams.controller.ended = true;\n        this.body.push(null);\n      },\n      onError(error) {\n        if (this.abort) {\n          fetchParams.controller.off('terminated', this.abort);\n        }\n        this.body?.destroy(error);\n        fetchParams.controller.terminate(error);\n        reject(error);\n      },\n      onUpgrade(status, rawHeaders, socket) {\n        if (status !== 101) {\n          return;\n        }\n        const headersList = new HeadersList();\n        for (let i = 0; i < rawHeaders.length; i += 2) {\n          headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString('latin1'), true);\n        }\n        resolve({\n          status,\n          statusText: STATUS_CODES[status],\n          headersList,\n          socket\n        });\n        return true;\n      }\n    }));\n  }\n}\nmodule.exports = {\n  fetch,\n  Fetch,\n  fetching,\n  finalizeAndReportTiming\n};","map":{"version":3,"names":["makeNetworkError","makeAppropriateNetworkError","filterResponse","makeResponse","fromInnerResponse","require","HeadersList","Request","cloneRequest","zlib","bytesMatch","makePolicyContainer","clonePolicyContainer","requestBadPort","TAOCheck","appendRequestOriginHeader","responseLocationURL","requestCurrentURL","setRequestReferrerPolicyOnRedirect","tryUpgradeRequestToAPotentiallyTrustworthyURL","createOpaqueTimingInfo","appendFetchMetadata","corsCheck","crossOriginResourcePolicyCheck","determineRequestsReferrer","coarsenedSharedCurrentTime","createDeferredPromise","isBlobLike","sameOrigin","isCancelled","isAborted","isErrorLike","fullyReadBody","readableStreamClose","isomorphicEncode","urlIsLocal","urlIsHttpHttpsScheme","urlHasHttpsScheme","clampAndCoarsenConnectionTimingInfo","simpleRangeHeaderValue","buildContentRange","createInflate","extractMimeType","kState","kDispatcher","assert","safelyExtractBody","extractBody","redirectStatusSet","nullBodyStatus","safeMethodsSet","requestBodyHeader","subresourceSet","EE","Readable","pipeline","finished","addAbortListener","isErrored","isReadable","bufferToLowerCasedHeaderName","dataURLProcessor","serializeAMimeType","minimizeSupportedMimeType","getGlobalDispatcher","webidl","STATUS_CODES","GET_OR_HEAD","defaultUserAgent","__UNDICI_IS_NODE__","esbuildDetection","resolveObjectURL","Fetch","constructor","dispatcher","connection","dump","state","terminate","reason","destroy","emit","abort","error","DOMException","serializedAbortReason","handleFetchDone","response","finalizeAndReportTiming","fetch","input","init","undefined","argumentLengthCheck","arguments","p","requestObject","e","reject","promise","request","signal","aborted","abortFetch","globalObject","client","name","serviceWorkers","responseObject","locallyAborted","controller","realResponse","deref","processResponse","type","TypeError","cause","WeakRef","resolve","fetching","processResponseEndOfBody","initiatorType","urlList","length","originalURL","timingInfo","cacheState","timingAllowPassed","startTime","endTime","markResourceTiming","href","globalThis","performance","body","stream","cancel","catch","err","code","processRequestBodyChunkLength","processRequestEndOfBody","processResponseConsumeBody","useParallelQueue","taskDestination","crossOriginIsolatedCapability","currentTime","fetchParams","window","origin","policyContainer","headersList","contains","value","append","priority","has","destination","mainFetch","recursive","localURLsOnly","referrerPolicy","referrer","currentURL","url","responseTainting","protocol","mode","schemeFetch","redirect","httpFetch","status","internalResponse","push","timingAllowFailed","rangeRequested","headers","method","includes","integrity","processBodyError","fetchFinale","processBody","bytes","redirectCount","Promise","scheme","blobURLEntry","search","blob","toString","fullLength","size","serializedFullLength","bodyWithType","statusText","set","rangeHeader","get","rangeValue","rangeStartValue","rangeStart","rangeEndValue","rangeEnd","slicedBlob","slice","slicedBodyWithType","serializedSlicedLength","contentRange","dataURLStruct","mimeType","finalizeResponse","done","processResponseDone","queueMicrotask","unsafeEndTime","Date","now","fullTimingInfo","reportTimingSteps","bodyInfo","responseStatus","hasCrossOriginRedirects","contentType","processResponseEndOfBodyTask","actualResponse","httpNetworkOrCacheFetch","httpRedirectFetch","locationURL","hash","username","password","source","headerName","delete","redirectEndTime","postRedirectStartTime","redirectStartTime","isAuthenticationFetch","isNewConnectionFetch","httpFetchParams","httpRequest","httpCache","revalidatingFlag","includeCredentials","credentials","contentLength","contentLengthHeaderValue","keepalive","URL","cache","preventNoCacheCacheControlHeaderModification","forwardResponse","httpNetworkFetch","requestIncludesCredentials","forceNewConnection","destroyed","newConnection","requestBody","processBodyChunk","byteLength","processEndOfBody","socket","dispatch","iterator","Symbol","asyncIterator","next","pullAlgorithm","resume","cancelAlgorithm","ReadableStream","start","pull","onAborted","on","isFailure","ended","encodedBodySize","decodedBodySize","buffer","Uint8Array","enqueue","desiredSize","agent","path","pathname","isMockActive","entries","maxRedirections","upgrade","onConnect","finalConnectionTimingInfo","finalNetworkRequestStartTime","onResponseStarted","finalNetworkResponseStartTime","onHeaders","rawHeaders","codings","location","i","contentEncoding","toLowerCase","split","map","x","trim","read","decoders","willFollow","coding","createGunzip","flush","constants","Z_SYNC_FLUSH","finishFlush","createBrotliDecompress","onData","chunk","onComplete","off","onError","onUpgrade","module","exports"],"sources":["/Users/nataliia/PussyProjects/react-app/node_modules/undici/lib/web/fetch/index.js"],"sourcesContent":["// https://github.com/Ethan-Arrowood/undici-fetch\n\n'use strict'\n\nconst {\n  makeNetworkError,\n  makeAppropriateNetworkError,\n  filterResponse,\n  makeResponse,\n  fromInnerResponse\n} = require('./response')\nconst { HeadersList } = require('./headers')\nconst { Request, cloneRequest } = require('./request')\nconst zlib = require('node:zlib')\nconst {\n  bytesMatch,\n  makePolicyContainer,\n  clonePolicyContainer,\n  requestBadPort,\n  TAOCheck,\n  appendRequestOriginHeader,\n  responseLocationURL,\n  requestCurrentURL,\n  setRequestReferrerPolicyOnRedirect,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  createOpaqueTimingInfo,\n  appendFetchMetadata,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  determineRequestsReferrer,\n  coarsenedSharedCurrentTime,\n  createDeferredPromise,\n  isBlobLike,\n  sameOrigin,\n  isCancelled,\n  isAborted,\n  isErrorLike,\n  fullyReadBody,\n  readableStreamClose,\n  isomorphicEncode,\n  urlIsLocal,\n  urlIsHttpHttpsScheme,\n  urlHasHttpsScheme,\n  clampAndCoarsenConnectionTimingInfo,\n  simpleRangeHeaderValue,\n  buildContentRange,\n  createInflate,\n  extractMimeType\n} = require('./util')\nconst { kState, kDispatcher } = require('./symbols')\nconst assert = require('node:assert')\nconst { safelyExtractBody, extractBody } = require('./body')\nconst {\n  redirectStatusSet,\n  nullBodyStatus,\n  safeMethodsSet,\n  requestBodyHeader,\n  subresourceSet\n} = require('./constants')\nconst EE = require('node:events')\nconst { Readable, pipeline, finished } = require('node:stream')\nconst { addAbortListener, isErrored, isReadable, bufferToLowerCasedHeaderName } = require('../../core/util')\nconst { dataURLProcessor, serializeAMimeType, minimizeSupportedMimeType } = require('./data-url')\nconst { getGlobalDispatcher } = require('../../global')\nconst { webidl } = require('./webidl')\nconst { STATUS_CODES } = require('node:http')\nconst GET_OR_HEAD = ['GET', 'HEAD']\n\nconst defaultUserAgent = typeof __UNDICI_IS_NODE__ !== 'undefined' || typeof esbuildDetection !== 'undefined'\n  ? 'node'\n  : 'undici'\n\n/** @type {import('buffer').resolveObjectURL} */\nlet resolveObjectURL\n\nclass Fetch extends EE {\n  constructor (dispatcher) {\n    super()\n\n    this.dispatcher = dispatcher\n    this.connection = null\n    this.dump = false\n    this.state = 'ongoing'\n  }\n\n  terminate (reason) {\n    if (this.state !== 'ongoing') {\n      return\n    }\n\n    this.state = 'terminated'\n    this.connection?.destroy(reason)\n    this.emit('terminated', reason)\n  }\n\n  // https://fetch.spec.whatwg.org/#fetch-controller-abort\n  abort (error) {\n    if (this.state !== 'ongoing') {\n      return\n    }\n\n    // 1. Set controller’s state to \"aborted\".\n    this.state = 'aborted'\n\n    // 2. Let fallbackError be an \"AbortError\" DOMException.\n    // 3. Set error to fallbackError if it is not given.\n    if (!error) {\n      error = new DOMException('The operation was aborted.', 'AbortError')\n    }\n\n    // 4. Let serializedError be StructuredSerialize(error).\n    //    If that threw an exception, catch it, and let\n    //    serializedError be StructuredSerialize(fallbackError).\n\n    // 5. Set controller’s serialized abort reason to serializedError.\n    this.serializedAbortReason = error\n\n    this.connection?.destroy(error)\n    this.emit('terminated', error)\n  }\n}\n\nfunction handleFetchDone (response) {\n  finalizeAndReportTiming(response, 'fetch')\n}\n\n// https://fetch.spec.whatwg.org/#fetch-method\nfunction fetch (input, init = undefined) {\n  webidl.argumentLengthCheck(arguments, 1, 'globalThis.fetch')\n\n  // 1. Let p be a new promise.\n  let p = createDeferredPromise()\n\n  // 2. Let requestObject be the result of invoking the initial value of\n  // Request as constructor with input and init as arguments. If this throws\n  // an exception, reject p with it and return p.\n  let requestObject\n\n  try {\n    requestObject = new Request(input, init)\n  } catch (e) {\n    p.reject(e)\n    return p.promise\n  }\n\n  // 3. Let request be requestObject’s request.\n  const request = requestObject[kState]\n\n  // 4. If requestObject’s signal’s aborted flag is set, then:\n  if (requestObject.signal.aborted) {\n    // 1. Abort the fetch() call with p, request, null, and\n    //    requestObject’s signal’s abort reason.\n    abortFetch(p, request, null, requestObject.signal.reason)\n\n    // 2. Return p.\n    return p.promise\n  }\n\n  // 5. Let globalObject be request’s client’s global object.\n  const globalObject = request.client.globalObject\n\n  // 6. If globalObject is a ServiceWorkerGlobalScope object, then set\n  // request’s service-workers mode to \"none\".\n  if (globalObject?.constructor?.name === 'ServiceWorkerGlobalScope') {\n    request.serviceWorkers = 'none'\n  }\n\n  // 7. Let responseObject be null.\n  let responseObject = null\n\n  // 8. Let relevantRealm be this’s relevant Realm.\n\n  // 9. Let locallyAborted be false.\n  let locallyAborted = false\n\n  // 10. Let controller be null.\n  let controller = null\n\n  // 11. Add the following abort steps to requestObject’s signal:\n  addAbortListener(\n    requestObject.signal,\n    () => {\n      // 1. Set locallyAborted to true.\n      locallyAborted = true\n\n      // 2. Assert: controller is non-null.\n      assert(controller != null)\n\n      // 3. Abort controller with requestObject’s signal’s abort reason.\n      controller.abort(requestObject.signal.reason)\n\n      const realResponse = responseObject?.deref()\n\n      // 4. Abort the fetch() call with p, request, responseObject,\n      //    and requestObject’s signal’s abort reason.\n      abortFetch(p, request, realResponse, requestObject.signal.reason)\n    }\n  )\n\n  // 12. Let handleFetchDone given response response be to finalize and\n  // report timing with response, globalObject, and \"fetch\".\n  // see function handleFetchDone\n\n  // 13. Set controller to the result of calling fetch given request,\n  // with processResponseEndOfBody set to handleFetchDone, and processResponse\n  // given response being these substeps:\n\n  const processResponse = (response) => {\n    // 1. If locallyAborted is true, terminate these substeps.\n    if (locallyAborted) {\n      return\n    }\n\n    // 2. If response’s aborted flag is set, then:\n    if (response.aborted) {\n      // 1. Let deserializedError be the result of deserialize a serialized\n      //    abort reason given controller’s serialized abort reason and\n      //    relevantRealm.\n\n      // 2. Abort the fetch() call with p, request, responseObject, and\n      //    deserializedError.\n\n      abortFetch(p, request, responseObject, controller.serializedAbortReason)\n      return\n    }\n\n    // 3. If response is a network error, then reject p with a TypeError\n    // and terminate these substeps.\n    if (response.type === 'error') {\n      p.reject(new TypeError('fetch failed', { cause: response.error }))\n      return\n    }\n\n    // 4. Set responseObject to the result of creating a Response object,\n    // given response, \"immutable\", and relevantRealm.\n    responseObject = new WeakRef(fromInnerResponse(response, 'immutable'))\n\n    // 5. Resolve p with responseObject.\n    p.resolve(responseObject.deref())\n    p = null\n  }\n\n  controller = fetching({\n    request,\n    processResponseEndOfBody: handleFetchDone,\n    processResponse,\n    dispatcher: requestObject[kDispatcher] // undici\n  })\n\n  // 14. Return p.\n  return p.promise\n}\n\n// https://fetch.spec.whatwg.org/#finalize-and-report-timing\nfunction finalizeAndReportTiming (response, initiatorType = 'other') {\n  // 1. If response is an aborted network error, then return.\n  if (response.type === 'error' && response.aborted) {\n    return\n  }\n\n  // 2. If response’s URL list is null or empty, then return.\n  if (!response.urlList?.length) {\n    return\n  }\n\n  // 3. Let originalURL be response’s URL list[0].\n  const originalURL = response.urlList[0]\n\n  // 4. Let timingInfo be response’s timing info.\n  let timingInfo = response.timingInfo\n\n  // 5. Let cacheState be response’s cache state.\n  let cacheState = response.cacheState\n\n  // 6. If originalURL’s scheme is not an HTTP(S) scheme, then return.\n  if (!urlIsHttpHttpsScheme(originalURL)) {\n    return\n  }\n\n  // 7. If timingInfo is null, then return.\n  if (timingInfo === null) {\n    return\n  }\n\n  // 8. If response’s timing allow passed flag is not set, then:\n  if (!response.timingAllowPassed) {\n    //  1. Set timingInfo to a the result of creating an opaque timing info for timingInfo.\n    timingInfo = createOpaqueTimingInfo({\n      startTime: timingInfo.startTime\n    })\n\n    //  2. Set cacheState to the empty string.\n    cacheState = ''\n  }\n\n  // 9. Set timingInfo’s end time to the coarsened shared current time\n  // given global’s relevant settings object’s cross-origin isolated\n  // capability.\n  // TODO: given global’s relevant settings object’s cross-origin isolated\n  // capability?\n  timingInfo.endTime = coarsenedSharedCurrentTime()\n\n  // 10. Set response’s timing info to timingInfo.\n  response.timingInfo = timingInfo\n\n  // 11. Mark resource timing for timingInfo, originalURL, initiatorType,\n  // global, and cacheState.\n  markResourceTiming(\n    timingInfo,\n    originalURL.href,\n    initiatorType,\n    globalThis,\n    cacheState\n  )\n}\n\n// https://w3c.github.io/resource-timing/#dfn-mark-resource-timing\nconst markResourceTiming = performance.markResourceTiming\n\n// https://fetch.spec.whatwg.org/#abort-fetch\nfunction abortFetch (p, request, responseObject, error) {\n  // 1. Reject promise with error.\n  if (p) {\n    // We might have already resolved the promise at this stage\n    p.reject(error)\n  }\n\n  // 2. If request’s body is not null and is readable, then cancel request’s\n  // body with error.\n  if (request.body != null && isReadable(request.body?.stream)) {\n    request.body.stream.cancel(error).catch((err) => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return\n      }\n      throw err\n    })\n  }\n\n  // 3. If responseObject is null, then return.\n  if (responseObject == null) {\n    return\n  }\n\n  // 4. Let response be responseObject’s response.\n  const response = responseObject[kState]\n\n  // 5. If response’s body is not null and is readable, then error response’s\n  // body with error.\n  if (response.body != null && isReadable(response.body?.stream)) {\n    response.body.stream.cancel(error).catch((err) => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return\n      }\n      throw err\n    })\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetching\nfunction fetching ({\n  request,\n  processRequestBodyChunkLength,\n  processRequestEndOfBody,\n  processResponse,\n  processResponseEndOfBody,\n  processResponseConsumeBody,\n  useParallelQueue = false,\n  dispatcher = getGlobalDispatcher() // undici\n}) {\n  // Ensure that the dispatcher is set accordingly\n  assert(dispatcher)\n\n  // 1. Let taskDestination be null.\n  let taskDestination = null\n\n  // 2. Let crossOriginIsolatedCapability be false.\n  let crossOriginIsolatedCapability = false\n\n  // 3. If request’s client is non-null, then:\n  if (request.client != null) {\n    // 1. Set taskDestination to request’s client’s global object.\n    taskDestination = request.client.globalObject\n\n    // 2. Set crossOriginIsolatedCapability to request’s client’s cross-origin\n    // isolated capability.\n    crossOriginIsolatedCapability =\n      request.client.crossOriginIsolatedCapability\n  }\n\n  // 4. If useParallelQueue is true, then set taskDestination to the result of\n  // starting a new parallel queue.\n  // TODO\n\n  // 5. Let timingInfo be a new fetch timing info whose start time and\n  // post-redirect start time are the coarsened shared current time given\n  // crossOriginIsolatedCapability.\n  const currentTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability)\n  const timingInfo = createOpaqueTimingInfo({\n    startTime: currentTime\n  })\n\n  // 6. Let fetchParams be a new fetch params whose\n  // request is request,\n  // timing info is timingInfo,\n  // process request body chunk length is processRequestBodyChunkLength,\n  // process request end-of-body is processRequestEndOfBody,\n  // process response is processResponse,\n  // process response consume body is processResponseConsumeBody,\n  // process response end-of-body is processResponseEndOfBody,\n  // task destination is taskDestination,\n  // and cross-origin isolated capability is crossOriginIsolatedCapability.\n  const fetchParams = {\n    controller: new Fetch(dispatcher),\n    request,\n    timingInfo,\n    processRequestBodyChunkLength,\n    processRequestEndOfBody,\n    processResponse,\n    processResponseConsumeBody,\n    processResponseEndOfBody,\n    taskDestination,\n    crossOriginIsolatedCapability\n  }\n\n  // 7. If request’s body is a byte sequence, then set request’s body to\n  //    request’s body as a body.\n  // NOTE: Since fetching is only called from fetch, body should already be\n  // extracted.\n  assert(!request.body || request.body.stream)\n\n  // 8. If request’s window is \"client\", then set request’s window to request’s\n  // client, if request’s client’s global object is a Window object; otherwise\n  // \"no-window\".\n  if (request.window === 'client') {\n    // TODO: What if request.client is null?\n    request.window =\n      request.client?.globalObject?.constructor?.name === 'Window'\n        ? request.client\n        : 'no-window'\n  }\n\n  // 9. If request’s origin is \"client\", then set request’s origin to request’s\n  // client’s origin.\n  if (request.origin === 'client') {\n    request.origin = request.client.origin\n  }\n\n  // 10. If all of the following conditions are true:\n  // TODO\n\n  // 11. If request’s policy container is \"client\", then:\n  if (request.policyContainer === 'client') {\n    // 1. If request’s client is non-null, then set request’s policy\n    // container to a clone of request’s client’s policy container. [HTML]\n    if (request.client != null) {\n      request.policyContainer = clonePolicyContainer(\n        request.client.policyContainer\n      )\n    } else {\n      // 2. Otherwise, set request’s policy container to a new policy\n      // container.\n      request.policyContainer = makePolicyContainer()\n    }\n  }\n\n  // 12. If request’s header list does not contain `Accept`, then:\n  if (!request.headersList.contains('accept', true)) {\n    // 1. Let value be `*/*`.\n    const value = '*/*'\n\n    // 2. A user agent should set value to the first matching statement, if\n    // any, switching on request’s destination:\n    // \"document\"\n    // \"frame\"\n    // \"iframe\"\n    // `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`\n    // \"image\"\n    // `image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5`\n    // \"style\"\n    // `text/css,*/*;q=0.1`\n    // TODO\n\n    // 3. Append `Accept`/value to request’s header list.\n    request.headersList.append('accept', value, true)\n  }\n\n  // 13. If request’s header list does not contain `Accept-Language`, then\n  // user agents should append `Accept-Language`/an appropriate value to\n  // request’s header list.\n  if (!request.headersList.contains('accept-language', true)) {\n    request.headersList.append('accept-language', '*', true)\n  }\n\n  // 14. If request’s priority is null, then use request’s initiator and\n  // destination appropriately in setting request’s priority to a\n  // user-agent-defined object.\n  if (request.priority === null) {\n    // TODO\n  }\n\n  // 15. If request is a subresource request, then:\n  if (subresourceSet.has(request.destination)) {\n    // TODO\n  }\n\n  // 16. Run main fetch given fetchParams.\n  mainFetch(fetchParams)\n    .catch(err => {\n      fetchParams.controller.terminate(err)\n    })\n\n  // 17. Return fetchParam's controller\n  return fetchParams.controller\n}\n\n// https://fetch.spec.whatwg.org/#concept-main-fetch\nasync function mainFetch (fetchParams, recursive = false) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. If request’s local-URLs-only flag is set and request’s current URL is\n  // not local, then set response to a network error.\n  if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {\n    response = makeNetworkError('local URLs only')\n  }\n\n  // 4. Run report Content Security Policy violations for request.\n  // TODO\n\n  // 5. Upgrade request to a potentially trustworthy URL, if appropriate.\n  tryUpgradeRequestToAPotentiallyTrustworthyURL(request)\n\n  // 6. If should request be blocked due to a bad port, should fetching request\n  // be blocked as mixed content, or should request be blocked by Content\n  // Security Policy returns blocked, then set response to a network error.\n  if (requestBadPort(request) === 'blocked') {\n    response = makeNetworkError('bad port')\n  }\n  // TODO: should fetching request be blocked as mixed content?\n  // TODO: should request be blocked by Content Security Policy?\n\n  // 7. If request’s referrer policy is the empty string, then set request’s\n  // referrer policy to request’s policy container’s referrer policy.\n  if (request.referrerPolicy === '') {\n    request.referrerPolicy = request.policyContainer.referrerPolicy\n  }\n\n  // 8. If request’s referrer is not \"no-referrer\", then set request’s\n  // referrer to the result of invoking determine request’s referrer.\n  if (request.referrer !== 'no-referrer') {\n    request.referrer = determineRequestsReferrer(request)\n  }\n\n  // 9. Set request’s current URL’s scheme to \"https\" if all of the following\n  // conditions are true:\n  // - request’s current URL’s scheme is \"http\"\n  // - request’s current URL’s host is a domain\n  // - Matching request’s current URL’s host per Known HSTS Host Domain Name\n  //   Matching results in either a superdomain match with an asserted\n  //   includeSubDomains directive or a congruent match (with or without an\n  //   asserted includeSubDomains directive). [HSTS]\n  // TODO\n\n  // 10. If recursive is false, then run the remaining steps in parallel.\n  // TODO\n\n  // 11. If response is null, then set response to the result of running\n  // the steps corresponding to the first matching statement:\n  if (response === null) {\n    response = await (async () => {\n      const currentURL = requestCurrentURL(request)\n\n      if (\n        // - request’s current URL’s origin is same origin with request’s origin,\n        //   and request’s response tainting is \"basic\"\n        (sameOrigin(currentURL, request.url) && request.responseTainting === 'basic') ||\n        // request’s current URL’s scheme is \"data\"\n        (currentURL.protocol === 'data:') ||\n        // - request’s mode is \"navigate\" or \"websocket\"\n        (request.mode === 'navigate' || request.mode === 'websocket')\n      ) {\n        // 1. Set request’s response tainting to \"basic\".\n        request.responseTainting = 'basic'\n\n        // 2. Return the result of running scheme fetch given fetchParams.\n        return await schemeFetch(fetchParams)\n      }\n\n      // request’s mode is \"same-origin\"\n      if (request.mode === 'same-origin') {\n        // 1. Return a network error.\n        return makeNetworkError('request mode cannot be \"same-origin\"')\n      }\n\n      // request’s mode is \"no-cors\"\n      if (request.mode === 'no-cors') {\n        // 1. If request’s redirect mode is not \"follow\", then return a network\n        // error.\n        if (request.redirect !== 'follow') {\n          return makeNetworkError(\n            'redirect mode cannot be \"follow\" for \"no-cors\" request'\n          )\n        }\n\n        // 2. Set request’s response tainting to \"opaque\".\n        request.responseTainting = 'opaque'\n\n        // 3. Return the result of running scheme fetch given fetchParams.\n        return await schemeFetch(fetchParams)\n      }\n\n      // request’s current URL’s scheme is not an HTTP(S) scheme\n      if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {\n        // Return a network error.\n        return makeNetworkError('URL scheme must be a HTTP(S) scheme')\n      }\n\n      // - request’s use-CORS-preflight flag is set\n      // - request’s unsafe-request flag is set and either request’s method is\n      //   not a CORS-safelisted method or CORS-unsafe request-header names with\n      //   request’s header list is not empty\n      //    1. Set request’s response tainting to \"cors\".\n      //    2. Let corsWithPreflightResponse be the result of running HTTP fetch\n      //    given fetchParams and true.\n      //    3. If corsWithPreflightResponse is a network error, then clear cache\n      //    entries using request.\n      //    4. Return corsWithPreflightResponse.\n      // TODO\n\n      // Otherwise\n      //    1. Set request’s response tainting to \"cors\".\n      request.responseTainting = 'cors'\n\n      //    2. Return the result of running HTTP fetch given fetchParams.\n      return await httpFetch(fetchParams)\n    })()\n  }\n\n  // 12. If recursive is true, then return response.\n  if (recursive) {\n    return response\n  }\n\n  // 13. If response is not a network error and response is not a filtered\n  // response, then:\n  if (response.status !== 0 && !response.internalResponse) {\n    // If request’s response tainting is \"cors\", then:\n    if (request.responseTainting === 'cors') {\n      // 1. Let headerNames be the result of extracting header list values\n      // given `Access-Control-Expose-Headers` and response’s header list.\n      // TODO\n      // 2. If request’s credentials mode is not \"include\" and headerNames\n      // contains `*`, then set response’s CORS-exposed header-name list to\n      // all unique header names in response’s header list.\n      // TODO\n      // 3. Otherwise, if headerNames is not null or failure, then set\n      // response’s CORS-exposed header-name list to headerNames.\n      // TODO\n    }\n\n    // Set response to the following filtered response with response as its\n    // internal response, depending on request’s response tainting:\n    if (request.responseTainting === 'basic') {\n      response = filterResponse(response, 'basic')\n    } else if (request.responseTainting === 'cors') {\n      response = filterResponse(response, 'cors')\n    } else if (request.responseTainting === 'opaque') {\n      response = filterResponse(response, 'opaque')\n    } else {\n      assert(false)\n    }\n  }\n\n  // 14. Let internalResponse be response, if response is a network error,\n  // and response’s internal response otherwise.\n  let internalResponse =\n    response.status === 0 ? response : response.internalResponse\n\n  // 15. If internalResponse’s URL list is empty, then set it to a clone of\n  // request’s URL list.\n  if (internalResponse.urlList.length === 0) {\n    internalResponse.urlList.push(...request.urlList)\n  }\n\n  // 16. If request’s timing allow failed flag is unset, then set\n  // internalResponse’s timing allow passed flag.\n  if (!request.timingAllowFailed) {\n    response.timingAllowPassed = true\n  }\n\n  // 17. If response is not a network error and any of the following returns\n  // blocked\n  // - should internalResponse to request be blocked as mixed content\n  // - should internalResponse to request be blocked by Content Security Policy\n  // - should internalResponse to request be blocked due to its MIME type\n  // - should internalResponse to request be blocked due to nosniff\n  // TODO\n\n  // 18. If response’s type is \"opaque\", internalResponse’s status is 206,\n  // internalResponse’s range-requested flag is set, and request’s header\n  // list does not contain `Range`, then set response and internalResponse\n  // to a network error.\n  if (\n    response.type === 'opaque' &&\n    internalResponse.status === 206 &&\n    internalResponse.rangeRequested &&\n    !request.headers.contains('range', true)\n  ) {\n    response = internalResponse = makeNetworkError()\n  }\n\n  // 19. If response is not a network error and either request’s method is\n  // `HEAD` or `CONNECT`, or internalResponse’s status is a null body status,\n  // set internalResponse’s body to null and disregard any enqueuing toward\n  // it (if any).\n  if (\n    response.status !== 0 &&\n    (request.method === 'HEAD' ||\n      request.method === 'CONNECT' ||\n      nullBodyStatus.includes(internalResponse.status))\n  ) {\n    internalResponse.body = null\n    fetchParams.controller.dump = true\n  }\n\n  // 20. If request’s integrity metadata is not the empty string, then:\n  if (request.integrity) {\n    // 1. Let processBodyError be this step: run fetch finale given fetchParams\n    // and a network error.\n    const processBodyError = (reason) =>\n      fetchFinale(fetchParams, makeNetworkError(reason))\n\n    // 2. If request’s response tainting is \"opaque\", or response’s body is null,\n    // then run processBodyError and abort these steps.\n    if (request.responseTainting === 'opaque' || response.body == null) {\n      processBodyError(response.error)\n      return\n    }\n\n    // 3. Let processBody given bytes be these steps:\n    const processBody = (bytes) => {\n      // 1. If bytes do not match request’s integrity metadata,\n      // then run processBodyError and abort these steps. [SRI]\n      if (!bytesMatch(bytes, request.integrity)) {\n        processBodyError('integrity mismatch')\n        return\n      }\n\n      // 2. Set response’s body to bytes as a body.\n      response.body = safelyExtractBody(bytes)[0]\n\n      // 3. Run fetch finale given fetchParams and response.\n      fetchFinale(fetchParams, response)\n    }\n\n    // 4. Fully read response’s body given processBody and processBodyError.\n    await fullyReadBody(response.body, processBody, processBodyError)\n  } else {\n    // 21. Otherwise, run fetch finale given fetchParams and response.\n    fetchFinale(fetchParams, response)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#concept-scheme-fetch\n// given a fetch params fetchParams\nfunction schemeFetch (fetchParams) {\n  // Note: since the connection is destroyed on redirect, which sets fetchParams to a\n  // cancelled state, we do not want this condition to trigger *unless* there have been\n  // no redirects. See https://github.com/nodejs/undici/issues/1776\n  // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n  if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {\n    return Promise.resolve(makeAppropriateNetworkError(fetchParams))\n  }\n\n  // 2. Let request be fetchParams’s request.\n  const { request } = fetchParams\n\n  const { protocol: scheme } = requestCurrentURL(request)\n\n  // 3. Switch on request’s current URL’s scheme and run the associated steps:\n  switch (scheme) {\n    case 'about:': {\n      // If request’s current URL’s path is the string \"blank\", then return a new response\n      // whose status message is `OK`, header list is « (`Content-Type`, `text/html;charset=utf-8`) »,\n      // and body is the empty byte sequence as a body.\n\n      // Otherwise, return a network error.\n      return Promise.resolve(makeNetworkError('about scheme is not supported'))\n    }\n    case 'blob:': {\n      if (!resolveObjectURL) {\n        resolveObjectURL = require('node:buffer').resolveObjectURL\n      }\n\n      // 1. Let blobURLEntry be request’s current URL’s blob URL entry.\n      const blobURLEntry = requestCurrentURL(request)\n\n      // https://github.com/web-platform-tests/wpt/blob/7b0ebaccc62b566a1965396e5be7bb2bc06f841f/FileAPI/url/resources/fetch-tests.js#L52-L56\n      // Buffer.resolveObjectURL does not ignore URL queries.\n      if (blobURLEntry.search.length !== 0) {\n        return Promise.resolve(makeNetworkError('NetworkError when attempting to fetch resource.'))\n      }\n\n      const blob = resolveObjectURL(blobURLEntry.toString())\n\n      // 2. If request’s method is not `GET`, blobURLEntry is null, or blobURLEntry’s\n      //    object is not a Blob object, then return a network error.\n      if (request.method !== 'GET' || !isBlobLike(blob)) {\n        return Promise.resolve(makeNetworkError('invalid method'))\n      }\n\n      // 3. Let blob be blobURLEntry’s object.\n      // Note: done above\n\n      // 4. Let response be a new response.\n      const response = makeResponse()\n\n      // 5. Let fullLength be blob’s size.\n      const fullLength = blob.size\n\n      // 6. Let serializedFullLength be fullLength, serialized and isomorphic encoded.\n      const serializedFullLength = isomorphicEncode(`${fullLength}`)\n\n      // 7. Let type be blob’s type.\n      const type = blob.type\n\n      // 8. If request’s header list does not contain `Range`:\n      // 9. Otherwise:\n      if (!request.headersList.contains('range', true)) {\n        // 1. Let bodyWithType be the result of safely extracting blob.\n        // Note: in the FileAPI a blob \"object\" is a Blob *or* a MediaSource.\n        // In node, this can only ever be a Blob. Therefore we can safely\n        // use extractBody directly.\n        const bodyWithType = extractBody(blob)\n\n        // 2. Set response’s status message to `OK`.\n        response.statusText = 'OK'\n\n        // 3. Set response’s body to bodyWithType’s body.\n        response.body = bodyWithType[0]\n\n        // 4. Set response’s header list to « (`Content-Length`, serializedFullLength), (`Content-Type`, type) ».\n        response.headersList.set('content-length', serializedFullLength, true)\n        response.headersList.set('content-type', type, true)\n      } else {\n        // 1. Set response’s range-requested flag.\n        response.rangeRequested = true\n\n        // 2. Let rangeHeader be the result of getting `Range` from request’s header list.\n        const rangeHeader = request.headersList.get('range', true)\n\n        // 3. Let rangeValue be the result of parsing a single range header value given rangeHeader and true.\n        const rangeValue = simpleRangeHeaderValue(rangeHeader, true)\n\n        // 4. If rangeValue is failure, then return a network error.\n        if (rangeValue === 'failure') {\n          return Promise.resolve(makeNetworkError('failed to fetch the data URL'))\n        }\n\n        // 5. Let (rangeStart, rangeEnd) be rangeValue.\n        let { rangeStartValue: rangeStart, rangeEndValue: rangeEnd } = rangeValue\n\n        // 6. If rangeStart is null:\n        // 7. Otherwise:\n        if (rangeStart === null) {\n          // 1. Set rangeStart to fullLength − rangeEnd.\n          rangeStart = fullLength - rangeEnd\n\n          // 2. Set rangeEnd to rangeStart + rangeEnd − 1.\n          rangeEnd = rangeStart + rangeEnd - 1\n        } else {\n          // 1. If rangeStart is greater than or equal to fullLength, then return a network error.\n          if (rangeStart >= fullLength) {\n            return Promise.resolve(makeNetworkError('Range start is greater than the blob\\'s size.'))\n          }\n\n          // 2. If rangeEnd is null or rangeEnd is greater than or equal to fullLength, then set\n          //    rangeEnd to fullLength − 1.\n          if (rangeEnd === null || rangeEnd >= fullLength) {\n            rangeEnd = fullLength - 1\n          }\n        }\n\n        // 8. Let slicedBlob be the result of invoking slice blob given blob, rangeStart,\n        //    rangeEnd + 1, and type.\n        const slicedBlob = blob.slice(rangeStart, rangeEnd, type)\n\n        // 9. Let slicedBodyWithType be the result of safely extracting slicedBlob.\n        // Note: same reason as mentioned above as to why we use extractBody\n        const slicedBodyWithType = extractBody(slicedBlob)\n\n        // 10. Set response’s body to slicedBodyWithType’s body.\n        response.body = slicedBodyWithType[0]\n\n        // 11. Let serializedSlicedLength be slicedBlob’s size, serialized and isomorphic encoded.\n        const serializedSlicedLength = isomorphicEncode(`${slicedBlob.size}`)\n\n        // 12. Let contentRange be the result of invoking build a content range given rangeStart,\n        //     rangeEnd, and fullLength.\n        const contentRange = buildContentRange(rangeStart, rangeEnd, fullLength)\n\n        // 13. Set response’s status to 206.\n        response.status = 206\n\n        // 14. Set response’s status message to `Partial Content`.\n        response.statusText = 'Partial Content'\n\n        // 15. Set response’s header list to « (`Content-Length`, serializedSlicedLength),\n        //     (`Content-Type`, type), (`Content-Range`, contentRange) ».\n        response.headersList.set('content-length', serializedSlicedLength, true)\n        response.headersList.set('content-type', type, true)\n        response.headersList.set('content-range', contentRange, true)\n      }\n\n      // 10. Return response.\n      return Promise.resolve(response)\n    }\n    case 'data:': {\n      // 1. Let dataURLStruct be the result of running the\n      //    data: URL processor on request’s current URL.\n      const currentURL = requestCurrentURL(request)\n      const dataURLStruct = dataURLProcessor(currentURL)\n\n      // 2. If dataURLStruct is failure, then return a\n      //    network error.\n      if (dataURLStruct === 'failure') {\n        return Promise.resolve(makeNetworkError('failed to fetch the data URL'))\n      }\n\n      // 3. Let mimeType be dataURLStruct’s MIME type, serialized.\n      const mimeType = serializeAMimeType(dataURLStruct.mimeType)\n\n      // 4. Return a response whose status message is `OK`,\n      //    header list is « (`Content-Type`, mimeType) »,\n      //    and body is dataURLStruct’s body as a body.\n      return Promise.resolve(makeResponse({\n        statusText: 'OK',\n        headersList: [\n          ['content-type', { name: 'Content-Type', value: mimeType }]\n        ],\n        body: safelyExtractBody(dataURLStruct.body)[0]\n      }))\n    }\n    case 'file:': {\n      // For now, unfortunate as it is, file URLs are left as an exercise for the reader.\n      // When in doubt, return a network error.\n      return Promise.resolve(makeNetworkError('not implemented... yet...'))\n    }\n    case 'http:':\n    case 'https:': {\n      // Return the result of running HTTP fetch given fetchParams.\n\n      return httpFetch(fetchParams)\n        .catch((err) => makeNetworkError(err))\n    }\n    default: {\n      return Promise.resolve(makeNetworkError('unknown scheme'))\n    }\n  }\n}\n\n// https://fetch.spec.whatwg.org/#finalize-response\nfunction finalizeResponse (fetchParams, response) {\n  // 1. Set fetchParams’s request’s done flag.\n  fetchParams.request.done = true\n\n  // 2, If fetchParams’s process response done is not null, then queue a fetch\n  // task to run fetchParams’s process response done given response, with\n  // fetchParams’s task destination.\n  if (fetchParams.processResponseDone != null) {\n    queueMicrotask(() => fetchParams.processResponseDone(response))\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetch-finale\nfunction fetchFinale (fetchParams, response) {\n  // 1. Let timingInfo be fetchParams’s timing info.\n  let timingInfo = fetchParams.timingInfo\n\n  // 2. If response is not a network error and fetchParams’s request’s client is a secure context,\n  //    then set timingInfo’s server-timing headers to the result of getting, decoding, and splitting\n  //    `Server-Timing` from response’s internal response’s header list.\n  // TODO\n\n  // 3. Let processResponseEndOfBody be the following steps:\n  const processResponseEndOfBody = () => {\n    // 1. Let unsafeEndTime be the unsafe shared current time.\n    const unsafeEndTime = Date.now() // ?\n\n    // 2. If fetchParams’s request’s destination is \"document\", then set fetchParams’s controller’s\n    //    full timing info to fetchParams’s timing info.\n    if (fetchParams.request.destination === 'document') {\n      fetchParams.controller.fullTimingInfo = timingInfo\n    }\n\n    // 3. Set fetchParams’s controller’s report timing steps to the following steps given a global object global:\n    fetchParams.controller.reportTimingSteps = () => {\n      // 1. If fetchParams’s request’s URL’s scheme is not an HTTP(S) scheme, then return.\n      if (fetchParams.request.url.protocol !== 'https:') {\n        return\n      }\n\n      // 2. Set timingInfo’s end time to the relative high resolution time given unsafeEndTime and global.\n      timingInfo.endTime = unsafeEndTime\n\n      // 3. Let cacheState be response’s cache state.\n      let cacheState = response.cacheState\n\n      // 4. Let bodyInfo be response’s body info.\n      const bodyInfo = response.bodyInfo\n\n      // 5. If response’s timing allow passed flag is not set, then set timingInfo to the result of creating an\n      //    opaque timing info for timingInfo and set cacheState to the empty string.\n      if (!response.timingAllowPassed) {\n        timingInfo = createOpaqueTimingInfo(timingInfo)\n\n        cacheState = ''\n      }\n\n      // 6. Let responseStatus be 0.\n      let responseStatus = 0\n\n      // 7. If fetchParams’s request’s mode is not \"navigate\" or response’s has-cross-origin-redirects is false:\n      if (fetchParams.request.mode !== 'navigator' || !response.hasCrossOriginRedirects) {\n        // 1. Set responseStatus to response’s status.\n        responseStatus = response.status\n\n        // 2. Let mimeType be the result of extracting a MIME type from response’s header list.\n        const mimeType = extractMimeType(response.headersList)\n\n        // 3. If mimeType is not failure, then set bodyInfo’s content type to the result of minimizing a supported MIME type given mimeType.\n        if (mimeType !== 'failure') {\n          bodyInfo.contentType = minimizeSupportedMimeType(mimeType)\n        }\n      }\n\n      // 8. If fetchParams’s request’s initiator type is non-null, then mark resource timing given timingInfo,\n      //    fetchParams’s request’s URL, fetchParams’s request’s initiator type, global, cacheState, bodyInfo,\n      //    and responseStatus.\n      if (fetchParams.request.initiatorType != null) {\n        // TODO: update markresourcetiming\n        markResourceTiming(timingInfo, fetchParams.request.url.href, fetchParams.request.initiatorType, globalThis, cacheState, bodyInfo, responseStatus)\n      }\n    }\n\n    // 4. Let processResponseEndOfBodyTask be the following steps:\n    const processResponseEndOfBodyTask = () => {\n      // 1. Set fetchParams’s request’s done flag.\n      fetchParams.request.done = true\n\n      // 2. If fetchParams’s process response end-of-body is non-null, then run fetchParams’s process\n      //    response end-of-body given response.\n      if (fetchParams.processResponseEndOfBody != null) {\n        queueMicrotask(() => fetchParams.processResponseEndOfBody(response))\n      }\n\n      // 3. If fetchParams’s request’s initiator type is non-null and fetchParams’s request’s client’s\n      //    global object is fetchParams’s task destination, then run fetchParams’s controller’s report\n      //    timing steps given fetchParams’s request’s client’s global object.\n      if (fetchParams.request.initiatorType != null) {\n        fetchParams.controller.reportTimingSteps()\n      }\n    }\n\n    // 5. Queue a fetch task to run processResponseEndOfBodyTask with fetchParams’s task destination\n    queueMicrotask(() => processResponseEndOfBodyTask())\n  }\n\n  // 4. If fetchParams’s process response is non-null, then queue a fetch task to run fetchParams’s\n  //    process response given response, with fetchParams’s task destination.\n  if (fetchParams.processResponse != null) {\n    queueMicrotask(() => {\n      fetchParams.processResponse(response)\n      fetchParams.processResponse = null\n    })\n  }\n\n  // 5. Let internalResponse be response, if response is a network error; otherwise response’s internal response.\n  const internalResponse = response.type === 'error' ? response : (response.internalResponse ?? response)\n\n  // 6. If internalResponse’s body is null, then run processResponseEndOfBody.\n  // 7. Otherwise:\n  if (internalResponse.body == null) {\n    processResponseEndOfBody()\n  } else {\n    // mcollina: all the following steps of the specs are skipped.\n    // The internal transform stream is not needed.\n    // See https://github.com/nodejs/undici/pull/3093#issuecomment-2050198541\n\n    // 1. Let transformStream be a new TransformStream.\n    // 2. Let identityTransformAlgorithm be an algorithm which, given chunk, enqueues chunk in transformStream.\n    // 3. Set up transformStream with transformAlgorithm set to identityTransformAlgorithm and flushAlgorithm\n    //    set to processResponseEndOfBody.\n    // 4. Set internalResponse’s body’s stream to the result of internalResponse’s body’s stream piped through transformStream.\n\n    finished(internalResponse.body.stream, () => {\n      processResponseEndOfBody()\n    })\n  }\n}\n\n// https://fetch.spec.whatwg.org/#http-fetch\nasync function httpFetch (fetchParams) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. Let actualResponse be null.\n  let actualResponse = null\n\n  // 4. Let timingInfo be fetchParams’s timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 5. If request’s service-workers mode is \"all\", then:\n  if (request.serviceWorkers === 'all') {\n    // TODO\n  }\n\n  // 6. If response is null, then:\n  if (response === null) {\n    // 1. If makeCORSPreflight is true and one of these conditions is true:\n    // TODO\n\n    // 2. If request’s redirect mode is \"follow\", then set request’s\n    // service-workers mode to \"none\".\n    if (request.redirect === 'follow') {\n      request.serviceWorkers = 'none'\n    }\n\n    // 3. Set response and actualResponse to the result of running\n    // HTTP-network-or-cache fetch given fetchParams.\n    actualResponse = response = await httpNetworkOrCacheFetch(fetchParams)\n\n    // 4. If request’s response tainting is \"cors\" and a CORS check\n    // for request and response returns failure, then return a network error.\n    if (\n      request.responseTainting === 'cors' &&\n      corsCheck(request, response) === 'failure'\n    ) {\n      return makeNetworkError('cors failure')\n    }\n\n    // 5. If the TAO check for request and response returns failure, then set\n    // request’s timing allow failed flag.\n    if (TAOCheck(request, response) === 'failure') {\n      request.timingAllowFailed = true\n    }\n  }\n\n  // 7. If either request’s response tainting or response’s type\n  // is \"opaque\", and the cross-origin resource policy check with\n  // request’s origin, request’s client, request’s destination,\n  // and actualResponse returns blocked, then return a network error.\n  if (\n    (request.responseTainting === 'opaque' || response.type === 'opaque') &&\n    crossOriginResourcePolicyCheck(\n      request.origin,\n      request.client,\n      request.destination,\n      actualResponse\n    ) === 'blocked'\n  ) {\n    return makeNetworkError('blocked')\n  }\n\n  // 8. If actualResponse’s status is a redirect status, then:\n  if (redirectStatusSet.has(actualResponse.status)) {\n    // 1. If actualResponse’s status is not 303, request’s body is not null,\n    // and the connection uses HTTP/2, then user agents may, and are even\n    // encouraged to, transmit an RST_STREAM frame.\n    // See, https://github.com/whatwg/fetch/issues/1288\n    if (request.redirect !== 'manual') {\n      fetchParams.controller.connection.destroy(undefined, false)\n    }\n\n    // 2. Switch on request’s redirect mode:\n    if (request.redirect === 'error') {\n      // Set response to a network error.\n      response = makeNetworkError('unexpected redirect')\n    } else if (request.redirect === 'manual') {\n      // Set response to an opaque-redirect filtered response whose internal\n      // response is actualResponse.\n      // NOTE(spec): On the web this would return an `opaqueredirect` response,\n      // but that doesn't make sense server side.\n      // See https://github.com/nodejs/undici/issues/1193.\n      response = actualResponse\n    } else if (request.redirect === 'follow') {\n      // Set response to the result of running HTTP-redirect fetch given\n      // fetchParams and response.\n      response = await httpRedirectFetch(fetchParams, response)\n    } else {\n      assert(false)\n    }\n  }\n\n  // 9. Set response’s timing info to timingInfo.\n  response.timingInfo = timingInfo\n\n  // 10. Return response.\n  return response\n}\n\n// https://fetch.spec.whatwg.org/#http-redirect-fetch\nfunction httpRedirectFetch (fetchParams, response) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let actualResponse be response, if response is not a filtered response,\n  // and response’s internal response otherwise.\n  const actualResponse = response.internalResponse\n    ? response.internalResponse\n    : response\n\n  // 3. Let locationURL be actualResponse’s location URL given request’s current\n  // URL’s fragment.\n  let locationURL\n\n  try {\n    locationURL = responseLocationURL(\n      actualResponse,\n      requestCurrentURL(request).hash\n    )\n\n    // 4. If locationURL is null, then return response.\n    if (locationURL == null) {\n      return response\n    }\n  } catch (err) {\n    // 5. If locationURL is failure, then return a network error.\n    return Promise.resolve(makeNetworkError(err))\n  }\n\n  // 6. If locationURL’s scheme is not an HTTP(S) scheme, then return a network\n  // error.\n  if (!urlIsHttpHttpsScheme(locationURL)) {\n    return Promise.resolve(makeNetworkError('URL scheme must be a HTTP(S) scheme'))\n  }\n\n  // 7. If request’s redirect count is 20, then return a network error.\n  if (request.redirectCount === 20) {\n    return Promise.resolve(makeNetworkError('redirect count exceeded'))\n  }\n\n  // 8. Increase request’s redirect count by 1.\n  request.redirectCount += 1\n\n  // 9. If request’s mode is \"cors\", locationURL includes credentials, and\n  // request’s origin is not same origin with locationURL’s origin, then return\n  //  a network error.\n  if (\n    request.mode === 'cors' &&\n    (locationURL.username || locationURL.password) &&\n    !sameOrigin(request, locationURL)\n  ) {\n    return Promise.resolve(makeNetworkError('cross origin not allowed for request mode \"cors\"'))\n  }\n\n  // 10. If request’s response tainting is \"cors\" and locationURL includes\n  // credentials, then return a network error.\n  if (\n    request.responseTainting === 'cors' &&\n    (locationURL.username || locationURL.password)\n  ) {\n    return Promise.resolve(makeNetworkError(\n      'URL cannot contain credentials for request mode \"cors\"'\n    ))\n  }\n\n  // 11. If actualResponse’s status is not 303, request’s body is non-null,\n  // and request’s body’s source is null, then return a network error.\n  if (\n    actualResponse.status !== 303 &&\n    request.body != null &&\n    request.body.source == null\n  ) {\n    return Promise.resolve(makeNetworkError())\n  }\n\n  // 12. If one of the following is true\n  // - actualResponse’s status is 301 or 302 and request’s method is `POST`\n  // - actualResponse’s status is 303 and request’s method is not `GET` or `HEAD`\n  if (\n    ([301, 302].includes(actualResponse.status) && request.method === 'POST') ||\n    (actualResponse.status === 303 &&\n      !GET_OR_HEAD.includes(request.method))\n  ) {\n    // then:\n    // 1. Set request’s method to `GET` and request’s body to null.\n    request.method = 'GET'\n    request.body = null\n\n    // 2. For each headerName of request-body-header name, delete headerName from\n    // request’s header list.\n    for (const headerName of requestBodyHeader) {\n      request.headersList.delete(headerName)\n    }\n  }\n\n  // 13. If request’s current URL’s origin is not same origin with locationURL’s\n  //     origin, then for each headerName of CORS non-wildcard request-header name,\n  //     delete headerName from request’s header list.\n  if (!sameOrigin(requestCurrentURL(request), locationURL)) {\n    // https://fetch.spec.whatwg.org/#cors-non-wildcard-request-header-name\n    request.headersList.delete('authorization', true)\n\n    // https://fetch.spec.whatwg.org/#authentication-entries\n    request.headersList.delete('proxy-authorization', true)\n\n    // \"Cookie\" and \"Host\" are forbidden request-headers, which undici doesn't implement.\n    request.headersList.delete('cookie', true)\n    request.headersList.delete('host', true)\n  }\n\n  // 14. If request’s body is non-null, then set request’s body to the first return\n  // value of safely extracting request’s body’s source.\n  if (request.body != null) {\n    assert(request.body.source != null)\n    request.body = safelyExtractBody(request.body.source)[0]\n  }\n\n  // 15. Let timingInfo be fetchParams’s timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 16. Set timingInfo’s redirect end time and post-redirect start time to the\n  // coarsened shared current time given fetchParams’s cross-origin isolated\n  // capability.\n  timingInfo.redirectEndTime = timingInfo.postRedirectStartTime =\n    coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)\n\n  // 17. If timingInfo’s redirect start time is 0, then set timingInfo’s\n  //  redirect start time to timingInfo’s start time.\n  if (timingInfo.redirectStartTime === 0) {\n    timingInfo.redirectStartTime = timingInfo.startTime\n  }\n\n  // 18. Append locationURL to request’s URL list.\n  request.urlList.push(locationURL)\n\n  // 19. Invoke set request’s referrer policy on redirect on request and\n  // actualResponse.\n  setRequestReferrerPolicyOnRedirect(request, actualResponse)\n\n  // 20. Return the result of running main fetch given fetchParams and true.\n  return mainFetch(fetchParams, true)\n}\n\n// https://fetch.spec.whatwg.org/#http-network-or-cache-fetch\nasync function httpNetworkOrCacheFetch (\n  fetchParams,\n  isAuthenticationFetch = false,\n  isNewConnectionFetch = false\n) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let httpFetchParams be null.\n  let httpFetchParams = null\n\n  // 3. Let httpRequest be null.\n  let httpRequest = null\n\n  // 4. Let response be null.\n  let response = null\n\n  // 5. Let storedResponse be null.\n  // TODO: cache\n\n  // 6. Let httpCache be null.\n  const httpCache = null\n\n  // 7. Let the revalidatingFlag be unset.\n  const revalidatingFlag = false\n\n  // 8. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. If request’s window is \"no-window\" and request’s redirect mode is\n  //    \"error\", then set httpFetchParams to fetchParams and httpRequest to\n  //    request.\n  if (request.window === 'no-window' && request.redirect === 'error') {\n    httpFetchParams = fetchParams\n    httpRequest = request\n  } else {\n    // Otherwise:\n\n    // 1. Set httpRequest to a clone of request.\n    httpRequest = cloneRequest(request)\n\n    // 2. Set httpFetchParams to a copy of fetchParams.\n    httpFetchParams = { ...fetchParams }\n\n    // 3. Set httpFetchParams’s request to httpRequest.\n    httpFetchParams.request = httpRequest\n  }\n\n  //    3. Let includeCredentials be true if one of\n  const includeCredentials =\n    request.credentials === 'include' ||\n    (request.credentials === 'same-origin' &&\n      request.responseTainting === 'basic')\n\n  //    4. Let contentLength be httpRequest’s body’s length, if httpRequest’s\n  //    body is non-null; otherwise null.\n  const contentLength = httpRequest.body ? httpRequest.body.length : null\n\n  //    5. Let contentLengthHeaderValue be null.\n  let contentLengthHeaderValue = null\n\n  //    6. If httpRequest’s body is null and httpRequest’s method is `POST` or\n  //    `PUT`, then set contentLengthHeaderValue to `0`.\n  if (\n    httpRequest.body == null &&\n    ['POST', 'PUT'].includes(httpRequest.method)\n  ) {\n    contentLengthHeaderValue = '0'\n  }\n\n  //    7. If contentLength is non-null, then set contentLengthHeaderValue to\n  //    contentLength, serialized and isomorphic encoded.\n  if (contentLength != null) {\n    contentLengthHeaderValue = isomorphicEncode(`${contentLength}`)\n  }\n\n  //    8. If contentLengthHeaderValue is non-null, then append\n  //    `Content-Length`/contentLengthHeaderValue to httpRequest’s header\n  //    list.\n  if (contentLengthHeaderValue != null) {\n    httpRequest.headersList.append('content-length', contentLengthHeaderValue, true)\n  }\n\n  //    9. If contentLengthHeaderValue is non-null, then append (`Content-Length`,\n  //    contentLengthHeaderValue) to httpRequest’s header list.\n\n  //    10. If contentLength is non-null and httpRequest’s keepalive is true,\n  //    then:\n  if (contentLength != null && httpRequest.keepalive) {\n    // NOTE: keepalive is a noop outside of browser context.\n  }\n\n  //    11. If httpRequest’s referrer is a URL, then append\n  //    `Referer`/httpRequest’s referrer, serialized and isomorphic encoded,\n  //     to httpRequest’s header list.\n  if (httpRequest.referrer instanceof URL) {\n    httpRequest.headersList.append('referer', isomorphicEncode(httpRequest.referrer.href), true)\n  }\n\n  //    12. Append a request `Origin` header for httpRequest.\n  appendRequestOriginHeader(httpRequest)\n\n  //    13. Append the Fetch metadata headers for httpRequest. [FETCH-METADATA]\n  appendFetchMetadata(httpRequest)\n\n  //    14. If httpRequest’s header list does not contain `User-Agent`, then\n  //    user agents should append `User-Agent`/default `User-Agent` value to\n  //    httpRequest’s header list.\n  if (!httpRequest.headersList.contains('user-agent', true)) {\n    httpRequest.headersList.append('user-agent', defaultUserAgent)\n  }\n\n  //    15. If httpRequest’s cache mode is \"default\" and httpRequest’s header\n  //    list contains `If-Modified-Since`, `If-None-Match`,\n  //    `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set\n  //    httpRequest’s cache mode to \"no-store\".\n  if (\n    httpRequest.cache === 'default' &&\n    (httpRequest.headersList.contains('if-modified-since', true) ||\n      httpRequest.headersList.contains('if-none-match', true) ||\n      httpRequest.headersList.contains('if-unmodified-since', true) ||\n      httpRequest.headersList.contains('if-match', true) ||\n      httpRequest.headersList.contains('if-range', true))\n  ) {\n    httpRequest.cache = 'no-store'\n  }\n\n  //    16. If httpRequest’s cache mode is \"no-cache\", httpRequest’s prevent\n  //    no-cache cache-control header modification flag is unset, and\n  //    httpRequest’s header list does not contain `Cache-Control`, then append\n  //    `Cache-Control`/`max-age=0` to httpRequest’s header list.\n  if (\n    httpRequest.cache === 'no-cache' &&\n    !httpRequest.preventNoCacheCacheControlHeaderModification &&\n    !httpRequest.headersList.contains('cache-control', true)\n  ) {\n    httpRequest.headersList.append('cache-control', 'max-age=0', true)\n  }\n\n  //    17. If httpRequest’s cache mode is \"no-store\" or \"reload\", then:\n  if (httpRequest.cache === 'no-store' || httpRequest.cache === 'reload') {\n    // 1. If httpRequest’s header list does not contain `Pragma`, then append\n    // `Pragma`/`no-cache` to httpRequest’s header list.\n    if (!httpRequest.headersList.contains('pragma', true)) {\n      httpRequest.headersList.append('pragma', 'no-cache', true)\n    }\n\n    // 2. If httpRequest’s header list does not contain `Cache-Control`,\n    // then append `Cache-Control`/`no-cache` to httpRequest’s header list.\n    if (!httpRequest.headersList.contains('cache-control', true)) {\n      httpRequest.headersList.append('cache-control', 'no-cache', true)\n    }\n  }\n\n  //    18. If httpRequest’s header list contains `Range`, then append\n  //    `Accept-Encoding`/`identity` to httpRequest’s header list.\n  if (httpRequest.headersList.contains('range', true)) {\n    httpRequest.headersList.append('accept-encoding', 'identity', true)\n  }\n\n  //    19. Modify httpRequest’s header list per HTTP. Do not append a given\n  //    header if httpRequest’s header list contains that header’s name.\n  //    TODO: https://github.com/whatwg/fetch/issues/1285#issuecomment-896560129\n  if (!httpRequest.headersList.contains('accept-encoding', true)) {\n    if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {\n      httpRequest.headersList.append('accept-encoding', 'br, gzip, deflate', true)\n    } else {\n      httpRequest.headersList.append('accept-encoding', 'gzip, deflate', true)\n    }\n  }\n\n  httpRequest.headersList.delete('host', true)\n\n  //    20. If includeCredentials is true, then:\n  if (includeCredentials) {\n    // 1. If the user agent is not configured to block cookies for httpRequest\n    // (see section 7 of [COOKIES]), then:\n    // TODO: credentials\n    // 2. If httpRequest’s header list does not contain `Authorization`, then:\n    // TODO: credentials\n  }\n\n  //    21. If there’s a proxy-authentication entry, use it as appropriate.\n  //    TODO: proxy-authentication\n\n  //    22. Set httpCache to the result of determining the HTTP cache\n  //    partition, given httpRequest.\n  //    TODO: cache\n\n  //    23. If httpCache is null, then set httpRequest’s cache mode to\n  //    \"no-store\".\n  if (httpCache == null) {\n    httpRequest.cache = 'no-store'\n  }\n\n  //    24. If httpRequest’s cache mode is neither \"no-store\" nor \"reload\",\n  //    then:\n  if (httpRequest.cache !== 'no-store' && httpRequest.cache !== 'reload') {\n    // TODO: cache\n  }\n\n  // 9. If aborted, then return the appropriate network error for fetchParams.\n  // TODO\n\n  // 10. If response is null, then:\n  if (response == null) {\n    // 1. If httpRequest’s cache mode is \"only-if-cached\", then return a\n    // network error.\n    if (httpRequest.cache === 'only-if-cached') {\n      return makeNetworkError('only if cached')\n    }\n\n    // 2. Let forwardResponse be the result of running HTTP-network fetch\n    // given httpFetchParams, includeCredentials, and isNewConnectionFetch.\n    const forwardResponse = await httpNetworkFetch(\n      httpFetchParams,\n      includeCredentials,\n      isNewConnectionFetch\n    )\n\n    // 3. If httpRequest’s method is unsafe and forwardResponse’s status is\n    // in the range 200 to 399, inclusive, invalidate appropriate stored\n    // responses in httpCache, as per the \"Invalidation\" chapter of HTTP\n    // Caching, and set storedResponse to null. [HTTP-CACHING]\n    if (\n      !safeMethodsSet.has(httpRequest.method) &&\n      forwardResponse.status >= 200 &&\n      forwardResponse.status <= 399\n    ) {\n      // TODO: cache\n    }\n\n    // 4. If the revalidatingFlag is set and forwardResponse’s status is 304,\n    // then:\n    if (revalidatingFlag && forwardResponse.status === 304) {\n      // TODO: cache\n    }\n\n    // 5. If response is null, then:\n    if (response == null) {\n      // 1. Set response to forwardResponse.\n      response = forwardResponse\n\n      // 2. Store httpRequest and forwardResponse in httpCache, as per the\n      // \"Storing Responses in Caches\" chapter of HTTP Caching. [HTTP-CACHING]\n      // TODO: cache\n    }\n  }\n\n  // 11. Set response’s URL list to a clone of httpRequest’s URL list.\n  response.urlList = [...httpRequest.urlList]\n\n  // 12. If httpRequest’s header list contains `Range`, then set response’s\n  // range-requested flag.\n  if (httpRequest.headersList.contains('range', true)) {\n    response.rangeRequested = true\n  }\n\n  // 13. Set response’s request-includes-credentials to includeCredentials.\n  response.requestIncludesCredentials = includeCredentials\n\n  // 14. If response’s status is 401, httpRequest’s response tainting is not\n  // \"cors\", includeCredentials is true, and request’s window is an environment\n  // settings object, then:\n  // TODO\n\n  // 15. If response’s status is 407, then:\n  if (response.status === 407) {\n    // 1. If request’s window is \"no-window\", then return a network error.\n    if (request.window === 'no-window') {\n      return makeNetworkError()\n    }\n\n    // 2. ???\n\n    // 3. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n    if (isCancelled(fetchParams)) {\n      return makeAppropriateNetworkError(fetchParams)\n    }\n\n    // 4. Prompt the end user as appropriate in request’s window and store\n    // the result as a proxy-authentication entry. [HTTP-AUTH]\n    // TODO: Invoke some kind of callback?\n\n    // 5. Set response to the result of running HTTP-network-or-cache fetch given\n    // fetchParams.\n    // TODO\n    return makeNetworkError('proxy authentication required')\n  }\n\n  // 16. If all of the following are true\n  if (\n    // response’s status is 421\n    response.status === 421 &&\n    // isNewConnectionFetch is false\n    !isNewConnectionFetch &&\n    // request’s body is null, or request’s body is non-null and request’s body’s source is non-null\n    (request.body == null || request.body.source != null)\n  ) {\n    // then:\n\n    // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n    if (isCancelled(fetchParams)) {\n      return makeAppropriateNetworkError(fetchParams)\n    }\n\n    // 2. Set response to the result of running HTTP-network-or-cache\n    // fetch given fetchParams, isAuthenticationFetch, and true.\n\n    // TODO (spec): The spec doesn't specify this but we need to cancel\n    // the active response before we can start a new one.\n    // https://github.com/whatwg/fetch/issues/1293\n    fetchParams.controller.connection.destroy()\n\n    response = await httpNetworkOrCacheFetch(\n      fetchParams,\n      isAuthenticationFetch,\n      true\n    )\n  }\n\n  // 17. If isAuthenticationFetch is true, then create an authentication entry\n  if (isAuthenticationFetch) {\n    // TODO\n  }\n\n  // 18. Return response.\n  return response\n}\n\n// https://fetch.spec.whatwg.org/#http-network-fetch\nasync function httpNetworkFetch (\n  fetchParams,\n  includeCredentials = false,\n  forceNewConnection = false\n) {\n  assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed)\n\n  fetchParams.controller.connection = {\n    abort: null,\n    destroyed: false,\n    destroy (err, abort = true) {\n      if (!this.destroyed) {\n        this.destroyed = true\n        if (abort) {\n          this.abort?.(err ?? new DOMException('The operation was aborted.', 'AbortError'))\n        }\n      }\n    }\n  }\n\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. Let timingInfo be fetchParams’s timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 4. Let httpCache be the result of determining the HTTP cache partition,\n  // given request.\n  // TODO: cache\n  const httpCache = null\n\n  // 5. If httpCache is null, then set request’s cache mode to \"no-store\".\n  if (httpCache == null) {\n    request.cache = 'no-store'\n  }\n\n  // 6. Let networkPartitionKey be the result of determining the network\n  // partition key given request.\n  // TODO\n\n  // 7. Let newConnection be \"yes\" if forceNewConnection is true; otherwise\n  // \"no\".\n  const newConnection = forceNewConnection ? 'yes' : 'no' // eslint-disable-line no-unused-vars\n\n  // 8. Switch on request’s mode:\n  if (request.mode === 'websocket') {\n    // Let connection be the result of obtaining a WebSocket connection,\n    // given request’s current URL.\n    // TODO\n  } else {\n    // Let connection be the result of obtaining a connection, given\n    // networkPartitionKey, request’s current URL’s origin,\n    // includeCredentials, and forceNewConnection.\n    // TODO\n  }\n\n  // 9. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. If connection is failure, then return a network error.\n\n  //    2. Set timingInfo’s final connection timing info to the result of\n  //    calling clamp and coarsen connection timing info with connection’s\n  //    timing info, timingInfo’s post-redirect start time, and fetchParams’s\n  //    cross-origin isolated capability.\n\n  //    3. If connection is not an HTTP/2 connection, request’s body is non-null,\n  //    and request’s body’s source is null, then append (`Transfer-Encoding`,\n  //    `chunked`) to request’s header list.\n\n  //    4. Set timingInfo’s final network-request start time to the coarsened\n  //    shared current time given fetchParams’s cross-origin isolated\n  //    capability.\n\n  //    5. Set response to the result of making an HTTP request over connection\n  //    using request with the following caveats:\n\n  //        - Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS]\n  //        [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]\n\n  //        - If request’s body is non-null, and request’s body’s source is null,\n  //        then the user agent may have a buffer of up to 64 kibibytes and store\n  //        a part of request’s body in that buffer. If the user agent reads from\n  //        request’s body beyond that buffer’s size and the user agent needs to\n  //        resend request, then instead return a network error.\n\n  //        - Set timingInfo’s final network-response start time to the coarsened\n  //        shared current time given fetchParams’s cross-origin isolated capability,\n  //        immediately after the user agent’s HTTP parser receives the first byte\n  //        of the response (e.g., frame header bytes for HTTP/2 or response status\n  //        line for HTTP/1.x).\n\n  //        - Wait until all the headers are transmitted.\n\n  //        - Any responses whose status is in the range 100 to 199, inclusive,\n  //        and is not 101, are to be ignored, except for the purposes of setting\n  //        timingInfo’s final network-response start time above.\n\n  //    - If request’s header list contains `Transfer-Encoding`/`chunked` and\n  //    response is transferred via HTTP/1.0 or older, then return a network\n  //    error.\n\n  //    - If the HTTP request results in a TLS client certificate dialog, then:\n\n  //        1. If request’s window is an environment settings object, make the\n  //        dialog available in request’s window.\n\n  //        2. Otherwise, return a network error.\n\n  // To transmit request’s body body, run these steps:\n  let requestBody = null\n  // 1. If body is null and fetchParams’s process request end-of-body is\n  // non-null, then queue a fetch task given fetchParams’s process request\n  // end-of-body and fetchParams’s task destination.\n  if (request.body == null && fetchParams.processRequestEndOfBody) {\n    queueMicrotask(() => fetchParams.processRequestEndOfBody())\n  } else if (request.body != null) {\n    // 2. Otherwise, if body is non-null:\n\n    //    1. Let processBodyChunk given bytes be these steps:\n    const processBodyChunk = async function * (bytes) {\n      // 1. If the ongoing fetch is terminated, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return\n      }\n\n      // 2. Run this step in parallel: transmit bytes.\n      yield bytes\n\n      // 3. If fetchParams’s process request body is non-null, then run\n      // fetchParams’s process request body given bytes’s length.\n      fetchParams.processRequestBodyChunkLength?.(bytes.byteLength)\n    }\n\n    // 2. Let processEndOfBody be these steps:\n    const processEndOfBody = () => {\n      // 1. If fetchParams is canceled, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return\n      }\n\n      // 2. If fetchParams’s process request end-of-body is non-null,\n      // then run fetchParams’s process request end-of-body.\n      if (fetchParams.processRequestEndOfBody) {\n        fetchParams.processRequestEndOfBody()\n      }\n    }\n\n    // 3. Let processBodyError given e be these steps:\n    const processBodyError = (e) => {\n      // 1. If fetchParams is canceled, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return\n      }\n\n      // 2. If e is an \"AbortError\" DOMException, then abort fetchParams’s controller.\n      if (e.name === 'AbortError') {\n        fetchParams.controller.abort()\n      } else {\n        fetchParams.controller.terminate(e)\n      }\n    }\n\n    // 4. Incrementally read request’s body given processBodyChunk, processEndOfBody,\n    // processBodyError, and fetchParams’s task destination.\n    requestBody = (async function * () {\n      try {\n        for await (const bytes of request.body.stream) {\n          yield * processBodyChunk(bytes)\n        }\n        processEndOfBody()\n      } catch (err) {\n        processBodyError(err)\n      }\n    })()\n  }\n\n  try {\n    // socket is only provided for websockets\n    const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody })\n\n    if (socket) {\n      response = makeResponse({ status, statusText, headersList, socket })\n    } else {\n      const iterator = body[Symbol.asyncIterator]()\n      fetchParams.controller.next = () => iterator.next()\n\n      response = makeResponse({ status, statusText, headersList })\n    }\n  } catch (err) {\n    // 10. If aborted, then:\n    if (err.name === 'AbortError') {\n      // 1. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n      fetchParams.controller.connection.destroy()\n\n      // 2. Return the appropriate network error for fetchParams.\n      return makeAppropriateNetworkError(fetchParams, err)\n    }\n\n    return makeNetworkError(err)\n  }\n\n  // 11. Let pullAlgorithm be an action that resumes the ongoing fetch\n  // if it is suspended.\n  const pullAlgorithm = async () => {\n    await fetchParams.controller.resume()\n  }\n\n  // 12. Let cancelAlgorithm be an algorithm that aborts fetchParams’s\n  // controller with reason, given reason.\n  const cancelAlgorithm = (reason) => {\n    // If the aborted fetch was already terminated, then we do not\n    // need to do anything.\n    if (!isCancelled(fetchParams)) {\n      fetchParams.controller.abort(reason)\n    }\n  }\n\n  // 13. Let highWaterMark be a non-negative, non-NaN number, chosen by\n  // the user agent.\n  // TODO\n\n  // 14. Let sizeAlgorithm be an algorithm that accepts a chunk object\n  // and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.\n  // TODO\n\n  // 15. Let stream be a new ReadableStream.\n  // 16. Set up stream with byte reading support with pullAlgorithm set to pullAlgorithm,\n  //     cancelAlgorithm set to cancelAlgorithm.\n  const stream = new ReadableStream(\n    {\n      async start (controller) {\n        fetchParams.controller.controller = controller\n      },\n      async pull (controller) {\n        await pullAlgorithm(controller)\n      },\n      async cancel (reason) {\n        await cancelAlgorithm(reason)\n      },\n      type: 'bytes'\n    }\n  )\n\n  // 17. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. Set response’s body to a new body whose stream is stream.\n  response.body = { stream, source: null, length: null }\n\n  //    2. If response is not a network error and request’s cache mode is\n  //    not \"no-store\", then update response in httpCache for request.\n  //    TODO\n\n  //    3. If includeCredentials is true and the user agent is not configured\n  //    to block cookies for request (see section 7 of [COOKIES]), then run the\n  //    \"set-cookie-string\" parsing algorithm (see section 5.2 of [COOKIES]) on\n  //    the value of each header whose name is a byte-case-insensitive match for\n  //    `Set-Cookie` in response’s header list, if any, and request’s current URL.\n  //    TODO\n\n  // 18. If aborted, then:\n  // TODO\n\n  // 19. Run these steps in parallel:\n\n  //    1. Run these steps, but abort when fetchParams is canceled:\n  fetchParams.controller.onAborted = onAborted\n  fetchParams.controller.on('terminated', onAborted)\n  fetchParams.controller.resume = async () => {\n    // 1. While true\n    while (true) {\n      // 1-3. See onData...\n\n      // 4. Set bytes to the result of handling content codings given\n      // codings and bytes.\n      let bytes\n      let isFailure\n      try {\n        const { done, value } = await fetchParams.controller.next()\n\n        if (isAborted(fetchParams)) {\n          break\n        }\n\n        bytes = done ? undefined : value\n      } catch (err) {\n        if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {\n          // zlib doesn't like empty streams.\n          bytes = undefined\n        } else {\n          bytes = err\n\n          // err may be propagated from the result of calling readablestream.cancel,\n          // which might not be an error. https://github.com/nodejs/undici/issues/2009\n          isFailure = true\n        }\n      }\n\n      if (bytes === undefined) {\n        // 2. Otherwise, if the bytes transmission for response’s message\n        // body is done normally and stream is readable, then close\n        // stream, finalize response for fetchParams and response, and\n        // abort these in-parallel steps.\n        readableStreamClose(fetchParams.controller.controller)\n\n        finalizeResponse(fetchParams, response)\n\n        return\n      }\n\n      // 5. Increase timingInfo’s decoded body size by bytes’s length.\n      timingInfo.decodedBodySize += bytes?.byteLength ?? 0\n\n      // 6. If bytes is failure, then terminate fetchParams’s controller.\n      if (isFailure) {\n        fetchParams.controller.terminate(bytes)\n        return\n      }\n\n      // 7. Enqueue a Uint8Array wrapping an ArrayBuffer containing bytes\n      // into stream.\n      const buffer = new Uint8Array(bytes)\n      if (buffer.byteLength) {\n        fetchParams.controller.controller.enqueue(buffer)\n      }\n\n      // 8. If stream is errored, then terminate the ongoing fetch.\n      if (isErrored(stream)) {\n        fetchParams.controller.terminate()\n        return\n      }\n\n      // 9. If stream doesn’t need more data ask the user agent to suspend\n      // the ongoing fetch.\n      if (fetchParams.controller.controller.desiredSize <= 0) {\n        return\n      }\n    }\n  }\n\n  //    2. If aborted, then:\n  function onAborted (reason) {\n    // 2. If fetchParams is aborted, then:\n    if (isAborted(fetchParams)) {\n      // 1. Set response’s aborted flag.\n      response.aborted = true\n\n      // 2. If stream is readable, then error stream with the result of\n      //    deserialize a serialized abort reason given fetchParams’s\n      //    controller’s serialized abort reason and an\n      //    implementation-defined realm.\n      if (isReadable(stream)) {\n        fetchParams.controller.controller.error(\n          fetchParams.controller.serializedAbortReason\n        )\n      }\n    } else {\n      // 3. Otherwise, if stream is readable, error stream with a TypeError.\n      if (isReadable(stream)) {\n        fetchParams.controller.controller.error(new TypeError('terminated', {\n          cause: isErrorLike(reason) ? reason : undefined\n        }))\n      }\n    }\n\n    // 4. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n    // 5. Otherwise, the user agent should close connection unless it would be bad for performance to do so.\n    fetchParams.controller.connection.destroy()\n  }\n\n  // 20. Return response.\n  return response\n\n  function dispatch ({ body }) {\n    const url = requestCurrentURL(request)\n    /** @type {import('../..').Agent} */\n    const agent = fetchParams.controller.dispatcher\n\n    return new Promise((resolve, reject) => agent.dispatch(\n      {\n        path: url.pathname + url.search,\n        origin: url.origin,\n        method: request.method,\n        body: agent.isMockActive ? request.body && (request.body.source || request.body.stream) : body,\n        headers: request.headersList.entries,\n        maxRedirections: 0,\n        upgrade: request.mode === 'websocket' ? 'websocket' : undefined\n      },\n      {\n        body: null,\n        abort: null,\n\n        onConnect (abort) {\n          // TODO (fix): Do we need connection here?\n          const { connection } = fetchParams.controller\n\n          // Set timingInfo’s final connection timing info to the result of calling clamp and coarsen\n          // connection timing info with connection’s timing info, timingInfo’s post-redirect start\n          // time, and fetchParams’s cross-origin isolated capability.\n          // TODO: implement connection timing\n          timingInfo.finalConnectionTimingInfo = clampAndCoarsenConnectionTimingInfo(undefined, timingInfo.postRedirectStartTime, fetchParams.crossOriginIsolatedCapability)\n\n          if (connection.destroyed) {\n            abort(new DOMException('The operation was aborted.', 'AbortError'))\n          } else {\n            fetchParams.controller.on('terminated', abort)\n            this.abort = connection.abort = abort\n          }\n\n          // Set timingInfo’s final network-request start time to the coarsened shared current time given\n          // fetchParams’s cross-origin isolated capability.\n          timingInfo.finalNetworkRequestStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)\n        },\n\n        onResponseStarted () {\n          // Set timingInfo’s final network-response start time to the coarsened shared current\n          // time given fetchParams’s cross-origin isolated capability, immediately after the\n          // user agent’s HTTP parser receives the first byte of the response (e.g., frame header\n          // bytes for HTTP/2 or response status line for HTTP/1.x).\n          timingInfo.finalNetworkResponseStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)\n        },\n\n        onHeaders (status, rawHeaders, resume, statusText) {\n          if (status < 200) {\n            return\n          }\n\n          /** @type {string[]} */\n          let codings = []\n          let location = ''\n\n          const headersList = new HeadersList()\n\n          for (let i = 0; i < rawHeaders.length; i += 2) {\n            headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString('latin1'), true)\n          }\n          const contentEncoding = headersList.get('content-encoding', true)\n          if (contentEncoding) {\n            // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1\n            // \"All content-coding values are case-insensitive...\"\n            codings = contentEncoding.toLowerCase().split(',').map((x) => x.trim())\n          }\n          location = headersList.get('location', true)\n\n          this.body = new Readable({ read: resume })\n\n          const decoders = []\n\n          const willFollow = location && request.redirect === 'follow' &&\n            redirectStatusSet.has(status)\n\n          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding\n          if (codings.length !== 0 && request.method !== 'HEAD' && request.method !== 'CONNECT' && !nullBodyStatus.includes(status) && !willFollow) {\n            for (let i = 0; i < codings.length; ++i) {\n              const coding = codings[i]\n              // https://www.rfc-editor.org/rfc/rfc9112.html#section-7.2\n              if (coding === 'x-gzip' || coding === 'gzip') {\n                decoders.push(zlib.createGunzip({\n                  // Be less strict when decoding compressed responses, since sometimes\n                  // servers send slightly invalid responses that are still accepted\n                  // by common browsers.\n                  // Always using Z_SYNC_FLUSH is what cURL does.\n                  flush: zlib.constants.Z_SYNC_FLUSH,\n                  finishFlush: zlib.constants.Z_SYNC_FLUSH\n                }))\n              } else if (coding === 'deflate') {\n                decoders.push(createInflate())\n              } else if (coding === 'br') {\n                decoders.push(zlib.createBrotliDecompress())\n              } else {\n                decoders.length = 0\n                break\n              }\n            }\n          }\n\n          resolve({\n            status,\n            statusText,\n            headersList,\n            body: decoders.length\n              ? pipeline(this.body, ...decoders, () => { })\n              : this.body.on('error', () => { })\n          })\n\n          return true\n        },\n\n        onData (chunk) {\n          if (fetchParams.controller.dump) {\n            return\n          }\n\n          // 1. If one or more bytes have been transmitted from response’s\n          // message body, then:\n\n          //  1. Let bytes be the transmitted bytes.\n          const bytes = chunk\n\n          //  2. Let codings be the result of extracting header list values\n          //  given `Content-Encoding` and response’s header list.\n          //  See pullAlgorithm.\n\n          //  3. Increase timingInfo’s encoded body size by bytes’s length.\n          timingInfo.encodedBodySize += bytes.byteLength\n\n          //  4. See pullAlgorithm...\n\n          return this.body.push(bytes)\n        },\n\n        onComplete () {\n          if (this.abort) {\n            fetchParams.controller.off('terminated', this.abort)\n          }\n\n          if (fetchParams.controller.onAborted) {\n            fetchParams.controller.off('terminated', fetchParams.controller.onAborted)\n          }\n\n          fetchParams.controller.ended = true\n\n          this.body.push(null)\n        },\n\n        onError (error) {\n          if (this.abort) {\n            fetchParams.controller.off('terminated', this.abort)\n          }\n\n          this.body?.destroy(error)\n\n          fetchParams.controller.terminate(error)\n\n          reject(error)\n        },\n\n        onUpgrade (status, rawHeaders, socket) {\n          if (status !== 101) {\n            return\n          }\n\n          const headersList = new HeadersList()\n\n          for (let i = 0; i < rawHeaders.length; i += 2) {\n            headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString('latin1'), true)\n          }\n\n          resolve({\n            status,\n            statusText: STATUS_CODES[status],\n            headersList,\n            socket\n          })\n\n          return true\n        }\n      }\n    ))\n  }\n}\n\nmodule.exports = {\n  fetch,\n  Fetch,\n  fetching,\n  finalizeAndReportTiming\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
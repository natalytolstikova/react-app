{"ast":null,"code":"'use strict';\n\nconst {\n  InvalidArgumentError\n} = require('../core/errors');\nconst {\n  kClients,\n  kRunning,\n  kClose,\n  kDestroy,\n  kDispatch,\n  kInterceptors\n} = require('../core/symbols');\nconst DispatcherBase = require('./dispatcher-base');\nconst Pool = require('./pool');\nconst Client = require('./client');\nconst util = require('../core/util');\nconst createRedirectInterceptor = require('../interceptor/redirect-interceptor');\nconst kOnConnect = Symbol('onConnect');\nconst kOnDisconnect = Symbol('onDisconnect');\nconst kOnConnectionError = Symbol('onConnectionError');\nconst kMaxRedirections = Symbol('maxRedirections');\nconst kOnDrain = Symbol('onDrain');\nconst kFactory = Symbol('factory');\nconst kOptions = Symbol('options');\nfunction defaultFactory(origin, opts) {\n  return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);\n}\nclass Agent extends DispatcherBase {\n  constructor({\n    factory = defaultFactory,\n    maxRedirections = 0,\n    connect,\n    ...options\n  } = {}) {\n    super();\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.');\n    }\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object');\n    }\n    if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number');\n    }\n    if (connect && typeof connect !== 'function') {\n      connect = {\n        ...connect\n      };\n    }\n    this[kInterceptors] = options.interceptors?.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor({\n      maxRedirections\n    })];\n    this[kOptions] = {\n      ...util.deepClone(options),\n      connect\n    };\n    this[kOptions].interceptors = options.interceptors ? {\n      ...options.interceptors\n    } : undefined;\n    this[kMaxRedirections] = maxRedirections;\n    this[kFactory] = factory;\n    this[kClients] = new Map();\n    this[kOnDrain] = (origin, targets) => {\n      this.emit('drain', origin, [this, ...targets]);\n    };\n    this[kOnConnect] = (origin, targets) => {\n      this.emit('connect', origin, [this, ...targets]);\n    };\n    this[kOnDisconnect] = (origin, targets, err) => {\n      this.emit('disconnect', origin, [this, ...targets], err);\n    };\n    this[kOnConnectionError] = (origin, targets, err) => {\n      this.emit('connectionError', origin, [this, ...targets], err);\n    };\n  }\n  get [kRunning]() {\n    let ret = 0;\n    for (const client of this[kClients].values()) {\n      ret += client[kRunning];\n    }\n    return ret;\n  }\n  [kDispatch](opts, handler) {\n    let key;\n    if (opts.origin && (typeof opts.origin === 'string' || opts.origin instanceof URL)) {\n      key = String(opts.origin);\n    } else {\n      throw new InvalidArgumentError('opts.origin must be a non-empty string or URL.');\n    }\n    let dispatcher = this[kClients].get(key);\n    if (!dispatcher) {\n      dispatcher = this[kFactory](opts.origin, this[kOptions]).on('drain', this[kOnDrain]).on('connect', this[kOnConnect]).on('disconnect', this[kOnDisconnect]).on('connectionError', this[kOnConnectionError]);\n\n      // This introduces a tiny memory leak, as dispatchers are never removed from the map.\n      // TODO(mcollina): remove te timer when the client/pool do not have any more\n      // active connections.\n      this[kClients].set(key, dispatcher);\n    }\n    return dispatcher.dispatch(opts, handler);\n  }\n  async [kClose]() {\n    const closePromises = [];\n    for (const client of this[kClients].values()) {\n      closePromises.push(client.close());\n    }\n    this[kClients].clear();\n    await Promise.all(closePromises);\n  }\n  async [kDestroy](err) {\n    const destroyPromises = [];\n    for (const client of this[kClients].values()) {\n      destroyPromises.push(client.destroy(err));\n    }\n    this[kClients].clear();\n    await Promise.all(destroyPromises);\n  }\n}\nmodule.exports = Agent;","map":{"version":3,"names":["InvalidArgumentError","require","kClients","kRunning","kClose","kDestroy","kDispatch","kInterceptors","DispatcherBase","Pool","Client","util","createRedirectInterceptor","kOnConnect","Symbol","kOnDisconnect","kOnConnectionError","kMaxRedirections","kOnDrain","kFactory","kOptions","defaultFactory","origin","opts","connections","Agent","constructor","factory","maxRedirections","connect","options","Number","isInteger","interceptors","Array","isArray","deepClone","undefined","Map","targets","emit","err","ret","client","values","handler","key","URL","String","dispatcher","get","on","set","dispatch","closePromises","push","close","clear","Promise","all","destroyPromises","destroy","module","exports"],"sources":["/Users/nataliia/PussyProjects/react-app/node_modules/undici/lib/dispatcher/agent.js"],"sourcesContent":["'use strict'\n\nconst { InvalidArgumentError } = require('../core/errors')\nconst { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = require('../core/symbols')\nconst DispatcherBase = require('./dispatcher-base')\nconst Pool = require('./pool')\nconst Client = require('./client')\nconst util = require('../core/util')\nconst createRedirectInterceptor = require('../interceptor/redirect-interceptor')\n\nconst kOnConnect = Symbol('onConnect')\nconst kOnDisconnect = Symbol('onDisconnect')\nconst kOnConnectionError = Symbol('onConnectionError')\nconst kMaxRedirections = Symbol('maxRedirections')\nconst kOnDrain = Symbol('onDrain')\nconst kFactory = Symbol('factory')\nconst kOptions = Symbol('options')\n\nfunction defaultFactory (origin, opts) {\n  return opts && opts.connections === 1\n    ? new Client(origin, opts)\n    : new Pool(origin, opts)\n}\n\nclass Agent extends DispatcherBase {\n  constructor ({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {\n    super()\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    if (connect && typeof connect !== 'function') {\n      connect = { ...connect }\n    }\n\n    this[kInterceptors] = options.interceptors?.Agent && Array.isArray(options.interceptors.Agent)\n      ? options.interceptors.Agent\n      : [createRedirectInterceptor({ maxRedirections })]\n\n    this[kOptions] = { ...util.deepClone(options), connect }\n    this[kOptions].interceptors = options.interceptors\n      ? { ...options.interceptors }\n      : undefined\n    this[kMaxRedirections] = maxRedirections\n    this[kFactory] = factory\n    this[kClients] = new Map()\n\n    this[kOnDrain] = (origin, targets) => {\n      this.emit('drain', origin, [this, ...targets])\n    }\n\n    this[kOnConnect] = (origin, targets) => {\n      this.emit('connect', origin, [this, ...targets])\n    }\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      this.emit('disconnect', origin, [this, ...targets], err)\n    }\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      this.emit('connectionError', origin, [this, ...targets], err)\n    }\n  }\n\n  get [kRunning] () {\n    let ret = 0\n    for (const client of this[kClients].values()) {\n      ret += client[kRunning]\n    }\n    return ret\n  }\n\n  [kDispatch] (opts, handler) {\n    let key\n    if (opts.origin && (typeof opts.origin === 'string' || opts.origin instanceof URL)) {\n      key = String(opts.origin)\n    } else {\n      throw new InvalidArgumentError('opts.origin must be a non-empty string or URL.')\n    }\n\n    let dispatcher = this[kClients].get(key)\n\n    if (!dispatcher) {\n      dispatcher = this[kFactory](opts.origin, this[kOptions])\n        .on('drain', this[kOnDrain])\n        .on('connect', this[kOnConnect])\n        .on('disconnect', this[kOnDisconnect])\n        .on('connectionError', this[kOnConnectionError])\n\n      // This introduces a tiny memory leak, as dispatchers are never removed from the map.\n      // TODO(mcollina): remove te timer when the client/pool do not have any more\n      // active connections.\n      this[kClients].set(key, dispatcher)\n    }\n\n    return dispatcher.dispatch(opts, handler)\n  }\n\n  async [kClose] () {\n    const closePromises = []\n    for (const client of this[kClients].values()) {\n      closePromises.push(client.close())\n    }\n    this[kClients].clear()\n\n    await Promise.all(closePromises)\n  }\n\n  async [kDestroy] (err) {\n    const destroyPromises = []\n    for (const client of this[kClients].values()) {\n      destroyPromises.push(client.destroy(err))\n    }\n    this[kClients].clear()\n\n    await Promise.all(destroyPromises)\n  }\n}\n\nmodule.exports = Agent\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
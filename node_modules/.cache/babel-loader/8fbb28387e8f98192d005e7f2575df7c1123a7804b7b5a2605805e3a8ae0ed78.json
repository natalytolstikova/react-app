{"ast":null,"code":"'use strict';\n\nconst {\n  maxUnsigned16Bit\n} = require('./constants');\nconst BUFFER_SIZE = 16386;\n\n/** @type {import('crypto')} */\nlet crypto;\nlet buffer = null;\nlet bufIdx = BUFFER_SIZE;\ntry {\n  crypto = require('node:crypto');\n  /* c8 ignore next 3 */\n} catch {\n  crypto = {\n    // not full compatibility, but minimum.\n    randomFillSync: function randomFillSync(buffer, _offset, _size) {\n      for (let i = 0; i < buffer.length; ++i) {\n        buffer[i] = Math.random() * 255 | 0;\n      }\n      return buffer;\n    }\n  };\n}\nfunction generateMask() {\n  if (bufIdx === BUFFER_SIZE) {\n    bufIdx = 0;\n    crypto.randomFillSync(buffer ??= Buffer.allocUnsafe(BUFFER_SIZE), 0, BUFFER_SIZE);\n  }\n  return [buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++]];\n}\nclass WebsocketFrameSend {\n  /**\n   * @param {Buffer|undefined} data\n   */\n  constructor(data) {\n    this.frameData = data;\n  }\n  createFrame(opcode) {\n    const frameData = this.frameData;\n    const maskKey = generateMask();\n    const bodyLength = frameData?.byteLength ?? 0;\n\n    /** @type {number} */\n    let payloadLength = bodyLength; // 0-125\n    let offset = 6;\n    if (bodyLength > maxUnsigned16Bit) {\n      offset += 8; // payload length is next 8 bytes\n      payloadLength = 127;\n    } else if (bodyLength > 125) {\n      offset += 2; // payload length is next 2 bytes\n      payloadLength = 126;\n    }\n    const buffer = Buffer.allocUnsafe(bodyLength + offset);\n\n    // Clear first 2 bytes, everything else is overwritten\n    buffer[0] = buffer[1] = 0;\n    buffer[0] |= 0x80; // FIN\n    buffer[0] = (buffer[0] & 0xF0) + opcode; // opcode\n\n    /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */\n    buffer[offset - 4] = maskKey[0];\n    buffer[offset - 3] = maskKey[1];\n    buffer[offset - 2] = maskKey[2];\n    buffer[offset - 1] = maskKey[3];\n    buffer[1] = payloadLength;\n    if (payloadLength === 126) {\n      buffer.writeUInt16BE(bodyLength, 2);\n    } else if (payloadLength === 127) {\n      // Clear extended payload length\n      buffer[2] = buffer[3] = 0;\n      buffer.writeUIntBE(bodyLength, 4, 6);\n    }\n    buffer[1] |= 0x80; // MASK\n\n    // mask body\n    for (let i = 0; i < bodyLength; ++i) {\n      buffer[offset + i] = frameData[i] ^ maskKey[i & 3];\n    }\n    return buffer;\n  }\n}\nmodule.exports = {\n  WebsocketFrameSend\n};","map":{"version":3,"names":["maxUnsigned16Bit","require","BUFFER_SIZE","crypto","buffer","bufIdx","randomFillSync","_offset","_size","i","length","Math","random","generateMask","Buffer","allocUnsafe","WebsocketFrameSend","constructor","data","frameData","createFrame","opcode","maskKey","bodyLength","byteLength","payloadLength","offset","writeUInt16BE","writeUIntBE","module","exports"],"sources":["/Users/nataliia/PussyProjects/react-app/node_modules/undici/lib/web/websocket/frame.js"],"sourcesContent":["'use strict'\n\nconst { maxUnsigned16Bit } = require('./constants')\n\nconst BUFFER_SIZE = 16386\n\n/** @type {import('crypto')} */\nlet crypto\nlet buffer = null\nlet bufIdx = BUFFER_SIZE\n\ntry {\n  crypto = require('node:crypto')\n/* c8 ignore next 3 */\n} catch {\n  crypto = {\n    // not full compatibility, but minimum.\n    randomFillSync: function randomFillSync (buffer, _offset, _size) {\n      for (let i = 0; i < buffer.length; ++i) {\n        buffer[i] = Math.random() * 255 | 0\n      }\n      return buffer\n    }\n  }\n}\n\nfunction generateMask () {\n  if (bufIdx === BUFFER_SIZE) {\n    bufIdx = 0\n    crypto.randomFillSync((buffer ??= Buffer.allocUnsafe(BUFFER_SIZE)), 0, BUFFER_SIZE)\n  }\n  return [buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++]]\n}\n\nclass WebsocketFrameSend {\n  /**\n   * @param {Buffer|undefined} data\n   */\n  constructor (data) {\n    this.frameData = data\n  }\n\n  createFrame (opcode) {\n    const frameData = this.frameData\n    const maskKey = generateMask()\n    const bodyLength = frameData?.byteLength ?? 0\n\n    /** @type {number} */\n    let payloadLength = bodyLength // 0-125\n    let offset = 6\n\n    if (bodyLength > maxUnsigned16Bit) {\n      offset += 8 // payload length is next 8 bytes\n      payloadLength = 127\n    } else if (bodyLength > 125) {\n      offset += 2 // payload length is next 2 bytes\n      payloadLength = 126\n    }\n\n    const buffer = Buffer.allocUnsafe(bodyLength + offset)\n\n    // Clear first 2 bytes, everything else is overwritten\n    buffer[0] = buffer[1] = 0\n    buffer[0] |= 0x80 // FIN\n    buffer[0] = (buffer[0] & 0xF0) + opcode // opcode\n\n    /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */\n    buffer[offset - 4] = maskKey[0]\n    buffer[offset - 3] = maskKey[1]\n    buffer[offset - 2] = maskKey[2]\n    buffer[offset - 1] = maskKey[3]\n\n    buffer[1] = payloadLength\n\n    if (payloadLength === 126) {\n      buffer.writeUInt16BE(bodyLength, 2)\n    } else if (payloadLength === 127) {\n      // Clear extended payload length\n      buffer[2] = buffer[3] = 0\n      buffer.writeUIntBE(bodyLength, 4, 6)\n    }\n\n    buffer[1] |= 0x80 // MASK\n\n    // mask body\n    for (let i = 0; i < bodyLength; ++i) {\n      buffer[offset + i] = frameData[i] ^ maskKey[i & 3]\n    }\n\n    return buffer\n  }\n}\n\nmodule.exports = {\n  WebsocketFrameSend\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}